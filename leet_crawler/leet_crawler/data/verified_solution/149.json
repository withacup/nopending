{"solution_code": "  /*--newline--     *  A line is determined by two factors,say y=ax+b--newline--     *  --newline--     *  If two points(x1,y1) (x2,y2) are on the same line(Of course). --newline----newline--     *  Consider the gap between two points.--newline----newline--     *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant--newline----newline--     *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b--newline----newline--     *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a--newline----newline--     *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a--newline----newline--     *  So we can use y0&x0 to track a line;--newline--     */--newline--    --newline--    public class Solution{--newline--        public int maxPoints(Point[] points) {--newline--            if (points==null) return 0;--newline--            if (points.length<=2) return points.length;--newline--            --newline--            Map<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();--newline--            int result=0;--newline--            for (int i=0;i<points.length;i++){ --newline--                map.clear();--newline--                int overlap=0,max=0;--newline--                for (int j=i+1;j<points.length;j++){--newline--                    int x=points[j].x-points[i].x;--newline--                    int y=points[j].y-points[i].y;--newline--                    if (x==0&&y==0){--newline--                        overlap++;--newline--                        continue;--newline--                    }--newline--                    int gcd=generateGCD(x,y);--newline--                    if (gcd!=0){--newline--                        x/=gcd;--newline--                        y/=gcd;--newline--                    }--newline--                    --newline--                    if (map.containsKey(x)){--newline--                        if (map.get(x).containsKey(y)){--newline--                            map.get(x).put(y, map.get(x).get(y)+1);--newline--                        }else{--newline--                            map.get(x).put(y, 1);--newline--                        }                       --newline--                    }else{--newline--                        Map<Integer,Integer> m = new HashMap<Integer,Integer>();--newline--                        m.put(y, 1);--newline--                        map.put(x, m);--newline--                    }--newline--                    max=Math.max(max, map.get(x).get(y));--newline--                }--newline--                result=Math.max(result, max+overlap+1);--newline--            }--newline--            return result;--newline--            --newline--            --newline--        }--newline--        private int generateGCD(int a,int b){--newline--    --newline--            if (b==0) return a;--newline--            else return generateGCD(b,a%b);--newline--            --newline--        }--newline--    }", "modified_code": null, "total_cases": 34, "l_type": "java"}