{"solution_code": "public class Solution {--newline--    public double[] medianSlidingWindow(int[] nums, int k) {--newline--        double[] res = new double[nums.length-k+1];--newline--        TreeMap<Integer, Integer> minHeap = new TreeMap<Integer, Integer>();--newline--        TreeMap<Integer, Integer> maxHeap = new TreeMap<Integer, Integer>(Collections.reverseOrder());--newline--        --newline--        int minHeapCap = k/2; //smaller heap when k is odd.--newline--        int maxHeapCap = k - minHeapCap; --newline--        --newline--        for(int i=0; i< k; i++){--newline--            maxHeap.put(nums[i], maxHeap.getOrDefault(nums[i], 0) + 1);--newline--        }--newline--        int[] minHeapSize = new int[]{0};--newline--        int[] maxHeapSize = new int[]{k};--newline--        for(int i=0; i< minHeapCap; i++){--newline--            move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--        }--newline--        --newline--        res[0] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--        int resIdx = 1;--newline--        --newline--        for(int i=0; i< nums.length-k; i++){--newline--            int addee = nums[i+k];--newline--            if(addee <= maxHeap.keySet().iterator().next()){--newline--                add(addee, maxHeap, maxHeapSize);--newline--            } else {--newline--                add(addee, minHeap, minHeapSize);--newline--            }--newline--            --newline--            int removee = nums[i];--newline--            if(removee <= maxHeap.keySet().iterator().next()){--newline--                remove(removee, maxHeap, maxHeapSize);--newline--            } else {--newline--                remove(removee, minHeap, minHeapSize);--newline--            }--newline----newline--            //rebalance--newline--            if(minHeapSize[0] > minHeapCap){--newline--                move1Over(minHeap, maxHeap, minHeapSize, maxHeapSize);--newline--            } else if(minHeapSize[0] < minHeapCap){--newline--                move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--            }--newline--            --newline--            res[resIdx] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--            resIdx++;--newline--        }--newline--        return res;--newline--    }--newline----newline--    public double getMedian(TreeMap<Integer, Integer> bigHeap, TreeMap<Integer, Integer> smallHeap, int[] bigHeapSize, int[] smallHeapSize){--newline--        return bigHeapSize[0] > smallHeapSize[0] ? (double) bigHeap.keySet().iterator().next() : ((double) bigHeap.keySet().iterator().next() + (double) smallHeap.keySet().iterator().next()) / 2.0;--newline--    }--newline--    --newline--    //move the top element of heap1 to heap2--newline--    public void move1Over(TreeMap<Integer, Integer> heap1, TreeMap<Integer, Integer> heap2, int[] heap1Size, int[] heap2Size){--newline--        int peek = heap1.keySet().iterator().next();--newline--        add(peek, heap2, heap2Size);--newline--        remove(peek, heap1, heap1Size);--newline--    }--newline--    --newline--    public void add(int val, TreeMap<Integer, Integer> heap, int[] heapSize){--newline--        heap.put(val, heap.getOrDefault(val,0) + 1);--newline--        heapSize[0]++;--newline--    }--newline--    --newline--    public void remove(int val, TreeMap<Integer, Integer> heap, int[] heapSize){--newline--        if(heap.put(val, heap.get(val) - 1) == 1) heap.remove(val);--newline--        heapSize[0]--;--newline--    }--newline--}--newline--", "modified_code": null, "total_cases": 42, "l_type": "java"}