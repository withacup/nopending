{"solution_code": "public class Solution {--newline--  --newline--  public int findKthLargest(int[] a, int k) {--newline--    int n = a.length;--newline--    int p = quickSelect(a, 0, n - 1, n - k + 1);--newline--    return a[p];--newline--  }--newline--  --newline--  // return the index of the kth smallest number--newline--  int quickSelect(int[] a, int lo, int hi, int k) {--newline--    // use quick sort's idea--newline--    // put nums that are <= pivot to the left--newline--    // put nums that are  > pivot to the right--newline--    int i = lo, j = hi, pivot = a[hi];--newline--    while (i < j) {--newline--      if (a[i++] > pivot) swap(a, --i, --j);--newline--    }--newline--    swap(a, i, hi);--newline--    --newline--    // count the nums that are <= pivot from lo--newline--    int m = i - lo + 1;--newline--    --newline--    // pivot is the one!--newline--    if (m == k)     return i;--newline--    // pivot is too big, so it must be on the left--newline--    else if (m > k) return quickSelect(a, lo, i - 1, k);--newline--    // pivot is too small, so it must be on the right--newline--    else            return quickSelect(a, i + 1, hi, k - m);--newline--  }--newline--  --newline--  void swap(int[] a, int i, int j) {--newline--    int tmp = a[i];--newline--    a[i] = a[j];--newline--    a[j] = tmp;--newline--  }--newline----newline--}", "modified_code": null, "total_cases": 31, "l_type": "java"}