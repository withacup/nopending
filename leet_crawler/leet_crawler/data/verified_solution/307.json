{
    "solution_code": "public class NumArray {--newline--    /**--newline--     * Binary Indexed Trees (BIT or Fenwick tree):--newline--     * https://www.topcoder.com/community/data-science/data-science---newline--     * tutorials/binary-indexed-trees/--newline--     * --newline--     * Example: given an array a[0]...a[7], we use a array BIT[9] to--newline--     * represent a tree, where index [2] is the parent of [1] and [3], [6]--newline--     * is the parent of [5] and [7], [4] is the parent of [2] and [6], and--newline--     * [8] is the parent of [4]. I.e.,--newline--     * --newline--     * BIT[] as a binary tree:--newline--     *            ______________*--newline--     *            ______*--newline--     *            __*     __*--newline--     *            *   *   *   *--newline--     * indices: 0 1 2 3 4 5 6 7 8--newline--     * --newline--     * BIT[i] = ([i] is a left child) ? the partial sum from its left most--newline--     * descendant to itself : the partial sum from its parent (exclusive) to--newline--     * itself. (check the range of \"__\").--newline--     * --newline--     * Eg. BIT[1]=a[0], BIT[2]=a[1]+BIT[1]=a[1]+a[0], BIT[3]=a[2],--newline--     * BIT[4]=a[3]+BIT[3]+BIT[2]=a[3]+a[2]+a[1]+a[0],--newline--     * BIT[6]=a[5]+BIT[5]=a[5]+a[4],--newline--     * BIT[8]=a[7]+BIT[7]+BIT[6]+BIT[4]=a[7]+a[6]+...+a[0], ...--newline--     * --newline--     * Thus, to update a[1]=BIT[2], we shall update BIT[2], BIT[4], BIT[8],--newline--     * i.e., for current [i], the next update [j] is j=i+(i&-i) //double the--newline--     * last 1-bit from [i].--newline--     * --newline--     * Similarly, to get the partial sum up to a[6]=BIT[7], we shall get the--newline--     * sum of BIT[7], BIT[6], BIT[4], i.e., for current [i], the next--newline--     * summand [j] is j=i-(i&-i) // delete the last 1-bit from [i].--newline--     * --newline--     * To obtain the original value of a[7] (corresponding to index [8] of--newline--     * BIT), we have to subtract BIT[7], BIT[6], BIT[4] from BIT[8], i.e.,--newline--     * starting from [idx-1], for current [i], the next subtrahend [j] is--newline--     * j=i-(i&-i), up to j==idx-(idx&-idx) exclusive. (However, a quicker--newline--     * way but using extra space is to store the original array.)--newline--     */--newline----newline--    int[] nums;--newline--    int[] BIT;--newline--    int n;--newline----newline--    public NumArray(int[] nums) {--newline--        this.nums = nums;--newline----newline--        n = nums.length;--newline--        BIT = new int[n + 1];--newline--        for (int i = 0; i < n; i++)--newline--            init(i, nums[i]);--newline--    }--newline----newline--    public void init(int i, int val) {--newline--        i++;--newline--        while (i <= n) {--newline--            BIT[i] += val;--newline--            i += (i & -i);--newline--        }--newline--    }--newline----newline--    void update(int i, int val) {--newline--        int diff = val - nums[i];--newline--        nums[i] = val;--newline--        init(i, diff);--newline--    }--newline----newline--    public int getSum(int i) {--newline--        int sum = 0;--newline--        i++;--newline--        while (i > 0) {--newline--            sum += BIT[i];--newline--            i -= (i & -i);--newline--        }--newline--        return sum;--newline--    }--newline----newline--    public int sumRange(int i, int j) {--newline--        return getSum(j) - getSum(i - 1);--newline--    }--newline--}--newline----newline--// Your NumArray object will be instantiated and called as such:--newline--// NumArray numArray = new NumArray(nums);--newline--// numArray.sumRange(0, 1);--newline--// numArray.update(1, 10);--newline--// numArray.sumRange(1, 2);",
    "l_type": "java",
    "modified_code": null,
    "total_cases": 10
}