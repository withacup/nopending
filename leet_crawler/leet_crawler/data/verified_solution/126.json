{"solution_code": "public class Solution {--newline--    public List<List<String>> findLadders(String start, String end, List<String> wordList) {--newline--       HashSet<String> dict = new HashSet<String>(wordList);--newline--       List<List<String>> res = new ArrayList<List<String>>();         --newline--       HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node--newline--       HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node--newline--       ArrayList<String> solution = new ArrayList<String>();--newline--    --newline--       dict.add(start);          --newline--       bfs(start, end, dict, nodeNeighbors, distance);                 --newline--       dfs(start, end, dict, nodeNeighbors, distance, solution, res);   --newline--       return res;--newline--    }--newline--    --newline--    // BFS: Trace every node's distance from the start node (level by level).--newline--    private void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {--newline--      for (String str : dict)--newline--          nodeNeighbors.put(str, new ArrayList<String>());--newline--    --newline--      Queue<String> queue = new LinkedList<String>();--newline--      queue.offer(start);--newline--      distance.put(start, 0);--newline--    --newline--      while (!queue.isEmpty()) {--newline--          int count = queue.size();--newline--          boolean foundEnd = false;--newline--          for (int i = 0; i < count; i++) {--newline--              String cur = queue.poll();--newline--              int curDistance = distance.get(cur);                --newline--              ArrayList<String> neighbors = getNeighbors(cur, dict);--newline--    --newline--              for (String neighbor : neighbors) {--newline--                  nodeNeighbors.get(cur).add(neighbor);--newline--                  if (!distance.containsKey(neighbor)) {// Check if visited--newline--                      distance.put(neighbor, curDistance + 1);--newline--                      if (end.equals(neighbor))// Found the shortest path--newline--                          foundEnd = true;--newline--                      else--newline--                          queue.offer(neighbor);--newline--                      }--newline--                  }--newline--              }--newline--    --newline--              if (foundEnd)--newline--                  break;--newline--          }--newline--      }--newline--    --newline--    // Find all next level nodes.    --newline--    private ArrayList<String> getNeighbors(String node, Set<String> dict) {--newline--      ArrayList<String> res = new ArrayList<String>();--newline--      char chs[] = node.toCharArray();--newline--    --newline--      for (char ch ='a'; ch <= 'z'; ch++) {--newline--          for (int i = 0; i < chs.length; i++) {--newline--              if (chs[i] == ch) continue;--newline--              char old_ch = chs[i];--newline--              chs[i] = ch;--newline--              if (dict.contains(String.valueOf(chs))) {--newline--                  res.add(String.valueOf(chs));--newline--              }--newline--              chs[i] = old_ch;--newline--          }--newline--    --newline--      }--newline--      return res;--newline--    }--newline--    --newline--    // DFS: output all paths with the shortest distance.--newline--    private void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {--newline--        solution.add(cur);--newline--        if (end.equals(cur)) {--newline--           res.add(new ArrayList<String>(solution));--newline--        } else {--newline--           for (String next : nodeNeighbors.get(cur)) {            --newline--                if (distance.get(next) == distance.get(cur) + 1) {--newline--                     dfs(next, end, dict, nodeNeighbors, distance, solution, res);--newline--                }--newline--            }--newline--        }           --newline--       solution.remove(solution.size() - 1);--newline--    }--newline--    --newline--}", "modified_code": null, "total_cases": 39, "l_type": "java"}