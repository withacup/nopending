{"solution_code": "--newline--public class Solution {--newline----newline--    public class Cell {--newline--        int row;--newline--        int col;--newline--        int height;--newline--        public Cell(int row, int col, int height) {--newline--            this.row = row;--newline--            this.col = col;--newline--            this.height = height;--newline--        }--newline--    }--newline----newline--    public int trapRainWater(int[][] heights) {--newline--        if (heights == null || heights.length == 0 || heights[0].length == 0)--newline--            return 0;--newline----newline--        PriorityQueue<Cell> queue = new PriorityQueue<>(1, new Comparator<Cell>(){--newline--            public int compare(Cell a, Cell b) {--newline--                return a.height - b.height;--newline--            }--newline--        });--newline--        --newline--        int m = heights.length;--newline--        int n = heights[0].length;--newline--        boolean[][] visited = new boolean[m][n];--newline----newline--        // Initially, add all the Cells which are on borders to the queue.--newline--        for (int i = 0; i < m; i++) {--newline--            visited[i][0] = true;--newline--            visited[i][n - 1] = true;--newline--            queue.offer(new Cell(i, 0, heights[i][0]));--newline--            queue.offer(new Cell(i, n - 1, heights[i][n - 1]));--newline--        }--newline----newline--        for (int i = 0; i < n; i++) {--newline--            visited[0][i] = true;--newline--            visited[m - 1][i] = true;--newline--            queue.offer(new Cell(0, i, heights[0][i]));--newline--            queue.offer(new Cell(m - 1, i, heights[m - 1][i]));--newline--        }--newline----newline--        // from the borders, pick the shortest cell visited and check its neighbors:--newline--        // if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped--newline--       // add all its neighbors to the queue.--newline--        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};--newline--        int res = 0;--newline--        while (!queue.isEmpty()) {--newline--            Cell cell = queue.poll();--newline--            for (int[] dir : dirs) {--newline--                int row = cell.row + dir[0];--newline--                int col = cell.col + dir[1];--newline--                if (row >= 0 && row < m && col >= 0 && col < n && !visited[row][col]) {--newline--                    visited[row][col] = true;--newline--                    res += Math.max(0, cell.height - heights[row][col]);--newline--                    queue.offer(new Cell(row, col, Math.max(heights[row][col], cell.height)));--newline--                }--newline--            }--newline--        }--newline--        --newline--        return res;--newline--    }--newline--}--newline--", "modified_code": null, "total_cases": 40, "l_type": "java"}