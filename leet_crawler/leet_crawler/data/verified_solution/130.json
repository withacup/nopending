{
    "solution_code": "public class Solution {--newline--    public void solve(char[][] board) {--newline--        if (board.length == 0 || board[0].length == 0)--newline--            return;--newline--        if (board.length < 2 || board[0].length < 2)--newline--            return;--newline--        int m = board.length, n = board[0].length;--newline--        //Any 'O' connected to a boundary can't be turned to 'X', so ...--newline--        //Start from first and last column, turn 'O' to '*'.--newline--        for (int i = 0; i < m; i++) {--newline--            if (board[i][0] == 'O')--newline--                boundaryDFS(board, i, 0);--newline--            if (board[i][n-1] == 'O')--newline--                boundaryDFS(board, i, n-1);    --newline--        }--newline--        //Start from first and last row, turn '0' to '*'--newline--        for (int j = 0; j < n; j++) {--newline--            if (board[0][j] == 'O')--newline--                boundaryDFS(board, 0, j);--newline--            if (board[m-1][j] == 'O')--newline--                boundaryDFS(board, m-1, j);    --newline--        }--newline--        //post-prcessing, turn 'O' to 'X', '*' back to 'O', keep 'X' intact.--newline--        for (int i = 0; i < m; i++) {--newline--            for (int j = 0; j < n; j++) {--newline--                if (board[i][j] == 'O')--newline--                    board[i][j] = 'X';--newline--                else if (board[i][j] == '*')--newline--                    board[i][j] = 'O';--newline--            }--newline--        }--newline--    }--newline--    //Use DFS algo to turn internal however boundary-connected 'O' to '*';--newline--    private void boundaryDFS(char[][] board, int i, int j) {--newline--        if (i < 0 || i > board.length - 1 || j <0 || j > board[0].length - 1)--newline--            return;--newline--        if (board[i][j] == 'O')--newline--            board[i][j] = '*';--newline--        if (i > 1 && board[i-1][j] == 'O')--newline--            boundaryDFS(board, i-1, j);--newline--        if (i < board.length - 2 && board[i+1][j] == 'O')--newline--            boundaryDFS(board, i+1, j);--newline--        if (j > 1 && board[i][j-1] == 'O')--newline--            boundaryDFS(board, i, j-1);--newline--        if (j < board[i].length - 2 && board[i][j+1] == 'O' )--newline--            boundaryDFS(board, i, j+1);--newline--    }--newline--}",
    "l_type": "java",
    "modified_code": null,
    "total_cases": 60
}