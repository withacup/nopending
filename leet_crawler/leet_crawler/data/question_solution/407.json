{
    "posts": [
        {
            "java": "--newline--public class Solution {--newline----newline--    public class Cell {--newline--        int row;--newline--        int col;--newline--        int height;--newline--        public Cell(int row, int col, int height) {--newline--            this.row = row;--newline--            this.col = col;--newline--            this.height = height;--newline--        }--newline--    }--newline----newline--    public int trapRainWater(int[][] heights) {--newline--        if (heights == null || heights.length == 0 || heights[0].length == 0)--newline--            return 0;--newline----newline--        PriorityQueue<Cell> queue = new PriorityQueue<>(1, new Comparator<Cell>(){--newline--            public int compare(Cell a, Cell b) {--newline--                return a.height - b.height;--newline--            }--newline--        });--newline--        --newline--        int m = heights.length;--newline--        int n = heights[0].length;--newline--        boolean[][] visited = new boolean[m][n];--newline----newline--        // Initially, add all the Cells which are on borders to the queue.--newline--        for (int i = 0; i < m; i++) {--newline--            visited[i][0] = true;--newline--            visited[i][n - 1] = true;--newline--            queue.offer(new Cell(i, 0, heights[i][0]));--newline--            queue.offer(new Cell(i, n - 1, heights[i][n - 1]));--newline--        }--newline----newline--        for (int i = 0; i < n; i++) {--newline--            visited[0][i] = true;--newline--            visited[m - 1][i] = true;--newline--            queue.offer(new Cell(0, i, heights[0][i]));--newline--            queue.offer(new Cell(m - 1, i, heights[m - 1][i]));--newline--        }--newline----newline--        // from the borders, pick the shortest cell visited and check its neighbors:--newline--        // if the neighbor is shorter, collect the water it can trap and update its height as its height plus the water trapped--newline--       // add all its neighbors to the queue.--newline--        int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};--newline--        int res = 0;--newline--        while (!queue.isEmpty()) {--newline--            Cell cell = queue.poll();--newline--            for (int[] dir : dirs) {--newline--                int row = cell.row + dir[0];--newline--                int col = cell.col + dir[1];--newline--                if (row >= 0 && row < m && col >= 0 && col < n && !visited[row][col]) {--newline--                    visited[row][col] = true;--newline--                    res += Math.max(0, cell.height - heights[row][col]);--newline--                    queue.offer(new Cell(row, col, Math.max(heights[row][col], cell.height)));--newline--                }--newline--            }--newline--        }--newline--        --newline--        return res;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using PriorityQueue"
        },
        {
            "java": "public class Solution {--newline----newline--    int[] dx = {0, 0, 1, -1};--newline--    int[] dy = {1, -1, 0, 0};--newline----newline--    List<int[]>[] g;--newline--    int start;--newline----newline--    private int[] dijkstra() {--newline--        int[] dist = new int[g.length];--newline--        Arrays.fill(dist, Integer.MAX_VALUE / 2);--newline--        dist[start] = 0;--newline--        TreeSet<int[]> tree = new TreeSet<>((u, v) -> u[1] == v[1] ? u[0] - v[0] : u[1] - v[1]);--newline--        tree.add(new int[]{start, 0});--newline--        while (!tree.isEmpty()) {--newline--            int u = tree.first()[0], d = tree.pollFirst()[1];--newline--            for (int[] e : g[u]) {--newline--                int v = e[0], w = e[1];--newline--                if (Math.max(d, w) < dist[v]) {--newline--                    tree.remove(new int[]{v, dist[v]});--newline--                    dist[v] = Math.max(d, w);--newline--                    tree.add(new int[]{v, dist[v]});--newline--                }--newline--            }--newline--        }--newline--        return dist;--newline--    }--newline----newline--    public int trapRainWater(int[][] a) {--newline--        if (a == null || a.length == 0 || a[0].length == 0) return 0;--newline--        int r = a.length, c = a[0].length;--newline----newline--        start = r * c;--newline--        g = new List[r * c + 1];--newline--        for (int i = 0; i < g.length; i++) g[i] = new ArrayList<>();--newline--        for (int i = 0; i < r; i++)--newline--            for (int j = 0; j < c; j++) {--newline--                if (i == 0 || i == r - 1 || j == 0 || j == c - 1) g[start].add(new int[]{i * c + j, 0});--newline--                for (int k = 0; k < 4; k++) {--newline--                    int x = i + dx[k], y = j + dy[k];--newline--                    if (x >= 0 && x < r && y >= 0 && y < c) g[i * c + j].add(new int[]{x * c + y, a[i][j]});--newline--                }--newline--            }--newline----newline--        int ans = 0;--newline--        int[] dist = dijkstra();--newline--        for (int i = 0; i < r; i++)--newline--            for (int j = 0; j < c; j++) {--newline--                int cb = dist[i * c + j];--newline--                if (cb > a[i][j]) ans += cb - a[i][j];--newline--            }--newline----newline--        return ans;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Alternative approach using Dijkstra in O(rc max(log r, log c)) time"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int trapRainWater(vector<vector<int>>& heightMap) {--newline--        if(heightMap.size()==0) return 0;--newline--        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;--newline--        int row = heightMap.size(), col = heightMap[0].size();--newline--        vector<vector<int>> visited(row, vector<int>(col, 0));--newline--        int ans = 0, Max = INT_MIN;--newline--        for(int i = 0; i < row; i++)--newline--        {--newline--            for(int j = 0; j < col; j++)--newline--            {--newline--                if(!(i==0 || i==row-1 || j==0 || j==col-1)) continue;--newline--                que.push(make_pair(heightMap[i][j], i*col+j));--newline--                visited[i][j] = 1;--newline--            }--newline--        }--newline--        vector<vector<int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};--newline--        while(!que.empty())--newline--        {--newline--            auto val = que.top(); que.pop();--newline--            int height = val.first, x = val.second/col, y = val.second%col;--newline--            Max = max(Max, height);--newline--            for(auto d: dir)--newline--            {--newline--                int x2 = x + d[0], y2 = y + d[1];--newline--                if(x2>=row || x2<0 || y2<0 || y2>=col || visited[x2][y2]) continue;--newline--                visited[x2][y2] = 1;--newline--                if(heightMap[x2][y2] < Max) ans += Max - heightMap[x2][y2];--newline--                que.push(make_pair(heightMap[x2][y2], x2*col+y2));--newline--            }--newline--        }--newline--        return ans;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "concise C++ priority_queue solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def trapRainWater(self, heightMap):--newline----tab--        if not heightMap or not heightMap[0]:--newline----tab--            return 0--newline----tab--        --newline----tab--        import heapq    --newline----tab--        m, n = len(heightMap), len(heightMap[0])--newline----tab--        heap = []--newline----tab--        visited = [[0]*n for _ in xrange(m)]--newline----tab----newline----tab--        # Push all the block on the border into heap--newline----tab--        for i in xrange(m):--newline----tab--            for j in xrange(n):--newline----tab--                if i == 0 or j == 0 or i == m-1 or j == n-1:--newline----tab--                    heapq.heappush(heap, (heightMap[i][j], i, j))--newline----tab--                    visited[i][j] = 1--newline----tab--        --newline----tab--        result = 0--newline----tab--        while heap:--newline----tab--            height, i, j = heapq.heappop(heap)    --newline----tab--            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):--newline----tab--                if 0 <= x < m and 0 <= y < n and not visited[x][y]:--newline----tab--                    result += max(0, height-heightMap[x][y])--newline----tab--                    heapq.heappush(heap, (max(heightMap[x][y], height), x, y))--newline----tab--                    visited[x][y] = 1--newline----tab--        return result--newline----tab--",
            "topic_title": "python solution with heap"
        },
        {
            "java": "/*--newline--Basic physics:--newline--Unlike bricks, water flows to wherever it could. --newline--i.e we can't have the follwoing config made with water, but can do it with bricks--newline--000--newline--010--newline--000--newline--In the case above, if the \"1\" is built with water, that water can't stay. It needs to be spilled!--newline----newline--2 steps Algorithm: --newline--1. Since we know how to trap rain water in 1d, we can just transfor this 2D problem into 2 1D problems--newline--    we go row by row, to calculate each spot's water--newline--    we go column by column, to calculate each spot's water--newline----newline--2. Then, here comes the meat,--newline--    For every spot that gets wet, from either row or column calculation, the water can possibly spill.--newline--    We need to check the water height aganist it's 4 neighbors. --newline--        If the water height is taller than any one of its 4 neightbors, we need to spill the extra water.--newline--        If we spill any water from any slot, then its 4 neightbors needs to check themselves again.--newline--            For example, if we spill some water in the current slot b/c its bottm neighbor's height, current slot's top neighbor's height might need to be updated again.--newline--        we keep checking until there is no water to be spilled.--newline--*/--newline----newline----newline--public class Solution {--newline--    public int trapRainWater(int[][] heightMap) {--newline--        /*FIRST STEP*/--newline--        if(heightMap.length == 0) return 0;--newline--        int[][] wetMap = new int[heightMap.length][heightMap[0].length];--newline--        int sum = 0;--newline--        /*row by row*/--newline--        for(int i = 1; i < wetMap.length - 1; i++){--newline--            wetMap[i] = calculate(heightMap[i]);--newline--        }--newline--        /*column by column*/--newline--        for(int i = 1; i < heightMap[0].length - 1; i++){--newline--            int[] col = new int[heightMap.length];--newline--            for(int j = 0; j < heightMap.length; j++){--newline--                col[j] = heightMap[j][i];--newline--            }--newline--            int[] colResult = calculate(col);--newline--            /*update the wetMap to be the bigger value between row and col, later we can spill, don't worry*/--newline--            for(int j = 0; j < heightMap.length; j++){--newline--                wetMap[j][i] = Math.max(colResult[j], wetMap[j][i]);--newline--                sum += wetMap[j][i];--newline--            }--newline--        }--newline--        /*SECOND STEP*/--newline--        boolean spillWater = true;--newline--        int[] rowOffset = {-1,1,0,0};--newline--        int[] colOffset = {0,0,1,-1};--newline--        while(spillWater){--newline--            spillWater = false;--newline--            for(int i = 1; i < heightMap.length - 1; i++){--newline--                for(int j = 1; j < heightMap[0].length - 1; j++){--newline--                    /*If this slot has ever gotten wet, exammine its 4 neightbors*/--newline--                    if(wetMap[i][j] != 0){--newline--                        for(int m = 0; m < 4; m++){--newline--                            int neighborRow = i + rowOffset[m];--newline--                            int neighborCol = j + colOffset[m];--newline--                            int currentHeight = wetMap[i][j] + heightMap[i][j];--newline--                            int neighborHeight = wetMap[neighborRow][neighborCol] + --newline--                                                              heightMap[neighborRow][neighborCol];--newline--                            if(currentHeight > neighborHeight){--newline--                                int spilledWater = currentHeight - Math.max(neighborHeight, heightMap[i][j]);--newline--                                wetMap[i][j] = Math.max(0, wetMap[i][j] - spilledWater);--newline--                                sum -= spilledWater;--newline--                                spillWater = true;--newline--                            }--newline--                        }    --newline--                    }    --newline--                }--newline--            }--newline--        }--newline--        return sum;--newline--    }--newline--    --newline--    /*Nothing interesting here, the same function for trapping water 1*/--newline--    private int[] calculate (int[] height){--newline--        int[] result = new int[height.length];--newline--        Stack<Integer> s = new Stack<Integer>();--newline--        int index = 0;--newline--        while(index < height.length){--newline--            if(s.isEmpty() || height[index] <= height[s.peek()]){--newline--                s.push(index++);--newline--            }else{--newline--                int bottom = s.pop();--newline--                if(s.size() != 0){--newline--                    for(int i = s.peek() + 1; i < index; i++){--newline--                        result[i] += (Math.min(height[s.peek()], height[index]) - height[bottom]);--newline--                    }    --newline--                }--newline--            }--newline--        }--newline--        return result;--newline--    }   --newline--    --newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "&#91;Why reinvent the wheel??&#93; An easy understood commented solution based on trapping rain 1"
        }
    ],
    "qc": "407.json"
}