{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<String> removeInvalidParentheses(String s) {--newline--        List<String> ans = new ArrayList<>();--newline--        remove(s, ans, 0, 0, new char[]{'(', ')'});--newline--        return ans;--newline--    }--newline--    --newline--    public void remove(String s, List<String> ans, int last_i, int last_j,  char[] par) {--newline--        for (int stack = 0, i = last_i; i < s.length(); ++i) {--newline--            if (s.charAt(i) == par[0]) stack++;--newline--            if (s.charAt(i) == par[1]) stack--;--newline--            if (stack >= 0) continue;--newline--            for (int j = last_j; j <= i; ++j)--newline--                if (s.charAt(j) == par[1] && (j == last_j || s.charAt(j - 1) != par[1]))--newline--                    remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);--newline--            return;--newline--        }--newline--        String reversed = new StringBuilder(s).reverse().toString();--newline--        if (par[0] == '(') // finished left to right--newline--            remove(reversed, ans, 0, 0, new char[]{')', '('});--newline--        else // finished right to left--newline--            ans.add(reversed);--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy, Short, Concise and Fast Java DFS 3 ms solution"
        },
        {
            "java": "public class Solution {--newline--    public List<String> removeInvalidParentheses(String s) {--newline--      List<String> res = new ArrayList<>();--newline--      --newline--      // sanity check--newline--      if (s == null) return res;--newline--      --newline--      Set<String> visited = new HashSet<>();--newline--      Queue<String> queue = new LinkedList<>();--newline--      --newline--      // initialize--newline--      queue.add(s);--newline--      visited.add(s);--newline--      --newline--      boolean found = false;--newline--      --newline--      while (!queue.isEmpty()) {--newline--        s = queue.poll();--newline--        --newline--        if (isValid(s)) {--newline--          // found an answer, add to the result--newline--          res.add(s);--newline--          found = true;--newline--        }--newline--      --newline--        if (found) continue;--newline--      --newline--        // generate all possible states--newline--        for (int i = 0; i < s.length(); i++) {--newline--          // we only try to remove left or right paren--newline--          if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;--newline--        --newline--          String t = s.substring(0, i) + s.substring(i + 1);--newline--        --newline--          if (!visited.contains(t)) {--newline--            // for each state, if it's not visited, add it to the queue--newline--            queue.add(t);--newline--            visited.add(t);--newline--          }--newline--        }--newline--      }--newline--      --newline--      return res;--newline--    }--newline--    --newline--    // helper function checks if string s contains valid parantheses--newline--    boolean isValid(String s) {--newline--      int count = 0;--newline--    --newline--      for (int i = 0; i < s.length(); i++) {--newline--        char c = s.charAt(i);--newline--        if (c == '(') count++;--newline--        if (c == ')' && count-- == 0) return false;--newline--      }--newline--    --newline--      return count == 0;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my Java BFS solution"
        },
        {
            "java": "public class Solution {--newline--    public List<String> removeInvalidParentheses(String s) {--newline--        int rmL = 0, rmR = 0;--newline--        for (int i = 0; i < s.length(); i++) {--newline--            if (s.charAt(i) == '(') {--newline--                rmL++;--newline--            } else if (s.charAt(i) == ')') {--newline--                if (rmL != 0) {--newline--                    rmL--;--newline--                } else {--newline--                    rmR++;--newline--                }--newline--            }--newline--        }--newline--        Set<String> res = new HashSet<>();--newline--        dfs(s, 0, res, new StringBuilder(), rmL, rmR, 0);--newline--        return new ArrayList<String>(res);--newline--    }--newline--    --newline--    public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmL, int rmR, int open) {--newline--        if (rmL < 0 || rmR < 0 || open < 0) {--newline--            return;--newline--        }--newline--        if (i == s.length()) {--newline--            if (rmL == 0 && rmR == 0 && open == 0) {--newline--                res.add(sb.toString());--newline--            }        --newline--            return;--newline--        }--newline--    --newline--        char c = s.charAt(i); --newline--        int len = sb.length();--newline--    --newline--        if (c == '(') {--newline--            dfs(s, i + 1, res, sb, rmL - 1, rmR, open);--tab----tab--    // not use (--newline--        --tab--dfs(s, i + 1, res, sb.append(c), rmL, rmR, open + 1);       // use (--newline--    --newline--        } else if (c == ')') {--newline--            dfs(s, i + 1, res, sb, rmL, rmR - 1, open);--tab--            // not use  )--newline--        --tab--dfs(s, i + 1, res, sb.append(c), rmL, rmR, open - 1);  --tab--    // use )--newline--    --newline--        } else {--newline--            dfs(s, i + 1, res, sb.append(c), rmL, rmR, open);--tab----newline--        }--newline--    --newline--        sb.setLength(len);        --newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easiest 9ms Java Solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<string> removeInvalidParentheses(string s) {--newline--        unordered_set<string> result;--newline--        int left_removed = 0;--newline--        int right_removed = 0;--newline--        for(auto c : s) {--newline--            if(c == '(') {--newline--                ++left_removed;--newline--            }--newline--            if(c == ')') {--newline--                if(left_removed != 0) {--newline--                    --left_removed;--newline--                }--newline--                else {--newline--                    ++right_removed;--newline--                }--newline--            }--newline--        }--newline--        helper(s, 0, left_removed, right_removed, 0, \"\", result);--newline--        return vector<string>(result.begin(), result.end());--newline--    }--newline--private:--newline--    void helper(string s, int index, int left_removed, int right_removed, int pair, string path, unordered_set<string>& result) {--newline--        if(index == s.size()) {--newline--            if(left_removed == 0 && right_removed == 0 && pair == 0) {--newline--                result.insert(path);--newline--            }--newline--            return;--newline--        }--newline--        if(s[index] != '(' && s[index] != ')') {--newline--            helper(s, index + 1, left_removed, right_removed, pair, path + s[index], result);--newline--        }--newline--        else {--newline--            if(s[index] == '(') {--newline--                if(left_removed > 0) {--newline--                    helper(s, index + 1, left_removed - 1, right_removed, pair, path, result);--newline--                }--newline--                helper(s, index + 1, left_removed, right_removed, pair + 1, path + s[index], result);--newline--            }--newline--            if(s[index] == ')') {--newline--                if(right_removed > 0) {--newline--                    helper(s, index + 1, left_removed, right_removed - 1, pair, path, result);--newline--                }--newline--                if(pair > 0) {--newline--                    helper(s, index + 1, left_removed, right_removed, pair - 1, path + s[index], result);--newline--                }--newline--            }--newline--        }--newline--    }--newline--};",
            "python": null,
            "topic_title": "My C++ DFS Solution - 16ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def removeInvalidParentheses(self, s):--newline----tab--        def isvalid(s):--newline----tab--            s = filter('()'.count, s)--newline----tab--            while '()' in s:--newline----tab--                s = s.replace('()', '')--newline----tab--            return not s--newline----tab--        level = {s}--newline----tab--        while True:--newline----tab--            valid = filter(isvalid, level)--newline----tab--            if valid:--newline----tab--                return valid--newline----tab--            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}",
            "topic_title": "Short Python BFS"
        }
    ],
    "qc": "301.json"
}