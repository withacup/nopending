{
    "posts": [
        {
            "java": "public class Solution {--newline--    public boolean isRectangleCover(int[][] rectangles) {--newline--    --newline--            if (rectangles.length == 0 || rectangles[0].length == 0) return false;--newline--    --newline--            int x1 = Integer.MAX_VALUE;--newline--            int x2 = Integer.MIN_VALUE;--newline--            int y1 = Integer.MAX_VALUE;--newline--            int y2 = Integer.MIN_VALUE;--newline--            --newline--            HashSet<String> set = new HashSet<String>();--newline--            int area = 0;--newline--            --newline--            for (int[] rect : rectangles) {--newline--                x1 = Math.min(rect[0], x1);--newline--                y1 = Math.min(rect[1], y1);--newline--                x2 = Math.max(rect[2], x2);--newline--                y2 = Math.max(rect[3], y2);--newline--                --newline--                area += (rect[2] - rect[0]) * (rect[3] - rect[1]);--newline--                --newline--                String s1 = rect[0] + \" \" + rect[1];--newline--                String s2 = rect[0] + \" \" + rect[3];--newline--                String s3 = rect[2] + \" \" + rect[3];--newline--                String s4 = rect[2] + \" \" + rect[1];--newline--                --newline--                if (!set.add(s1)) set.remove(s1);--newline--                if (!set.add(s2)) set.remove(s2);--newline--                if (!set.add(s3)) set.remove(s3);--newline--                if (!set.add(s4)) set.remove(s4);--newline--            }--newline--            --newline--            if (!set.contains(x1 + \" \" + y1) || !set.contains(x1 + \" \" + y2) || !set.contains(x2 + \" \" + y1) || !set.contains(x2 + \" \" + y2) || set.size() != 4) return false;--newline--            --newline--            return area == (x2-x1) * (y2-y1);--newline--        }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Really Easy Understanding Solution(O(n), Java)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    struct pairhash {//double hash function for pair key--newline--    public:--newline--        template <typename T, typename U>--newline--        size_t operator()(const pair<T, U> &rhs) const {--newline--            size_t l = hash<T>()(rhs.first);--newline--            size_t r = hash<U>()(rhs.second);--newline--            return l + 0x9e3779b9 + (r << 6) + (r >> 2);--newline--        }--newline--    };--newline--    --newline--    bool isRectangleCover(vector<vector<int>>& rectangles) {--newline--        // step 1: counting--newline--        unordered_map<pair<int, int>, int, pairhash> corner_count;--newline--        int minx = INT_MAX, maxx=INT_MIN, miny=INT_MAX, maxy=INT_MIN;--newline--        for (auto& rect : rectangles) {--newline--            minx = min(minx, rect[0]);--newline--            maxx = max(maxx, rect[2]);--newline--            miny = min(miny, rect[1]);--newline--            maxy = max(maxy, rect[3]);--newline--            --newline--            int& m1 = corner_count[make_pair(rect[0], rect[1])]; --newline--            if (m1 & 1) return false; else m1 |= 1;--newline--            int& m2 = corner_count[make_pair(rect[2], rect[1])];--newline--            if (m2 & 2) return false; else m2 |= 2;--newline--            int& m3 = corner_count[make_pair(rect[0], rect[3])]; --newline--            if (m3 & 4) return false; else m3 |= 4;--newline--            int& m4 = corner_count[make_pair(rect[2], rect[3])]; --newline--            if (m4 & 8) return false; else m4 |= 8;--newline--        }--newline--        --newline--        //step2: checking--newline--        for (const auto& kv: corner_count) {--newline--            pair<int, int> pos; int mask;--newline--            tie(pos, mask) = kv;--newline--            if ((pos.first != minx && pos.first != maxx) || (pos.second != miny && pos.second != maxy)) {--newline--                if (mask != 3 && mask != 5 && mask != 10 && mask != 12 && mask != 15) return false;--newline--            }--newline--        }--newline--        return true;--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "O(n) solution by counting corners with detailed explaination"
        },
        {
            "java": "public class Event implements Comparable<Event> {--newline----tab--int time;--newline----tab--int[] rect;--newline----newline----tab--public Event(int time, int[] rect) {--newline----tab----tab--this.time = time;--newline----tab----tab--this.rect = rect;--newline----tab--}--newline----tab----newline----tab--public int compareTo(Event that) {--newline----tab----tab--if (this.time != that.time) return this.time - that.time;--newline----tab----tab--else return this.rect[0] - that.rect[0];--newline----tab--}--newline--}--newline----newline--public boolean isRectangleCover(int[][] rectangles) {--newline----tab--PriorityQueue<Event> pq = new PriorityQueue<Event> ();--newline--        // border of y-intervals--newline----tab--int[] border= {Integer.MAX_VALUE, Integer.MIN_VALUE};--newline----tab--for (int[] rect : rectangles) {--newline----tab----tab--Event e1 = new Event(rect[0], rect);--newline----tab----tab--Event e2 = new Event(rect[2], rect);--newline----tab----tab--pq.add(e1);--newline----tab----tab--pq.add(e2);--newline----tab----tab--if (rect[1] < border[0]) border[0] = rect[1];--newline----tab----tab--if (rect[3] > border[1]) border[1] = rect[3];--newline----tab--}--newline----tab--TreeSet<int[]> set = new TreeSet<int[]> (new Comparator<int[]> () {--newline----tab----tab--@Override--newline--                // if two y-intervals intersects, return 0--newline----tab----tab--public int compare (int[] rect1, int[] rect2) {--newline----tab----tab----tab--if (rect1[3] <= rect2[1]) return -1;--newline----tab----tab----tab--else if (rect2[3] <= rect1[1]) return 1;--newline----tab----tab----tab--else return 0;--newline----tab----tab--}--newline----tab--});--newline----tab--int yRange = 0;--newline----tab--while (!pq.isEmpty()) {--newline----tab----tab--int time = pq.peek().time;--newline----tab----tab--while (!pq.isEmpty() && pq.peek().time == time) {--newline----tab----tab----tab--Event e = pq.poll();--newline----tab----tab----tab--int[] rect = e.rect;--newline----tab----tab----tab--if (time == rect[2]) {--newline----tab----tab----tab----tab--set.remove(rect);--newline----tab----tab----tab----tab--yRange -= rect[3] - rect[1];--newline----tab----tab----tab--} else {--newline----tab----tab----tab----tab--if (!set.add(rect)) return false;--newline----tab----tab----tab----tab--yRange += rect[3] - rect[1];--newline----tab----tab----tab--}--newline----tab----tab--}--newline--                // check intervals' range--newline----tab----tab--if (!pq.isEmpty() && yRange != border[1] - border[0]) {--newline--                        return false;--newline----tab----tab----tab--//if (set.isEmpty()) return false;--newline----tab----tab----tab--//if (yRange != border[1] - border[0]) return false;--newline----tab----tab--}--newline----tab--}--newline----tab--return true;--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "O(n log n) sweep line solution"
        },
        {
            "java": "public class Solution {--newline--    Map<String, Integer> map = new HashMap<String, Integer>();--newline--    public boolean isRectangleCover(int[][] rectangles) {--newline--        if (rectangles.length == 0 || rectangles[0].length == 0) return false;--newline--        int lx = Integer.MAX_VALUE, ly = lx, rx = Integer.MIN_VALUE, ry = rx, sum = 0;--newline--        for (int[] rec : rectangles) {--newline--            lx = Math.min(lx, rec[0]);--newline--            ly = Math.min(ly, rec[1]);--newline--            rx = Math.max(rx, rec[2]);--newline--            ry = Math.max(ry, rec[3]);--newline--            sum += (rec[2] - rec[0]) * (rec[3] - rec[1]);--newline--            //bottom-left--newline--            if (overlap(rec[0] + \" \" + rec[1], 1)) return false;--newline--            //top-left--newline--            if (overlap(rec[0] + \" \" + rec[3], 2)) return false;--newline--            //bottom-right--newline--            if (overlap(rec[2] + \" \" + rec[1], 4)) return false;--newline--            //top-right--newline--            if (overlap(rec[2] + \" \" + rec[3], 8)) return false;--newline--        }--newline--        int count = 0;--newline--        Iterator<Integer> iter = map.values().iterator();--newline--        while (iter.hasNext()) {--newline--            Integer i = iter.next();--newline--            if (i != 15 && i != 12 && i != 10 && i != 9 && i != 6 && i != 5 && i != 3) count++;--newline--        }--newline--        return count == 4 && sum == (rx - lx) * (ry - ly);--newline--    }--newline--    --newline--    private boolean overlap(String corner, Integer type) {--newline--        Integer temp = map.get(corner);--newline--        if (temp == null) temp = type;--newline--        else if ((temp & type) != 0) return true;--newline--        else temp |= type;--newline--        map.put(corner, temp);--newline--        return false;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Short Java solution with explanation (updated)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def isRectangleCover(self, rectangles):--newline----tab--        def recordCorner(point):--newline----tab--            if point in corners:--newline----tab--                corners[point] += 1--newline----tab--            else:--newline----tab--                corners[point] = 1--newline----tab----newline----tab--        corners = {}                                # record all corners --newline----tab--        L, B, R, T, area = float('inf'), float('inf'), -float('inf'), -float('inf'), 0--newline----tab----newline----tab--        for sub in rectangles:--newline----tab--            L, B, R, T = min(L, sub[0]), min(B, sub[1]), max(R, sub[2]), max(T, sub[3])--newline----tab--            ax, ay, bx, by = sub[:]--newline----tab--            area += (bx-ax)*(by-ay)                 # sum up the area of each sub-rectangle--newline----tab--            map(recordCorner, [(ax, ay), (bx, by), (ax, by), (bx, ay)])--newline----tab----newline----tab--        if area != (T-B)*(R-L): return False        # check the area--newline----tab----newline----tab--        big_four = [(L,B),(R,T),(L,T),(R,B)]--newline----tab----newline----tab--        for bf in big_four:                         # check corners of big rectangle--newline----tab--            if bf not in corners or corners[bf] != 1:--newline----tab--                return False--newline----tab----newline----tab--        for key in corners:                         # check existing \"inner\" points--newline----tab--            if corners[key]%2 and key not in big_four:--newline----tab--                return False--newline----tab----newline----tab--        return True--newline----tab--",
            "topic_title": "Easy Understanding O(n) Python Solution"
        }
    ],
    "qc": "391.json"
}