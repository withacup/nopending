{
    "posts": [
        {
            "java": "public class Solution {--newline--        public double[] calcEquation(String[][] equations, double[] values, String[][] queries) {--newline--            HashMap<String, ArrayList<String>> pairs = new HashMap<String, ArrayList<String>>();--newline--            HashMap<String, ArrayList<Double>> valuesPair = new HashMap<String, ArrayList<Double>>();--newline--            for (int i = 0; i < equations.length; i++) {--newline--                String[] equation = equations[i];--newline--                if (!pairs.containsKey(equation[0])) {--newline--                    pairs.put(equation[0], new ArrayList<String>());--newline--                    valuesPair.put(equation[0], new ArrayList<Double>());--newline--                }--newline--                if (!pairs.containsKey(equation[1])) {--newline--                    pairs.put(equation[1], new ArrayList<String>());--newline--                    valuesPair.put(equation[1], new ArrayList<Double>());--newline--                }--newline--                pairs.get(equation[0]).add(equation[1]);--newline--                pairs.get(equation[1]).add(equation[0]);--newline--                valuesPair.get(equation[0]).add(values[i]);--newline--                valuesPair.get(equation[1]).add(1/values[i]);--newline--            }--newline--            --newline--            double[] result = new double[queries.length];--newline--            for (int i = 0; i < queries.length; i++) {--newline--                String[] query = queries[i];--newline--                result[i] = dfs(query[0], query[1], pairs, valuesPair, new HashSet<String>(), 1.0);--newline--                if (result[i] == 0.0) result[i] = -1.0;--newline--            }--newline--            return result;--newline--        }--newline--        --newline--        private double dfs(String start, String end, HashMap<String, ArrayList<String>> pairs, HashMap<String, ArrayList<Double>> values, HashSet<String> set, double value) {--newline--            if (set.contains(start)) return 0.0;--newline--            if (!pairs.containsKey(start)) return 0.0;--newline--            if (start.equals(end)) return value;--newline--            set.add(start);--newline--            --newline--            ArrayList<String> strList = pairs.get(start);--newline--            ArrayList<Double> valueList = values.get(start);--newline--            double tmp = 0.0;--newline--            for (int i = 0; i < strList.size(); i++) {--newline--                tmp = dfs(strList.get(i), end, pairs, values, set, value*valueList.get(i));--newline--                if (tmp != 0.0) {--newline--                    break;--newline--                }--newline--            }--newline--            set.remove(start);--newline--            return tmp;--newline--        }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java AC Solution using graph"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def calcEquation(self, equations, values, queries):--newline----tab--        quot = collections.defaultdict(dict)--newline----tab--        for (num, den), val in zip(equations, values):--newline----tab--            quot[num][num] = quot[den][den] = 1.0--newline----tab--            quot[num][den] = val--newline----tab--            quot[den][num] = 1 / val--newline----tab--        for k in quot:--newline----tab--            for i in quot[k]:--newline----tab--                for j in quot[k]:--newline----tab--                    quot[i][j] = quot[i][k] * quot[k][j]--newline----tab--        return [quot[num].get(den, -1.0) for num, den in queries]--newline----tab--    ",
            "topic_title": "9 lines &quot;Floyd\u2013Warshall&quot; in Python"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--    // date: 2016-09-12     location: Santa Clara City Library--newline--public:--newline--    vector<double> calcEquation(vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries) {--newline--        unordered_map<string, Node*> map;--newline--        vector<double> res;--newline--        for (int i = 0; i < equations.size(); i ++) {--newline--            string s1 = equations[i].first, s2 = equations[i].second;--newline--            if (map.count(s1) == 0 && map.count(s2) == 0) {--newline--                map[s1] = new Node();--newline--                map[s2] = new Node();--newline--                map[s1] -> value = values[i];--newline--                map[s2] -> value = 1;--newline--                map[s1] -> parent = map[s2];--newline--            } else if (map.count(s1) == 0) {--newline--                map[s1] = new Node();--newline--                map[s1] -> value = map[s2] -> value * values[i];--newline--                map[s1] -> parent = map[s2];--newline--            } else if (map.count(s2) == 0) {--newline--                map[s2] = new Node();--newline--                map[s2] -> value = map[s1] -> value / values[i];--newline--                map[s2] -> parent = map[s1];--newline--            } else {--newline--                unionNodes(map[s1], map[s2], values[i], map);--newline--            }--newline--        }--newline----newline--        for (auto query : queries) {--newline--            if (map.count(query.first) == 0 || map.count(query.second) == 0 || findParent(map[query.first]) != findParent(map[query.second]))--newline--                res.push_back(-1);--newline--            else--newline--                res.push_back(map[query.first] -> value / map[query.second] -> value);--newline--        }--newline--        return res;--newline--    }--newline--    --newline--private:--newline--    struct Node {--newline--        Node* parent;--newline--        double value = 0.0;--newline--        Node()  {parent = this;}--newline--    };--newline--    --newline--    void unionNodes(Node* node1, Node* node2, double num, unordered_map<string, Node*>& map) {--newline--        Node* parent1 = findParent(node1), *parent2 = findParent(node2);--newline--        double ratio = node2 -> value * num / node1 -> value;--newline--        for (auto it = map.begin(); it != map.end(); it ++)--newline--            if (findParent(it -> second) == parent1)--newline--                it -> second -> value *= ratio;--newline--        parent1 -> parent = parent2;--newline--    }--newline--    --newline--    Node* findParent(Node* node) {--newline--        if (node -> parent == node)--newline--            return node;--newline--        node -> parent = findParent(node -> parent);--newline--        return node -> parent;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "0ms C++ Union-Find Solution &#91;EASY to UNDERSTAND&#93;"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<double> calcEquation(vector<pair<string, string>> equations, --newline--        vector<double>& values, vector<pair<string, string>> query) --newline--    {--newline--        unordered_map<string,unordered_map<string, double>> m;--newline--        vector<double> res;--newline--        for (int i = 0; i < values.size(); ++i)--newline--        {--newline--            m[equations[i].first].insert(make_pair(equations[i].second,values[i]));--newline--            if(values[i]!=0)--newline--                m[equations[i].second].insert(make_pair(equations[i].first,1/values[i]));--newline--        }--newline----newline--        for (auto i : query)--newline--        {--newline--            unordered_set<string> s;--newline--            double tmp = check(i.first,i.second,m,s);--newline--            if(tmp) res.push_back(tmp);--newline--            else res.push_back(-1);--newline--        }--newline--        return res;--newline--    }--newline----newline--    double check(string up, string down, --newline--            unordered_map<string,unordered_map<string, double>> &m,--newline--            unordered_set<string> &s)--newline--    {--newline--        if(m[up].find(down) != m[up].end()) return m[up][down];--newline--        for (auto i : m[up])--newline--        {--newline--            if(s.find(i.first) == s.end())--newline--            {--newline--                s.insert(i.first);--newline--                double tmp = check(i.first,down,m,s);--newline--                if(tmp) return i.second*tmp;--newline--            }--newline--        }--newline--        return 0;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "c++ 0ms Hash+DFS solution"
        },
        {
            "java": "public class Solution {--newline--    public static double[] calcEquation(String[][] equations, double[] values, String[][] query) {--newline--            Map<String, Map<String, Double>> numMap = new HashMap<>();--newline--            int i = 0;--newline--            for(String[] str : equations) {--newline--                insertPairs(numMap, str[0], str[1], values[i]);--newline--                insertPairs(numMap, str[1], str[0], 1.0/values[i]);--newline--                i++;--newline--            }--newline--    --newline--            double[] res = new double[query.length];--newline--            i = 0;--newline--            for(String[] q: query) {--newline--                Double resObj = handleQuery(q[0], q[1], numMap, new HashSet<>());--newline--                res[i++] = (resObj != null) ? resObj : -1.0;--newline--            }--newline--            return res;--newline--        }--newline--    --newline--        public static void insertPairs(Map<String, Map<String, Double>> numMap, String num, String denom, Double value) {--newline--            Map<String, Double> denomMap = numMap.get(num);--newline--            if(denomMap == null) {--newline--                denomMap = new HashMap<>();--newline--                numMap.put(num, denomMap);--newline--            }--newline--            denomMap.put(denom, value);--newline--        }--newline--    --newline--        public static Double handleQuery(String num, String denom, Map<String, Map<String, Double>> numMap, Set<String> visitedSet) {--newline--            String dupeKey = num+\":\"+denom;--newline--            if(visitedSet.contains(dupeKey)) return null;--newline--            if(!numMap.containsKey(num) || !numMap.containsKey(denom)) return null;--newline--            if(num.equals(denom)) return 1.0;--newline--    --newline--            Map<String, Double> denomMap = numMap.get(num);--newline--            visitedSet.add(dupeKey);--newline--            for(String key : denomMap.keySet()) {--newline--                Double res = handleQuery(key, denom, numMap, visitedSet);--newline--                if(res != null) {--newline--                    return denomMap.get(key) * res;--newline--                }--newline--            }--newline--            visitedSet.remove(dupeKey);--newline--            return null;--newline--        }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java AC solution with explanation"
        }
    ],
    "qc": "399.json"
}