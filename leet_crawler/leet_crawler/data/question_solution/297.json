{
    "posts": [
        {
            "java": "public class Codec {--newline--    private static final String spliter = \",\";--newline--    private static final String NN = \"X\";--newline----newline--    // Encodes a tree to a single string.--newline--    public String serialize(TreeNode root) {--newline--        StringBuilder sb = new StringBuilder();--newline--        buildString(root, sb);--newline--        return sb.toString();--newline--    }--newline----newline--    private void buildString(TreeNode node, StringBuilder sb) {--newline--        if (node == null) {--newline--            sb.append(NN).append(spliter);--newline--        } else {--newline--            sb.append(node.val).append(spliter);--newline--            buildString(node.left, sb);--newline--            buildString(node.right,sb);--newline--        }--newline--    }--newline--    // Decodes your encoded data to tree.--newline--    public TreeNode deserialize(String data) {--newline--        Deque<String> nodes = new LinkedList<>();--newline--        nodes.addAll(Arrays.asList(data.split(spliter)));--newline--        return buildTree(nodes);--newline--    }--newline--    --newline--    private TreeNode buildTree(Deque<String> nodes) {--newline--        String val = nodes.remove();--newline--        if (val.equals(NN)) return null;--newline--        else {--newline--            TreeNode node = new TreeNode(Integer.valueOf(val));--newline--            node.left = buildTree(nodes);--newline--            node.right = buildTree(nodes);--newline--            return node;--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy to understand Java Solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Codec {--newline--public:--newline----newline--    string serialize(TreeNode* root) {--newline--        ostringstream out;--newline--        serialize(root, out);--newline--        return out.str();--newline--    }--newline----newline--    TreeNode* deserialize(string data) {--newline--        istringstream in(data);--newline--        return deserialize(in);--newline--    }--newline----newline--private:--newline----newline--    void serialize(TreeNode* root, ostringstream& out) {--newline--        if (root) {--newline--            out << root->val << ' ';--newline--            serialize(root->left, out);--newline--            serialize(root->right, out);--newline--        } else {--newline--            out << \"# \";--newline--        }--newline--    }--newline----newline--    TreeNode* deserialize(istringstream& in) {--newline--        string val;--newline--        in >> val;--newline--        if (val == \"#\")--newline--            return nullptr;--newline--        TreeNode* root = new TreeNode(stoi(val));--newline--        root->left = deserialize(in);--newline--        root->right = deserialize(in);--newline--        return root;--newline--    }--newline--};",
            "python": "class Codec:--newline----tab----newline----tab--    def serialize(self, root):--newline----tab--        def doit(node):--newline----tab--            if node:--newline----tab--                vals.append(str(node.val))--newline----tab--                doit(node.left)--newline----tab--                doit(node.right)--newline----tab--            else:--newline----tab--                vals.append('#')--newline----tab--        vals = []--newline----tab--        doit(root)--newline----tab--        return ' '.join(vals)--newline----tab----newline----tab--    def deserialize(self, data):--newline----tab--        def doit():--newline----tab--            val = next(vals)--newline----tab--            if val == '#':--newline----tab--                return None--newline----tab--            node = TreeNode(int(val))--newline----tab--            node.left = doit()--newline----tab--            node.right = doit()--newline----tab--            return node--newline----tab--        vals = iter(data.split())--newline----tab--        return doit()--newline----tab--",
            "topic_title": "Recursive preorder, Python and C++, O(n)"
        },
        {
            "java": "public class Codec {--newline--    public String serialize(TreeNode root) {--newline--        if (root == null) return \"\";--newline--        Queue<TreeNode> q = new LinkedList<>();--newline--        StringBuilder res = new StringBuilder();--newline--        q.add(root);--newline--        while (!q.isEmpty()) {--newline--            TreeNode node = q.poll();--newline--            if (node == null) {--newline--                res.append(\"n \");--newline--                continue;--newline--            }--newline--            res.append(node.val + \" \");--newline--            q.add(node.left);--newline--            q.add(node.right);--newline--        }--newline--        return res.toString();--newline--    }--newline----newline--    public TreeNode deserialize(String data) {--newline--        if (data == \"\") return null;--newline--        Queue<TreeNode> q = new LinkedList<>();--newline--        String[] values = data.split(\" \");--newline--        TreeNode root = new TreeNode(Integer.parseInt(values[0]));--newline--        q.add(root);--newline--        for (int i = 1; i < values.length; i++) {--newline--            TreeNode parent = q.poll();--newline--            if (!values[i].equals(\"n\")) {--newline--                TreeNode left = new TreeNode(Integer.parseInt(values[i]));--newline--                parent.left = left;--newline--                q.add(left);--newline--            }--newline--            if (!values[++i].equals(\"n\")) {--newline--                TreeNode right = new TreeNode(Integer.parseInt(values[i]));--newline--                parent.right = right;--newline--                q.add(right);--newline--            }--newline--        }--newline--        return root;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Short and straight forward BFS Java code with a queue"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Codec {--newline--public:--newline--    // Encodes a tree to a single string.--newline--    string serialize(TreeNode* root) {--newline--        if (root == nullptr) return \"#\";--newline--        return to_string(root->val)+\",\"+serialize(root->left)+\",\"+serialize(root->right);--newline--    }--newline----newline--    // Decodes your encoded data to tree.--newline--    TreeNode* deserialize(string data) {--newline--        return mydeserialize(data);--newline--    }--newline--    TreeNode* mydeserialize(string& data) {--newline--        if (data[0]=='#') {--newline--            if(data.size() > 1) data = data.substr(2);--newline--            return nullptr;--newline--        } else {--newline--            TreeNode* node = new TreeNode(helper(data));--newline--            node->left = mydeserialize(data);--newline--            node->right = mydeserialize(data);--newline--            return node;--newline--        }--newline--    }--newline--private:--newline--    int helper(string& data) {--newline--        int pos = data.find(',');--newline--        int val = stoi(data.substr(0,pos));--newline--        data = data.substr(pos+1);--newline--        return val;--newline--    }--newline--};`",
            "python": null,
            "topic_title": "Clean C++ solution"
        },
        {
            "java": "public class Codec {--newline----newline--    // Encodes a tree to a single string.--newline--    public String serialize(TreeNode root) {--newline--        if (root==null) return \"\";--newline--        Queue<TreeNode> qu=new LinkedList<>();--newline--        StringBuilder sb=new StringBuilder();--newline--        qu.offer(root);--newline--        sb.append(String.valueOf(root.val));--newline--        sb.append(' ');--newline--        while (!qu.isEmpty()) {--newline--            TreeNode x=qu.poll();--newline--            if (x.left==null) sb.append(\"null \");--newline--            else {--newline--                qu.offer(x.left);--newline--                sb.append(String.valueOf(x.left.val));--newline--                sb.append(' ');--newline--            }--newline--            if (x.right==null) sb.append(\"null \");--newline--            else {--newline--                qu.offer(x.right);--newline--                sb.append(String.valueOf(x.right.val));--newline--                sb.append(' ');--newline--            }--newline--        }--newline--        return sb.toString();--newline--    }--newline----newline--    // Decodes your encoded data to tree.--newline--    public TreeNode deserialize(String data) {--newline--        if (data.length()==0) return null;--newline--        String[] node=data.split(\" \");--newline--        Queue<TreeNode> qu=new LinkedList<>();--newline--        TreeNode root=new TreeNode(Integer.valueOf(node[0]));--newline--        qu.offer(root);--newline--        int i=1;--newline--        while (!qu.isEmpty()) {--newline--            Queue<TreeNode> nextQu=new LinkedList<>();--newline--            while (!qu.isEmpty()) {--newline--                TreeNode x=qu.poll();--newline--                if (node[i].equals(\"null\")) x.left=null;--newline--                else {--newline--                    x.left=new TreeNode(Integer.valueOf(node[i]));--newline--                    nextQu.offer(x.left);--newline--                }--newline--                i++;--newline--                if (node[i].equals(\"null\")) x.right=null;--newline--                else {--newline--                    x.right=new TreeNode(Integer.valueOf(node[i]));--newline--                    nextQu.offer(x.right);--newline--                }--newline--                i++;--newline--            }--newline--            qu=nextQu;--newline--        }--newline--        return root;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Recursive DFS, Iterative DFS and BFS"
        }
    ],
    "qc": "297.json"
}