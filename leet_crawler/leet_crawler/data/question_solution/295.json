{
    "posts": [
        {
            "java": "class MedianFinder {--newline----newline--    private Queue<Long> small = new PriorityQueue(),--newline--                        large = new PriorityQueue();--newline----newline--    public void addNum(int num) {--newline--        large.add((long) num);--newline--        small.add(-large.poll());--newline--        if (large.size() < small.size())--newline--            large.add(-small.poll());--newline--    }--newline----newline--    public double findMedian() {--newline--        return large.size() > small.size()--newline--               ? large.peek()--newline--               : (large.peek() - small.peek()) / 2.0;--newline--    }--newline--};--newline--",
            "is_locked": false,
            "cpp": "class MedianFinder {--newline--    priority_queue<long> small, large;--newline--public:--newline----newline--    void addNum(int num) {--newline--        small.push(num);--newline--        large.push(-small.top());--newline--        small.pop();--newline--        if (small.size() < large.size()) {--newline--            small.push(-large.top());--newline--            large.pop();--newline--        }--newline--    }--newline----newline--    double findMedian() {--newline--        return small.size() > large.size()--newline--               ? small.top()--newline--               : (small.top() - large.top()) / 2.0;--newline--    }--newline--};--newline--",
            "python": "from heapq import *--newline----newline--class MedianFinder:--newline----tab----newline----tab--    def __init__(self):--newline----tab--        self.heaps = [], []--newline----tab----newline----tab--    def addNum(self, num):--newline----tab--        small, large = self.heaps--newline----tab--        heappush(small, -heappushpop(large, num))--newline----tab--        if len(large) < len(small):--newline----tab--            heappush(large, -heappop(small))--newline----tab----newline----tab--    def findMedian(self):--newline----tab--        small, large = self.heaps--newline----tab--        if len(large) > len(small):--newline----tab--            return float(large[0])--newline----tab--        return (large[0] - small[0]) / 2.0",
            "topic_title": "Short simple Java&#x2F;C++&#x2F;Python, O(log n) + O(1)"
        },
        {
            "java": "class MedianFinder {--newline--    // max queue is always larger or equal to min queue--newline--    PriorityQueue<Integer> min = new PriorityQueue();--newline--    PriorityQueue<Integer> max = new PriorityQueue(1000, Collections.reverseOrder());--newline--    // Adds a number into the data structure.--newline--    public void addNum(int num) {--newline--        max.offer(num);--newline--        min.offer(max.poll());--newline--        if (max.size() < min.size()){--newline--            max.offer(min.poll());--newline--        }--newline--    }--newline----newline--    // Returns the median of current data stream--newline--    public double findMedian() {--newline--        if (max.size() == min.size()) return (max.peek() + min.peek()) /  2.0;--newline--        else return max.peek();--newline--    }--newline--};",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my java solution logn to insert, O(1) to query"
        },
        {
            "java": "class MedianFinder {--newline--    private PriorityQueue<Integer> minH;--newline--    private PriorityQueue<Integer> maxH;--newline--    --newline--    MedianFinder(){--newline--        minH = new PriorityQueue<Integer>();--newline--        maxH = new PriorityQueue<Integer>(1, new Comparator<Integer>(){--newline--            public int compare(Integer o1, Integer o2) {--newline--                if (o1.intValue()>o2.intValue()) return -1;--newline--                if (o1.intValue()<o2.intValue()) return 1;--newline--                return 0;--newline--            }--newline--        });--newline--    }--newline--    --newline--    --newline--    // Adds a number into the data structure.--newline--    public void addNum(int num) {--newline--        if ((minH.size()==0)&&(maxH.size()==0)) minH.add(num);--newline--        else if ((minH.size())>(maxH.size())) {--newline--            if (num>minH.peek()) {--newline--                maxH.add(minH.poll());--newline--                minH.add(num);--newline--            } else maxH.add(num);--newline--        } else if ((minH.size())<(maxH.size())) {--newline--            if (num<maxH.peek()) {--newline--                minH.add(maxH.poll());--newline--                maxH.add(num);--newline--            } else minH.add(num);            --newline--        } else {--newline--            if (num<maxH.peek()) maxH.add(num);--newline--            else minH.add(num);             --newline--        }--newline--    }--newline----newline--    // Returns the median of current data stream--newline--    public double findMedian() {--newline--        if ((minH.size()==0)&&(maxH.size()==0)) return 0.0;--newline--        if ((minH.size())>(maxH.size())) return (double)(minH.peek());--newline--        if ((minH.size())<(maxH.size())) return (double)(maxH.peek());--newline--        return ((double)(maxH.peek()+minH.peek()))/2.0;--newline--    }--newline--};--newline----newline--// Your MedianFinder object will be instantiated and called as such:--newline--// MedianFinder mf = new MedianFinder();--newline--// mf.addNum(1);--newline--// mf.findMedian();",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy to understand double-heap solution in Java"
        },
        {
            "java": "public class MedianFinder {--newline--    private PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());--newline--    private PriorityQueue<Integer> large = new PriorityQueue<>();--newline--    private boolean even = true;--newline--    --newline--    public double findMedian() {--newline--        if (even)--newline--            return (small.peek() + large.peek()) / 2.0;--newline--        else--newline--            return small.peek();--newline--    }--newline--    --newline--    public void addNum(int num) {--newline--        if (even) {--newline--            large.offer(num);--newline--            small.offer(large.poll());--newline--        } else {--newline--            small.offer(num);--newline--            large.offer(small.poll());--newline--        }--newline--        even = !even;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": "from heapq import *--newline----newline----newline--class MedianFinder:--newline----tab--    def __init__(self):--newline----tab--        self.small = []  # the smaller half of the list, max heap (invert min-heap)--newline----tab--        self.large = []  # the larger half of the list, min heap--newline----tab----newline----tab--    def addNum(self, num):--newline----tab--        if len(self.small) == len(self.large):--newline----tab--            heappush(self.large, -heappushpop(self.small, -num))--newline----tab--        else:--newline----tab--            heappush(self.small, -heappushpop(self.large, num))--newline----tab----newline----tab--    def findMedian(self):--newline----tab--        if len(self.small) == len(self.large):--newline----tab--            return float(self.large[0] - self.small[0]) / 2.0--newline----tab--        else:--newline----tab--            return float(self.large[0])--newline----tab----newline----tab--# 18 / 18 test cases passed.--newline----tab--# Status: Accepted--newline----tab--# Runtime: 388 ms--newline----tab--",
            "topic_title": "Java&#x2F;Python two heap solution, O(log n) add, O(1) find"
        },
        {
            "java": "class MedianFinder {--newline----newline--    Queue[] q = {new PriorityQueue(), new PriorityQueue(Collections.reverseOrder())};--newline--    int i = 0;--newline----newline--    public void addNum(int num) {--newline--        q[i].add(num);--newline--        q[i^=1].add(q[i^1].poll());--newline--    }--newline----newline--    public double findMedian() {--newline--        return ((int)(q[1].peek()) + (int)(q[i].peek())) / 2.0;--newline--    }--newline--};--newline--",
            "is_locked": false,
            "cpp": null,
            "python": "from heapq import *--newline----newline--class MedianFinder:--newline----tab----newline----tab--    def __init__(self):--newline----tab--        self.data = 1, [], []--newline----tab----newline----tab--    def addNum(self, num):--newline----tab--        sign, h1, h2 = self.data--newline----tab--        heappush(h2, -heappushpop(h1, num * sign))--newline----tab--        self.data = -sign, h2, h1--newline----tab----newline----tab--    def findMedian(self):--newline----tab--        sign, h1, h2 = d = self.data--newline----tab--        return (h1[0] * sign - d[-sign][0]) / 2.0",
            "topic_title": "Very Short, O(log n) + O(1)"
        }
    ],
    "qc": "295.json"
}