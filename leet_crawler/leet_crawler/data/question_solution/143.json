{
    "posts": [
        {
            "java": "public class Solution {--newline--    public void reorderList(ListNode head) {--newline--                if(head==null||head.next==null) return;--newline--                --newline--                //Find the middle of the list--newline--                ListNode p1=head;--newline--                ListNode p2=head;--newline--                while(p2.next!=null&&p2.next.next!=null){ --newline--                    p1=p1.next;--newline--                    p2=p2.next.next;--newline--                }--newline--                --newline--                //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4--newline--                ListNode preMiddle=p1;--newline--                ListNode preCurrent=p1.next;--newline--                while(preCurrent.next!=null){--newline--                    ListNode current=preCurrent.next;--newline--                    preCurrent.next=current.next;--newline--                    current.next=preMiddle.next;--newline--                    preMiddle.next=current;--newline--                }--newline--                --newline--                //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4--newline--                p1=head;--newline--                p2=preMiddle.next;--newline--                while(p1!=preMiddle){--newline--                    preMiddle.next=p2.next;--newline--                    p2.next=p1.next;--newline--                    p1.next=p2;--newline--                    p1=p2.next;--newline--                    p2=preMiddle.next;--newline--                }--newline--            }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution with 3 steps"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    // O(N) time, O(1) space in total--newline--    void reorderList(ListNode *head) {--newline--        if (!head || !head->next) return;--newline--        --newline--        // find the middle node: O(n)--newline--        ListNode *p1 = head, *p2 = head->next;--newline--        while (p2 && p2->next) {--newline--            p1 = p1->next;--newline--            p2 = p2->next->next;--newline--        }--newline--        --newline--        // cut from the middle and reverse the second half: O(n)--newline--        ListNode *head2 = p1->next;--newline--        p1->next = NULL;--newline--        --newline--        p2 = head2->next;--newline--        head2->next = NULL;--newline--        while (p2) {--newline--            p1 = p2->next;--newline--            p2->next = head2;--newline--            head2 = p2;--newline--            p2 = p1;--newline--        }--newline--        --newline--        // merge two lists: O(n)--newline--        for (p1 = head, p2 = head2; p1; ) {--newline--            auto t = p1->next;--newline--            p1 = p1->next = p2;--newline--            p2 = t;--newline--        }--newline--        --newline--        //for (p1 = head, p2 = head2; p2; ) {--newline--        //    auto t = p1->next;--newline--        //    p1->next = p2;--newline--        //    p2 = p2->next;--newline--        //    p1 = p1->next->next = t;--newline--        //}--newline--    }--newline--}",
            "python": null,
            "topic_title": "A concise O(n) time, O(1) in place solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "# Splits in place a list in two halves, the first half is >= in size than the second.--newline--# @return A tuple containing the heads of the two halves--newline--def _splitList(head):--newline--    fast = head--newline--    slow = head--newline--    while fast and fast.next:--newline--        slow = slow.next--newline--        fast = fast.next--newline--        fast = fast.next--newline----newline--    middle = slow.next--newline--    slow.next = None--newline----newline--    return head, middle--newline----newline--# Reverses in place a list.--newline--# @return Returns the head of the new reversed list--newline--def _reverseList(head):--newline----newline--  last = None--newline--  currentNode = head--newline----newline--  while currentNode:--newline--    nextNode = currentNode.next--newline--    currentNode.next = last--newline--    last = currentNode--newline--    currentNode = nextNode--newline----newline--  return last--newline----newline--# Merges in place two lists--newline--# @return The newly merged list.--newline--def _mergeLists(a, b):--newline----newline--    tail = a--newline--    head = a--newline----newline--    a = a.next--newline--    while b:--newline--        tail.next = b--newline--        tail = tail.next--newline--        b = b.next--newline--        if a:--newline--            a, b = b, a--newline--            --newline--    return head--newline----newline----newline--class Solution:--newline----tab----newline----tab--    # @param head, a ListNode--newline----tab--    # @return nothing--newline----tab--    def reorderList(self, head):--newline----tab----newline----tab--        if not head or not head.next:--newline----tab--            return--newline----tab----newline----tab--        a, b = _splitList(head)--newline----tab--        b = _reverseList(b)--newline----tab--        head = _mergeLists(a, b)",
            "topic_title": "A python solution O(n) time, O(1) space"
        },
        {
            "java": "  public class Solution {--newline--    --newline--    public void reorderList(ListNode head) {--newline--      if (head == null || head.next == null)--newline--          return;--newline--      --newline--      // step 1. cut the list to two halves--newline--      // prev will be the tail of 1st half--newline--      // slow will be the head of 2nd half--newline--      ListNode prev = null, slow = head, fast = head, l1 = head;--newline--      --newline--      while (fast != null && fast.next != null) {--newline--        prev = slow;--newline--        slow = slow.next;--newline--        fast = fast.next.next;--newline--      }--newline--      --newline--      prev.next = null;--newline--      --newline--      // step 2. reverse the 2nd half--newline--      ListNode l2 = reverse(slow);--newline--      --newline--      // step 3. merge the two halves--newline--      merge(l1, l2);--newline--    }--newline--    --newline--    ListNode reverse(ListNode head) {--newline--      ListNode prev = null, curr = head, next = null;--newline--      --newline--      while (curr != null) {--newline--        next = curr.next;--newline--        curr.next = prev;--newline--        prev = curr;--newline--        curr = next;--newline--      }--newline--      --newline--      return prev;--newline--    }--newline--    --newline--    void merge(ListNode l1, ListNode l2) {--newline--      while (l1 != null) {--newline--        ListNode n1 = l1.next, n2 = l2.next;--newline--        l1.next = l2;--newline--        --newline--        if (n1 == null)--newline--          break;--newline--            --newline--        l2.next = n1;--newline--        l1 = n1;--newline--        l2 = n2;--newline--      }--newline--    }--newline----newline--  }",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution with 3 steps"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "/**--newline-- * Definition for singly-linked list.--newline-- * struct ListNode {--newline-- *     int val;--newline-- *     ListNode *next;--newline-- *     ListNode(int x) : val(x), next(NULL) {}--newline-- * };--newline-- */--newline--class Solution {--newline--public:--newline--    void reorderList(ListNode *head) {--newline--        if(head == NULL || head->next == NULL || head->next->next==NULL)--newline--            return;--newline--        //find the middle of the list, and split into two lists.    --newline--        ListNode *p=head,*q=head;--newline--        while(p && q && q->next && q->next->next){--newline--            p=p->next;--newline--            q=q->next->next;--newline--        }--newline--        --newline--        ListNode *mid = p->next;--newline--        p->next=NULL;--newline--        p=head;--newline--        //reverse from the middle to the end--newline--        ListNode *q1=mid, *q2,*q3;--newline--        if(mid->next){--newline--            q1=mid;--newline--            q2=mid->next;--newline--            while(q2){--newline--                q3=q2->next;--newline--                q2->next=q1;--newline--                q1=q2;--newline--                q2=q3;--newline--                --newline--            }--newline--            mid->next=NULL;--newline--        }--newline--        q=q1;--newline--        //merge these two list--newline--        ListNode *s=p;--newline--        p=p->next;--newline--        while(p && q){--newline--           s->next=q;--newline--           s=s->next;--newline--           q=q->next;--newline--           --newline--           s->next=p;--newline--           s=s->next;--newline--           p=p->next;--newline--        }--newline--        if(p){--newline--            s->next=p;--newline--        }--newline--        if(q){--newline--            s->next=q;--newline--        }--newline--    }--newline--};",
            "python": null,
            "topic_title": "My O(n) C++ Method, accepted"
        }
    ],
    "qc": "143.json"
}