{
    "posts": [
        {
            "java": "public class Codec {--newline--    private static final String SEP = \",\";--newline--    private static final String NULL = \"null\";--newline--    // Encodes a tree to a single string.--newline--    public String serialize(TreeNode root) {--newline--        StringBuilder sb = new StringBuilder();--newline--        if (root == null) return NULL;--newline--        //traverse it recursively if you want to, I am doing it iteratively here--newline--        Stack<TreeNode> st = new Stack<>();--newline--        st.push(root);--newline--        while (!st.empty()) {--newline--            root = st.pop();--newline--            sb.append(root.val).append(SEP);--newline--            if (root.right != null) st.push(root.right);--newline--            if (root.left != null) st.push(root.left);--newline--        }--newline--        return sb.toString();--newline--    }--newline----newline--    // Decodes your encoded data to tree.--newline--    // pre-order traversal--newline--    public TreeNode deserialize(String data) {--newline--        if (data.equals(NULL)) return null;--newline--        String[] strs = data.split(SEP);--newline--        Queue<Integer> q = new LinkedList<>();--newline--        for (String e : strs) {--newline--            q.offer(Integer.parseInt(e));--newline--        }--newline--        return getNode(q);--newline--    }--newline--    --newline--    // some notes:--newline--    //   5--newline--    //  3 6--newline--    // 2   7--newline--    private TreeNode getNode(Queue<Integer> q) { //q: 5,3,2,6,7--newline--        if (q.isEmpty()) return null;--newline--        TreeNode root = new TreeNode(q.poll());//root (5)--newline--        Queue<Integer> samllerQueue = new LinkedList<>();--newline--        while (!q.isEmpty() && q.peek() < root.val) {--newline--            samllerQueue.offer(q.poll());--newline--        }--newline--        //smallerQueue : 3,2   storing elements smaller than 5 (root)--newline--        root.left = getNode(samllerQueue);--newline--        //q: 6,7   storing elements bigger than 5 (root)--newline--        root.right = getNode(q);--newline--        return root;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java PreOrder + Queue solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Codec:--newline----tab----newline----tab--    def serialize(self, root):--newline----tab--        def preorder(node):--newline----tab--            if node:--newline----tab--                vals.append(str(node.val))--newline----tab--                preorder(node.left)--newline----tab--                preorder(node.right)--newline----tab--        vals = []--newline----tab--        preorder(root)--newline----tab--        return ' '.join(vals)--newline----tab----newline----tab--    def deserialize(self, data):--newline----tab--        preorder = map(int, data.split())--newline----tab--        inorder = sorted(preorder)--newline----tab--        return self.buildTree(preorder, inorder)--newline----tab----newline----tab--    def buildTree(self, preorder, inorder):--newline----tab--        def build(stop):--newline----tab--            if inorder and inorder[-1] != stop:--newline----tab--                root = TreeNode(preorder.pop())--newline----tab--                root.left = build(root.val)--newline----tab--                inorder.pop()--newline----tab--                root.right = build(stop)--newline----tab--                return root--newline----tab--        preorder.reverse()--newline----tab--        inorder.reverse()--newline----tab--        return build(None)--newline----tab--",
            "topic_title": "Deserialize from preorder and computed inorder, reusing old solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Codec {--newline--public:--newline--        // Encodes a tree to a single string.--newline--        void serialize(TreeNode* root, ostringstream& out )--newline--        {--newline--            if ( !root ) return;--newline--            out << root->val << \",\";--newline--            serialize(root->left, out);--newline--            serialize(root->right, out);--newline--        }--newline--        --newline--        string serialize(TreeNode* root) {--newline--            ostringstream ss;--newline--            serialize(root, ss);--newline--            return ss.str();--newline--        }--newline--    --newline--        TreeNode* deserialize(const string& s, int lower, int upper, int & pos )--newline--        {--newline--            // pos is a variable to record the end of decoded buffer --newline--            if ( pos == s.size() ) return nullptr;--newline--            int cur_pos = pos;--newline--            int number = 0;--newline--            while( s[cur_pos] != ',')--newline--            {--newline--                number = number * 10 + s[cur_pos] - '0';--newline--                ++cur_pos;--newline--            }--newline--            ++cur_pos;--newline--            // The next number is not part of current subtree, should return nullptr--newline--            if ( number < lower || number > upper ) return nullptr;--newline--    --newline--            TreeNode* root = new TreeNode( number );--newline--            pos = cur_pos; // update pos --newline--            root->left =  deserialize( s, lower, root->val, pos );--newline--            root->right = deserialize( s, root->val, upper, pos );--newline--            return root;--newline--        }--newline--        // Decodes your encoded data to tree.--newline--        TreeNode* deserialize(string data) {--newline--            int pos = 0;--newline--            return deserialize( data, INT_MIN, INT_MAX, pos );--newline--            --newline--        }--newline--    --newline--}",
            "python": null,
            "topic_title": "Using lower bound and upper bound to deserialize BST"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Codec {--newline--public:--newline----newline--    // Encodes a tree to a single string.--newline--    string serialize(TreeNode* root) {--newline--        string order;--newline--        inorderDFS(root, order);--newline--        return order;--newline--    }--newline--    --newline--    inline void inorderDFS(TreeNode* root, string& order) {--newline--        if (!root) return;--newline--        char buf[4];--newline--        memcpy(buf, &(root->val), sizeof(int)); //burn the int into 4 chars--newline--        for (int i=0; i<4; i++) order.push_back(buf[i]);--newline--        inorderDFS(root->left, order);--newline--        inorderDFS(root->right, order);--newline--    }--newline----newline--    // Decodes your encoded data to tree.--newline--    TreeNode* deserialize(string data) {--newline--        int pos = 0;--newline--        return reconstruct(data, pos, INT_MIN, INT_MAX);--newline--    }--newline--    --newline--    inline TreeNode* reconstruct(const string& buffer, int& pos, int minValue, int maxValue) {--newline--        if (pos >= buffer.size()) return NULL; //using pos to check whether buffer ends is better than using char* directly.--newline--        --newline--        int value;--newline--        memcpy(&value, &buffer[pos], sizeof(int));--newline--        if (value < minValue || value > maxValue) return NULL;--newline--        --newline--        TreeNode* node = new TreeNode(value);--newline--        pos += sizeof(int);--newline--        node->left = reconstruct(buffer, pos, minValue, value);--newline--        node->right = reconstruct(buffer, pos, value, maxValue);--newline--        return node;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Concise C++ 19ms solution beating 99.4%"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "what&#x27;s the difference between this and #297 ?"
        }
    ],
    "qc": "449.json"
}