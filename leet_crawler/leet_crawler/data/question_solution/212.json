{
    "posts": [
        {
            "java": "public List<String> findWords(char[][] board, String[] words) {--newline--    List<String> res = new ArrayList<>();--newline--    TrieNode root = buildTrie(words);--newline--    for (int i = 0; i < board.length; i++) {--newline--        for (int j = 0; j < board[0].length; j++) {--newline--            dfs (board, i, j, root, res);--newline--        }--newline--    }--newline--    return res;--newline--}--newline----newline--public void dfs(char[][] board, int i, int j, TrieNode p, List<String> res) {--newline--    char c = board[i][j];--newline--    if (c == '#' || p.next[c - 'a'] == null) return;--newline--    p = p.next[c - 'a'];--newline--    if (p.word != null) {   // found one--newline--        res.add(p.word);--newline--        p.word = null;     // de-duplicate--newline--    }--newline----newline--    board[i][j] = '#';--newline--    if (i > 0) dfs(board, i - 1, j ,p, res); --newline--    if (j > 0) dfs(board, i, j - 1, p, res);--newline--    if (i < board.length - 1) dfs(board, i + 1, j, p, res); --newline--    if (j < board[0].length - 1) dfs(board, i, j + 1, p, res); --newline--    board[i][j] = c;--newline--}--newline----newline--public TrieNode buildTrie(String[] words) {--newline--    TrieNode root = new TrieNode();--newline--    for (String w : words) {--newline--        TrieNode p = root;--newline--        for (char c : w.toCharArray()) {--newline--            int i = c - 'a';--newline--            if (p.next[i] == null) p.next[i] = new TrieNode();--newline--            p = p.next[i];--newline--       }--newline--       p.word = w;--newline--    }--newline--    return root;--newline--}--newline----newline--class TrieNode {--newline--    TrieNode[] next = new TrieNode[26];--newline--    String word;--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java 15ms Easiest Solution (100.00%)"
        },
        {
            "java": "public class Solution {--newline--    Set<String> res = new HashSet<String>();--newline--    --newline--    public List<String> findWords(char[][] board, String[] words) {--newline--        Trie trie = new Trie();--newline--        for (String word : words) {--newline--            trie.insert(word);--newline--        }--newline--        --newline--        int m = board.length;--newline--        int n = board[0].length;--newline--        boolean[][] visited = new boolean[m][n];--newline--        for (int i = 0; i < m; i++) {--newline--            for (int j = 0; j < n; j++) {--newline--                dfs(board, visited, \"\", i, j, trie);--newline--            }--newline--        }--newline--        --newline--        return new ArrayList<String>(res);--newline--    }--newline--    --newline--    public void dfs(char[][] board, boolean[][] visited, String str, int x, int y, Trie trie) {--newline--        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length) return;--newline--        if (visited[x][y]) return;--newline--        --newline--        str += board[x][y];--newline--        if (!trie.startsWith(str)) return;--newline--        --newline--        if (trie.search(str)) {--newline--            res.add(str);--newline--        }--newline--        --newline--        visited[x][y] = true;--newline--        dfs(board, visited, str, x - 1, y, trie);--newline--        dfs(board, visited, str, x + 1, y, trie);--newline--        dfs(board, visited, str, x, y - 1, trie);--newline--        dfs(board, visited, str, x, y + 1, trie);--newline--        visited[x][y] = false;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "My simple and clean Java code using DFS and Trie"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--private:--newline--class Trie--newline--{--newline--public:    --newline--    Trie * children[26];--newline--    bool isLeaf;--newline--    int  wordIdx;--newline--    int prefixCount;--newline--    --newline--    Trie()--newline--    {--newline--        isLeaf = false;--newline--        wordIdx = 0;--newline--        prefixCount = 0;--newline--        fill_n(children, 26, nullptr);--newline--    }--newline--    --newline--    ~Trie()--newline--    {--newline--        for(auto i=0; i<26; ++i) delete children[i];--newline--    }--newline--};--newline--    void insertWord(Trie *root,  const vector<string>& words, int idx)--newline--    {--newline--        int i, childID, len = words[idx].size();--newline--        for(i=0, root->prefixCount++ ; i<len; ++i)--newline--        {--newline--            childID = words[idx][i]-'a';--newline--            if(!root->children[childID]) root->children[childID] = new Trie();--newline--            root = root->children[childID];--newline--            ++root->prefixCount;--newline--        }--newline--        root->isLeaf = true; --newline--        root->wordIdx = idx;--newline--    }--newline--    --newline--    Trie *buildTrie(const vector<string> &words)--newline--    {--newline--        Trie *root = new Trie();--newline--        for(int i=0; i < words.size(); ++i) insertWord(root, words, i);--newline--        return root;--newline--    }--newline--    --newline--    int dfs_Trie(vector<string> &res, Trie *root, vector<vector<char>>& board, vector<string>& words, int row, int col)--newline--    {--newline--        int detected = 0;--newline----newline--        if(root->isLeaf)--newline--        {--newline--            ++detected;--newline--            root->isLeaf = false;--newline--            res.push_back(words[root->wordIdx]);--newline--        }--newline--        --newline--        if( row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col]=='*' || !root->children[ board[row][col]-'a'] || root->children[ board[row][col]-'a']->prefixCount <= 0 ) return detected;--newline--        int curC = board[row][col] - 'a';--newline--        board[row][col] = '*';--newline--        detected += dfs_Trie(res, root->children[curC], board, words, row-1, col) + --newline--               dfs_Trie(res, root->children[curC], board, words, row+1, col) +    --newline--               dfs_Trie(res, root->children[curC], board, words, row, col - 1) +    --newline--               dfs_Trie(res, root->children[curC], board, words, row, col + 1) ;--newline--        root->prefixCount -=detected;--newline--        board[row][col] = curC+'a';--newline--        return detected;--newline--    }--newline--    --newline--public:--newline--    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {--newline--        int M, N, wordNum = words.size();--newline--        vector<string> res;--newline--        if( !(M = board.size()) || !(N = board[0].size()) || !wordNum) return res;--newline--        Trie *root = buildTrie(words);--newline--        for(auto i=0; i<M && root->prefixCount; ++i)--newline--            for(auto j=0; j<N; ++j)--newline--                dfs_Trie(res, root, board, words, i, j);--newline--        delete root;--newline--        return res;--newline--    }--newline--};",
            "python": null,
            "topic_title": "My C++ Trie + Backtrace based solution (48 ms)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class TrieNode{--newline--public:--newline--    bool is_end;--newline--    vector<TrieNode*> children;--newline--    TrieNode(){--newline--        is_end=false;--newline--        children=vector<TrieNode*>(26, NULL);--newline--    }   --newline--};--newline----newline--class Trie{--newline--public:--newline--    TrieNode* getRoot(){return root;}--newline--    Trie(vector<string>& words){--newline--        root=new TrieNode();--newline--        for(int i=0; i<words.size(); ++i)--newline--            addWord(words[i]);--newline--    }--newline--    void addWord(const string& word){--newline--        TrieNode* cur=root;--newline--        for(int i=0; i<word.size(); ++i){--newline--            int index=word[i]-'a';--newline--            if(cur->children[index]==NULL)   --newline--               cur->children[index]=new TrieNode();--newline--            cur=cur->children[index];    --newline--        }--newline--        cur->is_end=true;--newline--    }--newline--private:--newline--    TrieNode* root;--newline--};--newline----newline--class Solution {--newline--public:--newline--    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {--newline--        Trie* trie = new Trie(words);--newline--        TrieNode* root=trie->getRoot();--newline--        set<string> result_set;--newline--        for(int x=0; x<board.size(); ++x)--newline--            for(int y=0; y<board[0].size(); ++y)--newline--                findWords(board, x, y, root, \"\", result_set);--newline--        --newline--        vector<string> result;--newline--        for(auto it:result_set)    result.push_back(it);--newline--        return result;        --newline--    }--newline--private:--newline--    void findWords(vector<vector<char>>& board, int x, int y, TrieNode* root, string word, set<string>& result){--newline--        if(x<0||x>=board.size()||y<0||y>=board[0].size() || board[x][y]==' ') return;--newline--        --newline--        if(root->children[board[x][y]-'a'] != NULL){--newline--            word=word+board[x][y];--newline--            root=root->children[board[x][y]-'a']; --newline--            if(root->is_end) result.insert(word);--newline--            char c=board[x][y];--newline--            board[x][y]=' ';--newline--            findWords(board, x+1, y, root, word, result);--newline--            findWords(board, x-1, y, root, word, result);--newline--            findWords(board, x, y+1, root, word, result);--newline--            findWords(board, x, y-1, root, word, result);--newline--            board[x][y]=c;        --newline--        }--newline--    }--newline--};",
            "python": null,
            "topic_title": "My AC very clean C++ code"
        },
        {
            "java": "public class Solution {--newline--    public class TrieNode{--newline--        public boolean isWord = false;--newline--        public TrieNode[] child = new TrieNode[26];--newline--        public TrieNode(){--newline--            --newline--        }--newline--    }--newline--    --newline--    TrieNode root = new TrieNode();--newline--    boolean[][] flag;--newline--    public List<String> findWords(char[][] board, String[] words) {--newline--        Set<String> result = new HashSet<>();--newline--        flag = new boolean[board.length][board[0].length];--newline--        --newline--        addToTrie(words);--newline--        --newline--        for(int i = 0; i < board.length; i++){--newline--            for(int j = 0; j < board[0].length; j++){--newline--                if(root.child[board[i][j] - 'a'] != null){--newline--                    search(board, i, j, root, \"\", result);--newline--                }--newline--            }--newline--        }--newline--        --newline--        return new LinkedList<>(result);--newline--    }--newline--    --newline--    private void addToTrie(String[] words){--newline--        for(String word: words){--newline--            TrieNode node = root;--newline--            for(int i = 0; i < word.length(); i++){--newline--                char ch = word.charAt(i);--newline--                if(node.child[ch - 'a'] == null){--newline--                    node.child[ch - 'a'] = new TrieNode();--newline--                }--newline--                node = node.child[ch - 'a'];--newline--            }--newline--            node.isWord = true;--newline--        }--newline--    }--newline--    --newline--    private void search(char[][] board, int i, int j, TrieNode node, String word, Set<String> result){--newline--        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || flag[i][j]){--newline--            return;--newline--        }--newline--        --newline--        if(node.child[board[i][j] - 'a'] == null){--newline--            return;--newline--        }--newline--        --newline--        flag[i][j] = true;--newline--        node = node.child[board[i][j] - 'a'];--newline--        if(node.isWord){--newline--            result.add(word + board[i][j]);--newline--        }--newline--        --newline--        search(board, i-1, j, node, word + board[i][j], result);--newline--        search(board, i+1, j, node, word + board[i][j], result);--newline--        search(board, i, j-1, node, word + board[i][j], result);--newline--        search(board, i, j+1, node, word + board[i][j], result);--newline--        --newline--        flag[i][j] = false;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "My Java solution using Trie"
        }
    ],
    "qc": "212.json"
}