{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<List<Integer>> palindromePairs(String[] words) {--newline--        List<List<Integer>> ret = new ArrayList<>(); --newline--        if (words == null || words.length < 2) return ret;--newline--        Map<String, Integer> map = new HashMap<String, Integer>();--newline--        for (int i=0; i<words.length; i++) map.put(words[i], i);--newline--        for (int i=0; i<words.length; i++) {--newline--            // System.out.println(words[i]);--newline--            for (int j=0; j<=words[i].length(); j++) { // notice it should be \"j <= words[i].length()\"--newline--                String str1 = words[i].substring(0, j);--newline--                String str2 = words[i].substring(j);--newline--                if (isPalindrome(str1)) {--newline--                    String str2rvs = new StringBuilder(str2).reverse().toString();--newline--                    if (map.containsKey(str2rvs) && map.get(str2rvs) != i) {--newline--                        List<Integer> list = new ArrayList<Integer>();--newline--                        list.add(map.get(str2rvs));--newline--                        list.add(i);--newline--                        ret.add(list);--newline--                        // System.out.printf(\"isPal(str1): %s\\n\", list.toString());--newline--                    }--newline--                }--newline--                if (isPalindrome(str2)) {--newline--                    String str1rvs = new StringBuilder(str1).reverse().toString();--newline--                    // check \"str.length() != 0\" to avoid duplicates--newline--                    if (map.containsKey(str1rvs) && map.get(str1rvs) != i && str2.length()!=0) { --newline--                        List<Integer> list = new ArrayList<Integer>();--newline--                        list.add(i);--newline--                        list.add(map.get(str1rvs));--newline--                        ret.add(list);--newline--                        // System.out.printf(\"isPal(str2): %s\\n\", list.toString());--newline--                    }--newline--                }--newline--            }--newline--        }--newline--        return ret;--newline--    }--newline--    --newline--    private boolean isPalindrome(String str) {--newline--        int left = 0;--newline--        int right = str.length() - 1;--newline--        while (left <= right) {--newline--            if (str.charAt(left++) !=  str.charAt(right--)) return false;--newline--        }--newline--        return true;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "150 ms 45 lines JAVA solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "O(n*k^2) java solution with Trie structure (n: total number of words; k: average length of each word)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "    class Solution {--newline--    public:--newline--        vector<vector<int>> palindromePairs(vector<string>& words) {--newline--            unordered_map<string, int> dict;--newline--            vector<vector<int>> ans;--newline--            // build dictionary--newline--            for(int i = 0; i < words.size(); i++) {--newline--                string key = words[i];--newline--                reverse(key.begin(), key.end());--newline--                dict[key] = i;--newline--            }--newline--            // edge case: if empty string \"\" exists, find all palindromes to become pairs (\"\", self)--newline--            if(dict.find(\"\")!=dict.end()){--newline--                for(int i = 0; i < words.size(); i++){--newline--                    if(i == dict[\"\"]) continue;--newline--                    if(isPalindrome(words[i])) ans.push_back({dict[\"\"], i}); // 1) if self is palindrome, here ans covers concatenate(\"\", self) --newline--                }--newline--            }--newline----newline--            for(int i = 0; i < words.size(); i++) {--newline--                for(int j = 0; j < words[i].size(); j++) {--newline--                    string left = words[i].substr(0, j);--newline--                    string right = words[i].substr(j, words[i].size() - j);--newline----newline--                    if(dict.find(left) != dict.end() && isPalindrome(right) && dict[left] != i) {--newline--                        ans.push_back({i, dict[left]});     // 2) when j = 0, left = \"\", right = self, so here covers concatenate(self, \"\")--newline--                    }--newline----newline--                    if(dict.find(right) != dict.end() && isPalindrome(left) && dict[right] != i) {--newline--                        ans.push_back({dict[right], i});--newline--                    }--newline--                }--newline--            }--newline----newline--            return ans;        --newline--        }--newline----newline--        bool isPalindrome(string str){--newline--            int i = 0;--newline--            int j = str.size() - 1; --newline----newline--            while(i < j) {--newline--                if(str[i++] != str[j--]) return false;--newline--            }--newline----newline--            return true;--newline--        }--newline----newline--    };",
            "python": null,
            "topic_title": "Easy to understand AC C++ solution O(n*k^2) using map"
        },
        {
            "java": "public class Solution {--newline--public List<List<Integer>> palindromePairs(String[] words) {--newline--    List<List<Integer>> res = new ArrayList<List<Integer>>();--newline--    if(words == null || words.length == 0){--newline--        return res;--newline--    }--newline--    //build the map save the key-val pairs: String - idx--newline--    HashMap<String, Integer> map = new HashMap<>();--newline--    for(int i = 0; i < words.length; i++){--newline--        map.put(words[i], i);--newline--    }--newline--    --newline--    //special cases: \"\" can be combine with any palindrome string--newline--    if(map.containsKey(\"\")){--newline--        int blankIdx = map.get(\"\");--newline--        for(int i = 0; i < words.length; i++){--newline--            if(isPalindrome(words[i])){--newline--                if(i == blankIdx) continue;--newline--                res.add(Arrays.asList(blankIdx, i));--newline--                res.add(Arrays.asList(i, blankIdx));--newline--            }--newline--        }--newline--    }--newline--    --newline--    //find all string and reverse string pairs--newline--    for(int i = 0; i < words.length; i++){--newline--        String cur_r = reverseStr(words[i]);--newline--        if(map.containsKey(cur_r)){--newline--            int found = map.get(cur_r);--newline--            if(found == i) continue;--newline--            res.add(Arrays.asList(i, found));--newline--        }--newline--    }--newline--    --newline--    //find the pair s1, s2 that --newline--    //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)--newline--    //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)--newline--    for(int i = 0; i < words.length; i++){--newline--        String cur = words[i];--newline--        for(int cut = 1; cut < cur.length(); cut++){--newline--            if(isPalindrome(cur.substring(0, cut))){--newline--                String cut_r = reverseStr(cur.substring(cut));--newline--                if(map.containsKey(cut_r)){--newline--                    int found = map.get(cut_r);--newline--                    if(found == i) continue;--newline--                    res.add(Arrays.asList(found, i));--newline--                }--newline--            }--newline--            if(isPalindrome(cur.substring(cut))){--newline--                String cut_r = reverseStr(cur.substring(0, cut));--newline--                if(map.containsKey(cut_r)){--newline--                    int found = map.get(cut_r);--newline--                    if(found == i) continue;--newline--                    res.add(Arrays.asList(i, found));--newline--                }--newline--            }--newline--        }--newline--    }--newline--    --newline--    return res;--newline--}--newline----newline--public String reverseStr(String str){--newline--    StringBuilder sb= new StringBuilder(str);--newline--    return sb.reverse().toString();--newline--}--newline----newline--public boolean isPalindrome(String s){--newline--    int i = 0;--newline--    int j = s.length() - 1;--newline--    while(i <= j){--newline--        if(s.charAt(i) != s.charAt(j)){--newline--            return false;--newline--        }--newline--        i++;--newline--        j--;--newline--    }--newline--    return true;--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "The Easy-to-unserstand JAVA Solution"
        },
        {
            "java": "public class Solution {--newline--    public List<List<Integer>> palindromePairs(String[] words) {--newline--        List<List<Integer>> pairs = new LinkedList<>();--newline--        if (words == null) return pairs;--newline--        HashMap<String, Integer> map = new HashMap<>();--newline--        for (int i = 0; i < words.length; ++ i) map.put(words[i], i);--newline--        for (int i = 0; i < words.length; ++ i) {--newline--            int l = 0, r = 0;--newline--            while (l <= r) {--newline--                String s = words[i].substring(l, r);--newline--                Integer j = map.get(new StringBuilder(s).reverse().toString());--newline--                if (j != null && i != j && isPalindrome(words[i].substring(l == 0 ? r : 0, l == 0 ? words[i].length() : l)))--newline--                    pairs.add(Arrays.asList(l == 0 ? new Integer[]{i, j} : new Integer[]{j, i}));--newline--                if (r < words[i].length()) ++r;--newline--                else ++l;--newline--            }--newline--        }--newline--        return pairs;--newline--    }--newline--    --newline--    private boolean isPalindrome(String s) {--newline--        for (int i = 0; i < s.length()/2; ++ i)--newline--            if (s.charAt(i) != s.charAt(s.length()-1-i))--newline--                return false;--newline--        return true;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Accepted short Java solution using HashMap"
        }
    ],
    "qc": "336.json"
}