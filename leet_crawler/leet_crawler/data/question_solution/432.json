{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class AllOne {--newline--public:--newline--    struct Row {--newline--        list<string> strs;--newline--        int val;--newline--        Row(const string &s, int x) : strs({s}), val(x) {}--newline--    };--newline----newline--    unordered_map<string, pair<list<Row>::iterator, list<string>::iterator>> strmap;--newline--    list<Row> matrix;--newline----newline--    /** Initialize your data structure here. */--newline--    AllOne() {--newline--        --newline--    }--newline--    --newline--    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */--newline--    void inc(string key) {--newline--        if (strmap.find(key) == strmap.end()) {--newline--            if (matrix.empty() || matrix.back().val != 1) {--newline--                auto newrow = matrix.emplace(matrix.end(), key, 1);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--            else {--newline--                auto newrow = --matrix.end();--newline--                newrow->strs.push_front(key);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--        }--newline--        else {--newline--            auto row = strmap[key].first;--newline--            auto col = strmap[key].second;--newline--            auto lastrow = row;--newline--            --lastrow;--newline--            if (lastrow == matrix.end() || lastrow->val != row->val + 1) {--newline--                auto newrow = matrix.emplace(row, key, row->val + 1);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--            else {--newline--                auto newrow = lastrow;--newline--                newrow->strs.push_front(key);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--            row->strs.erase(col);--newline--            if (row->strs.empty()) matrix.erase(row);--newline--        }--newline--    }--newline--    --newline--    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */--newline--    void dec(string key) {--newline--        if (strmap.find(key) == strmap.end()) {--newline--            return;--newline--        }--newline--        else {--newline--            auto row = strmap[key].first;--newline--            auto col = strmap[key].second;--newline--            if (row->val == 1) {--newline--                row->strs.erase(col);--newline--                if (row->strs.empty()) matrix.erase(row);--newline--                strmap.erase(key);--newline--                return;--newline--            }--newline--            auto nextrow = row;--newline--            ++nextrow;--newline--            if (nextrow == matrix.end() || nextrow->val != row->val - 1) {--newline--                auto newrow = matrix.emplace(nextrow, key, row->val - 1);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--            else {--newline--                auto newrow = nextrow;--newline--                newrow->strs.push_front(key);--newline--                strmap[key] = make_pair(newrow, newrow->strs.begin());--newline--            }--newline--            row->strs.erase(col);--newline--            if (row->strs.empty()) matrix.erase(row);--newline--        }--newline--    }--newline--    --newline--    /** Returns one of the keys with maximal value. */--newline--    string getMaxKey() {--newline--        return matrix.empty() ?  \"\" : matrix.front().strs.front();--newline--    }--newline--    --newline--    /** Returns one of the keys with Minimal value. */--newline--    string getMinKey() {--newline--        return matrix.empty() ?  \"\" : matrix.back().strs.front();--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "All in O(1), with detailed explantation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class AllOne {--newline--public:--newline----newline--    void inc(string key) {--newline--        --newline--        // If the key doesn't exist, insert it with value 0.--newline--        if (!bucketOfKey.count(key))--newline--            bucketOfKey[key] = buckets.insert(buckets.begin(), {0, {key}});--newline--            --newline--        // Insert the key in next bucket and update the lookup.--newline--        auto next = bucketOfKey[key], bucket = next++;--newline--        if (next == buckets.end() || next->value > bucket->value + 1)--newline--            next = buckets.insert(next, {bucket->value + 1, {}});--newline--        next->keys.insert(key);--newline--        bucketOfKey[key] = next;--newline--        --newline--        // Remove the key from its old bucket.--newline--        bucket->keys.erase(key);--newline--        if (bucket->keys.empty())--newline--            buckets.erase(bucket);--newline--    }--newline----newline--    void dec(string key) {--newline----newline--        // If the key doesn't exist, just leave.--newline--        if (!bucketOfKey.count(key))--newline--            return;--newline----newline--        // Maybe insert the key in previous bucket and update the lookup.--newline--        auto prev = bucketOfKey[key], bucket = prev--;--newline--        bucketOfKey.erase(key);--newline--        if (bucket->value > 1) {--newline--            if (bucket == buckets.begin() || prev->value < bucket->value - 1)--newline--                prev = buckets.insert(bucket, {bucket->value - 1, {}});--newline--            prev->keys.insert(key);--newline--            bucketOfKey[key] = prev;--newline--        }--newline--        --newline--        // Remove the key from its old bucket.--newline--        bucket->keys.erase(key);--newline--        if (bucket->keys.empty())--newline--            buckets.erase(bucket);--newline--    }--newline----newline--    string getMaxKey() {--newline--        return buckets.empty() ? \"\" : *(buckets.rbegin()->keys.begin());--newline--    }--newline--    --newline--    string getMinKey() {--newline--        return buckets.empty() ? \"\" : *(buckets.begin()->keys.begin());--newline--    }--newline----newline--private:--newline--    struct Bucket { int value; unordered_set<string> keys; };--newline--    list<Bucket> buckets;--newline--    unordered_map<string, list<Bucket>::iterator> bucketOfKey;--newline--};--newline--",
            "python": null,
            "topic_title": "C++ solution with comments"
        },
        {
            "java": "public class AllOne {--newline--    // maintain a doubly linked list of Buckets--newline--    private Bucket head;--newline--    private Bucket tail;--newline--    // for accessing a specific Bucket among the Bucket list in O(1) time--newline--    private Map<Integer, Bucket> countBucketMap;--newline--    // keep track of count of keys--newline--    private Map<String, Integer> keyCountMap;--newline----newline--    // each Bucket contains all the keys with the same count--newline--    private class Bucket {--newline--        int count;--newline--        Set<String> keySet;--newline--        Bucket next;--newline--        Bucket pre;--newline--        public Bucket(int cnt) {--newline--            count = cnt;--newline--            keySet = new HashSet<>();--newline--        }--newline--    }--newline----newline--    /** Initialize your data structure here. */--newline--    public AllOne() {--newline--        head = new Bucket(Integer.MIN_VALUE);--newline--        tail = new Bucket(Integer.MAX_VALUE);--newline--        head.next = tail;--newline--        tail.pre = head;--newline--        countBucketMap = new HashMap<>();--newline--        keyCountMap = new HashMap<>();--newline--    }--newline--    --newline--    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */--newline--    public void inc(String key) {--newline--        if (keyCountMap.containsKey(key)) {--newline--            changeKey(key, 1);--newline--        } else {--newline--            keyCountMap.put(key, 1);--newline--            if (head.next.count != 1) --newline--                addBucketAfter(new Bucket(1), head);--newline--            head.next.keySet.add(key);--newline--            countBucketMap.put(1, head.next);--newline--        }--newline--    }--newline--    --newline--    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */--newline--    public void dec(String key) {--newline--        if (keyCountMap.containsKey(key)) {--newline--            int count = keyCountMap.get(key);--newline--            if (count == 1) {--newline--                keyCountMap.remove(key);--newline--                removeKeyFromBucket(countBucketMap.get(count), key);--newline--            } else {--newline--                changeKey(key, -1);--newline--            }--newline--        }--newline--    }--newline--    --newline--    /** Returns one of the keys with maximal value. */--newline--    public String getMaxKey() {--newline--        return tail.pre == head ? \"\" : (String) tail.pre.keySet.iterator().next();--newline--    }--newline--    --newline--    /** Returns one of the keys with Minimal value. */--newline--    public String getMinKey() {--newline--        return head.next == tail ? \"\" : (String) head.next.keySet.iterator().next();        --newline--    }--newline--    --newline--    // helper function to make change on given key according to offset--newline--    private void changeKey(String key, int offset) {--newline--        int count = keyCountMap.get(key);--newline--        keyCountMap.put(key, count + offset);--newline--        Bucket curBucket = countBucketMap.get(count);--newline--        Bucket newBucket;--newline--        if (countBucketMap.containsKey(count + offset)) {--newline--            // target Bucket already exists--newline--            newBucket = countBucketMap.get(count + offset);--newline--        } else {--newline--            // add new Bucket--newline--            newBucket = new Bucket(count + offset);--newline--            countBucketMap.put(count + offset, newBucket);--newline--            addBucketAfter(newBucket, offset == 1 ? curBucket : curBucket.pre);--newline--        }--newline--        newBucket.keySet.add(key);--newline--        removeKeyFromBucket(curBucket, key);--newline--    }--newline--    --newline--    private void removeKeyFromBucket(Bucket bucket, String key) {--newline--        bucket.keySet.remove(key);--newline--        if (bucket.keySet.size() == 0) {--newline--            removeBucketFromList(bucket);--newline--            countBucketMap.remove(bucket.count);--newline--        }--newline--    }--newline--    --newline--    private void removeBucketFromList(Bucket bucket) {--newline--        bucket.pre.next = bucket.next;--newline--        bucket.next.pre = bucket.pre;--newline--        bucket.next = null;--newline--        bucket.pre = null;--newline--    }--newline--    --newline--    // add newBucket after preBucket--newline--    private void addBucketAfter(Bucket newBucket, Bucket preBucket) {--newline--        newBucket.pre = preBucket;--newline--        newBucket.next = preBucket.next;--newline--        preBucket.next.pre = newBucket;--newline--        preBucket.next = newBucket;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java AC all strict O(1) not average O(1), easy to read"
        },
        {
            "java": "public class AllOne {--newline--    class valueNode {--newline--        valueNode preNode;             --newline--        valueNode nextNode;           --newline--        int value;                     // curNode.value;--newline--        List<String> curKeys;         // store the key at the value of curNode.value;--newline--        --newline--        valueNode(int value,String key) {--newline--            this.value = value;--newline--            curKeys = new LinkedList<String>();--newline--            curKeys.add(key);--newline--        }--newline--    }--newline--    --newline--    private valueNode head;--newline--    private valueNode tail;--newline--    private valueNode curNode;--newline--    private HashMap<String, valueNode> keyMap;--newline--    --newline--    /** Initialize your data structure here. */--newline--    public AllOne() {--newline--        keyMap = new HashMap<String,valueNode>();--newline--        head = null;--newline--        tail = null;--newline--    }--newline--    --newline--    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */--newline--    public void inc(String key) {--newline--        if (tail == null) { // which means head must be null too and the keyMap must be empty.--newline--                curNode = new valueNode(1,key);--newline--                head = curNode;--newline--                tail = curNode;--newline--                keyMap.put(key,curNode);--newline--        } else if (!keyMap.containsKey(key)){ //which means that this key should be add to the tail.--newline--                if (tail.value == 1) {//which means just add the key to the tail list.--newline--                    tail.curKeys.add(key);--newline--                    keyMap.put(key,tail);--newline--                }else {    //which means have to add a value= 1 node.--newline--                    curNode = new valueNode(1,key);--newline--                    curNode.preNode = tail;--newline--                    tail.nextNode = curNode;--newline--                    tail = curNode;--newline--                    keyMap.put(key,curNode);--newline--                }--newline--        } else { //which the string already exists.--newline--            curNode = keyMap.get(key);--newline--            if (curNode.preNode != null) {  //which means the node is in the middle.--newline--                if (curNode.preNode.value == curNode.value + 1){--newline--                    curNode.preNode.curKeys.add(key);--newline--                    curNode.curKeys.remove(key); --newline--                    keyMap.put(key,curNode.preNode);--newline--                    checkEmpty(curNode);--newline--                }else {                     //which means the preNode value != curNode.value;--newline--                    valueNode newNode = new valueNode(curNode.value+1, key);--newline--                    newNode.preNode = curNode.preNode;--newline--                    newNode.nextNode= curNode;--newline--                    newNode.preNode.nextNode = newNode;--newline--                    curNode.preNode = newNode;--newline--                    curNode.curKeys.remove(key); --newline--                    keyMap.put(key,newNode);--newline--                    checkEmpty(curNode);--newline--                }--newline--            }else {//which means the node is the head. so we build a new head.--newline--                head = new valueNode(curNode.value+1,key);--newline--                head.nextNode = curNode;--newline--                curNode.preNode = head;--newline--                curNode.curKeys.remove(key);--newline--                keyMap.put(key,head);--newline--                checkEmpty(curNode);--newline--            }--newline--        }--newline--    }--newline--    --newline--    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */--newline--    public void dec(String key) {--newline--            if (head ==null ||!keyMap.containsKey(key)) return; //which means nothing here.--newline--                                                         //or  means no key in the structrue.--newline--            curNode = keyMap.get(key);--newline--            if (curNode.nextNode != null) {  //which means the node is in the middle.--newline--                if (curNode.nextNode.value == curNode.value - 1){ //which means we can just --newline--                    curNode.nextNode.curKeys.add(key);--newline--                    curNode.curKeys.remove(key); --newline--                    keyMap.put(key,curNode.nextNode);--newline--                    checkEmpty(curNode);--newline--                }else {                     //which means the nextNode value != curNode.value-1;--newline--                        valueNode newNode = new valueNode(curNode.value-1, key);--newline--                        newNode.nextNode = curNode.nextNode;--newline--                        newNode.preNode= curNode;--newline--                        newNode.nextNode.preNode = newNode;--newline--                        curNode.curKeys.remove(key); --newline--                        curNode.nextNode = newNode;--newline--                        keyMap.put(key,newNode);--newline--                        checkEmpty(curNode);--newline--                }--newline--            } else {    //which means the node is the tail. so we build a new head.--newline--                if (curNode.value == 1) {     //just to delete the key.--newline--                    curNode.curKeys.remove(key);  --newline--                    keyMap.remove(key);--newline--                    checkEmpty(curNode);--newline--                }else {                         // build another tail.--newline--                    tail = new valueNode(curNode.value-1,key);--newline--                    tail.preNode = curNode;--newline--                    curNode.nextNode = tail;--newline--                    curNode.curKeys.remove(key);  --newline--                    keyMap.put(key,tail);--newline--                    checkEmpty(curNode);--newline--                }--newline--            }--newline--    }--newline--    --newline--    /** Returns one of the keys with maximal value. */--newline--    public String getMaxKey() {--newline--         if (head == null) return \"\";//which means nothing here.--newline--         return head.curKeys.get(0);--newline--    }--newline--    --newline--    /** Returns one of the keys with Minimal value. */--newline--    public String getMinKey() {--newline--         if (tail == null) return \"\";//which means nothing here.--newline--         return tail.curKeys.get(0);--newline--        --newline--    }--newline--    // to check whether the node should be delete because the keyList is empty.--newline--    private void checkEmpty(valueNode checkNode) {--newline--            if (checkNode.curKeys.size() != 0) return;--newline--            if (checkNode.preNode == null && checkNode.nextNode == null){--newline--                tail = null;--newline--                head = null;--newline--            }else if (checkNode.preNode == null && checkNode.nextNode != null) {--newline--                head = checkNode.nextNode;--newline--                head.preNode = null;--newline--            }else if (checkNode.nextNode == null && checkNode.preNode != null){--newline--                tail = checkNode.preNode;--newline--                tail.nextNode = null;--newline--            }else {--newline--                checkNode.preNode.nextNode = checkNode.nextNode;--newline--                checkNode.nextNode.preNode  = checkNode.preNode; --newline--            } --newline--    }--newline--}--newline----newline--...",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "An accepted JAVA solution, detailed explanation.(HashMap + double linked list)"
        },
        {
            "java": "public class AllOne {--newline----newline--    class Node{--newline--        String key;--newline--        int val;--newline--        public Node(String key, int val) {--newline--            this.key = key;--newline--            this.val = val;--newline--        }--newline--    }--newline--    /** Initialize your data structure here. */--newline--    HashMap<String, Node> map;--newline--    PriorityQueue<Node> minQ;--newline--    PriorityQueue<Node> maxQ;--newline--    public AllOne() {--newline--        map = new HashMap<String, Node>();--newline--        minQ = new PriorityQueue<Node>(new Comparator<Node>(){--newline--            public int compare(Node a, Node b) {--newline--                return a.val - b.val;--newline--            }--newline--        });        --newline--        maxQ = new PriorityQueue<Node>(new Comparator<Node>(){--newline--            public int compare(Node a, Node b) {--newline--                return b.val - a.val;--newline--            }--newline--        });--newline--    }--newline--    --newline--    /** Inserts a new key <Key> with value 1. Or increments an existing key by 1. */--newline--    public void inc(String key) {--newline--        if (!map.containsKey(key)) {--newline--            map.put(key, new Node(key, 1));--newline--            Node node = map.get(key);--newline--            minQ.add(node);--newline--            maxQ.add(node);--newline--        } else {--newline--            Node node = map.get(key);--newline--            minQ.remove(node);--newline--            maxQ.remove(node);--newline--            node.val++;--newline--            map.put(key, node);--newline--            minQ.add(node);--newline--            maxQ.add(node);--newline--        }--newline--    }--newline--    --newline--    /** Decrements an existing key by 1. If Key's value is 1, remove it from the data structure. */--newline--    public void dec(String key) {--newline--        if (map.containsKey(key)) {--newline--            Node node = map.get(key);--newline--            if (node.val == 1) {--newline--                map.remove(key);--newline--                minQ.remove(node);--newline--                maxQ.remove(node);--newline--            } else {--newline--                minQ.remove(node);--newline--                maxQ.remove(node);--newline--                node.val--;--newline--                map.put(key, node);--newline--                minQ.add(node);--newline--                maxQ.add(node);--newline--            }--newline--        }--newline--    }--newline--    --newline--    /** Returns one of the keys with maximal value. */--newline--    public String getMaxKey() {--newline--        return maxQ.isEmpty() ? \"\" : maxQ.peek().key;--newline--    }--newline--    --newline--    /** Returns one of the keys with Minimal value. */--newline--    public String getMinKey() {--newline--        return minQ.isEmpty() ? \"\" : minQ.peek().key;--newline--    }--newline--}--newline----newline--/**--newline-- * Your AllOne object will be instantiated and called as such:--newline-- * AllOne obj = new AllOne();--newline-- * obj.inc(key);--newline-- * obj.dec(key);--newline-- * String param_3 = obj.getMaxKey();--newline-- * String param_4 = obj.getMinKey();--newline-- */--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "AC Java Solution using hashMap and two heaps"
        }
    ],
    "qc": "432.json"
}