{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<String> findItinerary(String[][] tickets) {--newline--        Map<String, PriorityQueue<String>> targets = new HashMap<>();--newline--        for (String[] ticket : tickets)--newline--            targets.computeIfAbsent(ticket[0], k -> new PriorityQueue()).add(ticket[1]);--newline--        List<String> route = new LinkedList();--newline--        Stack<String> stack = new Stack<>();--newline--        stack.push(\"JFK\");--newline--        while (!stack.empty()) {--newline--            while (targets.containsKey(stack.peek()) && !targets.get(stack.peek()).isEmpty())--newline--                stack.push(targets.get(stack.peek()).poll());--newline--            route.add(0, stack.pop());--newline--        }--newline--        return route;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<string> findItinerary(vector<pair<string, string>> tickets) {--newline--        for (auto ticket : tickets)--newline--            targets[ticket.first].insert(ticket.second);--newline--        visit(\"JFK\");--newline--        return vector<string>(route.rbegin(), route.rend());--newline--    }--newline--    --newline--    map<string, multiset<string>> targets;--newline--    vector<string> route;--newline--    --newline--    void visit(string airport) {--newline--        while (targets[airport].size()) {--newline--            string next = *targets[airport].begin();--newline--            targets[airport].erase(targets[airport].begin());--newline--            visit(next);--newline--        }--newline--        route.push_back(airport);--newline--    }--newline--    --newline--}",
            "python": "class Solution :--newline----tab--    def findItinerary(self, tickets):--newline----tab--        targets = collections.defaultdict(list)--newline----tab--        for a, b in sorted(tickets)[::-1]:--newline----tab--            targets[a] += b,--newline----tab--        route, stack = [], ['JFK']--newline----tab--        while stack:--newline----tab--            while targets[stack[-1]]:--newline----tab--                stack += targets[stack[-1]].pop(),--newline----tab--            route += stack.pop(),--newline----tab--        return route[::-1]--newline----tab--    ",
            "topic_title": "Short Ruby &#x2F; Python &#x2F; Java &#x2F; C++"
        },
        {
            "java": "public class Solution {--newline----newline--    Map<String, PriorityQueue<String>> flights;--newline--    LinkedList<String> path;--newline----newline--    public List<String> findItinerary(String[][] tickets) {--newline--        flights = new HashMap<>();--newline--        path = new LinkedList<>();--newline--        for (String[] ticket : tickets) {--newline--            flights.putIfAbsent(ticket[0], new PriorityQueue<>());--newline--            flights.get(ticket[0]).add(ticket[1]);--newline--        }--newline--        dfs(\"JFK\");--newline--        return path;--newline--    }--newline----newline--    public void dfs(String departure) {--newline--        PriorityQueue<String> arrivals = flights.get(departure);--newline--        while (arrivals != null && !arrivals.isEmpty())--newline--            dfs(arrivals.poll());--newline--        path.addFirst(departure);--newline--    }--newline--}--newline----newline--79 / 79 test cases passed.--newline--Status: Accepted--newline--Runtime: 11 ms",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline----tab--vector<string> findItinerary(vector<pair<string, string>> tickets) {--newline----tab----tab--// Each node (airport) contains a set of outgoing edges (destination).--newline----tab----tab--unordered_map<string, multiset<string>> graph;--newline----tab----tab--// We are always appending the deepest node to the itinerary, --newline----tab----tab--// so will need to reverse the itinerary in the end.--newline----tab----tab--vector<string> itinerary;--newline----tab----tab--if (tickets.size() == 0){--newline----tab----tab----tab--return itinerary;--newline----tab----tab--}--newline----tab----tab--// Construct the node and assign outgoing edges--newline----tab----tab--for (pair<string, string> eachTicket : tickets){--newline----tab----tab----tab--graph[eachTicket.first].insert(eachTicket.second);--newline----tab----tab--}--newline----tab----tab--stack<string> dfs;--newline----tab----tab--dfs.push(\"JFK\");--newline----tab----tab--while (!dfs.empty()){--newline----tab----tab----tab--string topAirport = dfs.top();--newline----tab----tab----tab--if (graph[topAirport].empty()){--newline----tab----tab----tab----tab--// If there is no more outgoing edges, append to itinerary--newline----tab----tab----tab----tab--// Two cases: --newline----tab----tab----tab----tab--// 1. If it searchs the terminal end first, it will simply get--newline----tab----tab----tab----tab--//    added to the itinerary first as it should, and the proper route--newline----tab----tab----tab----tab--//    will still be traversed since its entry is still on the stack.--newline----tab----tab----tab----tab--// 2. If it search the proper route first, the dead end route will also--newline----tab----tab----tab----tab--//    get added to the itinerary first.--newline----tab----tab----tab----tab--itinerary.push_back(topAirport);--newline----tab----tab----tab----tab--dfs.pop();--newline----tab----tab----tab--}--newline----tab----tab----tab--else {--newline----tab----tab----tab----tab--// Otherwise push the outgoing edge to the dfs stack and --newline----tab----tab----tab----tab--// remove it from the node.--newline----tab----tab----tab----tab--dfs.push(*(graph[topAirport].begin()));--newline----tab----tab----tab----tab--graph[topAirport].erase(graph[topAirport].begin());--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--// Reverse the itinerary.--newline----tab----tab--reverse(itinerary.begin(), itinerary.end());--newline----tab----tab--return itinerary;--newline----tab--}--newline--};",
            "python": null,
            "topic_title": "Short C++ DFS iterative 44ms solution with explanation.  No recursive calls, no backtracking."
        },
        {
            "java": "public class Solution {--newline--        public List<String> findItinerary(String[][] tickets) {--newline--            List<String> ans = new ArrayList<String>();--newline--            if(tickets == null || tickets.length == 0) return ans;--newline--            Map<String, PriorityQueue<String>> ticketsMap = new HashMap<>();--newline--            for(int i = 0; i < tickets.length; i++) {--newline--                if(!ticketsMap.containsKey(tickets[i][0])) ticketsMap.put(tickets[i][0], new PriorityQueue<String>());--newline--                ticketsMap.get(tickets[i][0]).add(tickets[i][1]);--newline--            }--newline--    --newline--            String curr = \"JFK\";--newline--            Stack<String> drawBack = new Stack<String>();--newline--            for(int i = 0; i < tickets.length; i++) {--newline--                while(!ticketsMap.containsKey(curr) || ticketsMap.get(curr).isEmpty()) {--newline--                    drawBack.push(curr);--newline--                    curr = ans.remove(ans.size()-1);--newline--                }--newline--                ans.add(curr);--newline--                curr = ticketsMap.get(curr).poll();--newline--            }--newline--            ans.add(curr);--newline--            while(!drawBack.isEmpty()) ans.add(drawBack.pop());--newline--            return ans;--newline--        }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "&#91;Share Solution&#93; Java, Greedy, Stack, 15ms with explanation"
        },
        {
            "java": "public class Solution {--newline--    public List<String> findItinerary(String[][] tickets) {--newline--        ArrayList<String> result = new ArrayList<String>();--newline--        --newline--        if(tickets == null || tickets.length == 0){--newline--            return result;--newline--        }--newline--        --newline--        int total = tickets.length + 1;--newline--        --newline--        HashMap<String, ArrayList<String>> map = new HashMap<String, ArrayList<String>>();--newline--        --newline--        for(int i = 0; i < tickets.length; i++){--newline--            if(map.containsKey(tickets[i][0])){--newline--                ArrayList<String> tmp = map.get(tickets[i][0]);--newline--                listAdd(tickets[i][1], tmp);--newline--            }--newline--            else{--newline--                ArrayList<String> tmp = new ArrayList<String>();--newline--                tmp.add(tickets[i][1]);--newline--                map.put(tickets[i][0], tmp);--newline--            }--newline--        }--newline--        --newline--        result.add(\"JFK\");--newline--        --newline--        itineraryHelper(\"JFK\", map, result, total, 1);--newline--        --newline--        return result;--newline--    }--newline--    --newline--    public boolean itineraryHelper(String current, HashMap<String, ArrayList<String>> map, ArrayList<String> result, int total, int num){--newline--        --newline--        if(num >= total){--newline--            return true;--newline--        }--newline--        --newline--        if(!map.containsKey(current) || map.get(current).size() == 0){--newline--            return false;--newline--        }--newline--        --newline--        ArrayList<String> curList = map.get(current);--newline--        int i = 0;--newline--        --newline--        while(i < curList.size()){--newline--            String next = curList.remove(i);--newline--            result.add(next);--newline--            --newline--            if(itineraryHelper(next, map, result, total, num + 1)){--newline--                return true;--newline--            }--newline--            --newline--            result.remove(result.size() - 1);--newline--            listAdd(next, curList);--newline--            i++;--newline--        }--newline--        --newline--        return false;--newline--    }--newline--    --newline--    --newline--    public void listAdd(String value, ArrayList<String> list){--newline--        if(list.size() == 0){--newline--            list.add(value);--newline--            return;--newline--        }--newline--        else{--newline--            int i = 0;--newline--            while(i < list.size()){--newline--                if(value.compareTo(list.get(i)) <= 0){--newline--                    list.add(i, value);--newline--                    return;--newline--                }--newline--                i++;--newline--            }--newline--            list.add(value);--newline--            return;--newline--        }--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java 11ms solution(HashMap &amp; sorted List)"
        }
    ],
    "qc": "332.json"
}