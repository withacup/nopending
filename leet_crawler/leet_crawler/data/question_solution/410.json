{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int splitArray(int[] nums, int m) {--newline--        int max = 0; long sum = 0;--newline--        for (int num : nums) {--newline--            max = Math.max(num, max);--newline--            sum += num;--newline--        }--newline--        if (m == 1) return (int)sum;--newline--        //binary search--newline--        long l = max; long r = sum;--newline--        while (l <= r) {--newline--            long mid = (l + r)/ 2;--newline--            if (valid(mid, nums, m)) {--newline--                r = mid - 1;--newline--            } else {--newline--                l = mid + 1;--newline--            }--newline--        }--newline--        return (int)l;--newline--    }--newline--    public boolean valid(long target, int[] nums, int m) {--newline--        int count = 1;--newline--        long total = 0;--newline--        for(int num : nums) {--newline--            total += num;--newline--            if (total > target) {--newline--                total = num;--newline--                count++;--newline--                if (count > m) {--newline--                    return false;--newline--                }--newline--            }--newline--        }--newline--        return true;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Clear Explanation: 8ms Binary Search Java"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--private:--newline--    /* --newline--        Params:--newline--            nums - The input array; --newline--            cuts - How many cuts are available (cuts = #groups - 1); --newline--            max - The maximum of the (sum of elements in one group);--newline--        Rtn:--newline--            Whether we can use at most 'cuts' number of cuts to segment the entire array, --newline--            such that the sum of each group will not exceed 'max'.--newline--     */--newline--    bool doable (const vector<int>& nums, int cuts, long long max) {--newline--        --newline--        // 'acc' is the temporary accumulator for the currently processed group.--newline--        --newline--        int acc = 0;--newline--        for (num : nums) {--newline--            --newline--            // If the current processed element in this array is larger than 'max', we cannot segment the array.--newline--            // (Reason is straightforward, if 'nums' is [10, 2, 3, 5] and 'max' is 6, even you can have 3 cuts--newline--            // (by which you can cut array as [[10], [2], [3], [5]]), the group containing 10 will be larger than 6, --newline--            //  there is no way to do this).--newline--            // Ps: This step is unnecessary in this solution. Because 'left' in the splitArray() function can assure --newline--            // 'max' will be larger than every single element. I just want to write a generalized doable() function :)--newline--            --newline--            if (num > max) return false;--newline--            --newline--            // If the (sum of the currently processed group) + (current element) is smaller than max, we can add current --newline--            // element into this group.--newline--            --newline--            else if (acc + num <= max) acc += num;--newline--            --newline--            // If not, we will make a cut before this element, and this element will be the first element in the new group.--newline--            --newline--            else {--newline--                --cuts;--newline--                acc = num;--newline--                --newline--                // If we've used up all cuts, this means this 'max' is not doable.--newline--                if (cuts < 0) return false;--newline--            }--newline--        }--newline--        --newline--        // If we can reach here, this means we've used at most 'cuts' cut to segment the array, and the sum of each groups is--newline--        // not larger than 'max'. Yeah!--newline--        return true;--newline--    }--newline--    --newline--public:--newline--    int splitArray(vector<int>& nums, int m) {--newline--        // Use long long to avoid overflow.--newline--        long long left = 0, right = 0;--newline--        // The smallest possible value ('left') is the the value of the largest element in this array.--newline--        // The largest possible value ('right') is the sum of all elements in this array.--newline--        for (num : nums) {--newline--            left = max(left, (long long)num);--newline--            right += num;--newline--        }--newline--        --newline--        // Use binary search, find the lower bound of the possible (minimum sum of groups within m - 1 cuts).--newline--        while (left < right) {--newline--            long long mid = left + (right - left) / 2;--newline--            if (doable(nums, m - 1, mid)) right = mid;--newline--            else left = mid + 1;--newline--        }--newline--        return left;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "&#91;C++ &#x2F; Fast &#x2F; Very clear explanation &#x2F; Clean Code&#93; Solution with Greedy Algorithm and Binary Search"
        },
        {
            "java": "public class Solution {--newline--    public int splitArray(int[] nums, int m) {--newline--        long sum = 0;--newline--        int max = 0;--newline--        for(int num: nums){--newline--            max = Math.max(max, num);--newline--            sum += num;--newline--        }--newline--        return (int)binary(nums, m, sum, max);--newline--    }--newline--    --newline--    private long binary(int[] nums, int m, long high, long low){--newline--        long mid = 0;--newline--        while(low < high){--newline--            mid = (high + low)/2;--newline--            if(valid(nums, m, mid)){--newline--                //System.out.println(mid);--newline--                high = mid;--newline--            }else{--newline--                low = mid + 1;--newline--            }--newline--        }--newline--        return high;--newline--    }--newline--    --newline--    private boolean valid(int[] nums, int m, long max){--newline--        int cur = 0;--newline--        int count = 1;--newline--        for(int num: nums){--newline--            cur += num;--newline--            if(cur > max){--newline--                cur = num;--newline--                count++;--newline--                if(count > m){--newline--                    return false;--newline--                }--newline--            }--newline--        }--newline--        return true;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java easy binary search solution 8ms"
        },
        {
            "java": "public class Solution {--newline--    public int splitArray(int[] nums, int m)--newline--    {--newline--        int L = nums.length;--newline--        int[] S = new int[L+1];--newline--        S[0]=0;--newline--        for(int i=0; i<L; i++)--newline--            S[i+1] = S[i]+nums[i];--newline--    --newline--        int[] dp = new int[L];--newline--        for(int i=0; i<L; i++)--newline--            dp[i] = S[L]-S[i];--newline--    --newline--        for(int s=1; s<m; s++)--newline--        {--newline--            for(int i=0; i<L-s; i++)--newline--            {--newline--                dp[i]=Integer.MAX_VALUE;--newline--                for(int j=i+1; j<=L-s; j++)--newline--                {--newline--                    int t = Math.max(dp[j], S[j]-S[i]);--newline--                    if(t<=dp[i])--newline--                        dp[i]=t;--newline--                    else--newline--                        break;--newline--                }--newline--            }--newline--        }--newline--    --newline--        return dp[0];--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "DP Java"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    using ll = long long;--newline----newline--    bool canSplit(vector<int>& nums, int m, ll sum) {--newline--        int c = 1;--newline--        ll s = 0;--newline--        for (auto& num : nums) {--newline--            s += num;--newline--            if (s > sum) {--newline--                s = num;--newline--                ++c;--newline--            }--newline--        }--newline--        return c <= m;--newline--    }--newline----newline--    int splitArray(vector<int>& nums, int m) {--newline--        ll left = 0, right = 0;--newline--        for (auto& num : nums) {--newline--            left = max(left, (ll)num);--newline--            right += num;--newline--        }--newline--        while (left <= right) {--newline--            ll mid = left + (right-left)/2;--newline--            if (canSplit(nums, m, mid))--newline--                right = mid-1;--newline--            else--newline--                left = mid+1;--newline--        }--newline--        return left;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Binary Search C++ Solution"
        }
    ],
    "qc": "410.json"
}