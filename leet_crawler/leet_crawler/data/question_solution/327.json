{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int countRangeSum(int[] nums, int lower, int upper) {--newline--        int n = nums.length;--newline--        long[] sums = new long[n + 1];--newline--        for (int i = 0; i < n; ++i)--newline--            sums[i + 1] = sums[i] + nums[i];--newline--        return countWhileMergeSort(sums, 0, n + 1, lower, upper);--newline--    }--newline--    --newline--    private int countWhileMergeSort(long[] sums, int start, int end, int lower, int upper) {--newline--        if (end - start <= 1) return 0;--newline--        int mid = (start + end) / 2;--newline--        int count = countWhileMergeSort(sums, start, mid, lower, upper) --newline--                  + countWhileMergeSort(sums, mid, end, lower, upper);--newline--        int j = mid, k = mid, t = mid;--newline--        long[] cache = new long[end - start];--newline--        for (int i = start, r = 0; i < mid; ++i, ++r) {--newline--            while (k < end && sums[k] - sums[i] < lower) k++;--newline--            while (j < end && sums[j] - sums[i] <= upper) j++;--newline--            while (t < end && sums[t] < sums[i]) cache[r++] = sums[t++];--newline--            cache[r] = sums[i];--newline--            count += j - k;--newline--        }--newline--        System.arraycopy(cache, 0, sums, start, t - start);--newline--        return count;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my solution"
        },
        {
            "java": "public class Solution {--newline--    public int countRangeSum(int[] nums, int lower, int upper) {--newline--        if (nums == null || nums.length == 0 || lower > upper) return 0;--newline--        return countRangeSumSub(nums, 0, nums.length - 1, lower, upper);--newline--    }--newline--    --newline--    private int countRangeSumSub(int[] nums, int l, int r, int lower, int upper) {--newline--        if (l == r) return nums[l] >= lower && nums[r] <= upper ? 1 : 0;  // base case--newline--    --tab----newline--        int m = l + (r - l) / 2;--newline--        long[] arr = new long[r - m];  // prefix array for the second subarray--newline--        long sum = 0;--newline--        int count = 0;--newline--    --tab----newline--        for (int i = m + 1; i <= r; i++) {--newline--    --tab--sum += nums[i];--newline--    --tab--arr[i - (m + 1)] = sum;--tab--// compute the prefix array--newline--        }--newline--    --tab----newline--        Arrays.sort(arr);  // sort the prefix array--newline--    --tab----newline--        // Here we can compute the suffix array element by element.--newline--        // For each element in the suffix array, we compute the corresponding--newline--        // \"insertion\" indices of the modified bounds in the sorted prefix array--newline--        // then the number of valid ranges sums will be given by the indices difference.--newline--        // I modified the bounds to be \"double\" to avoid duplicate elements.--newline--        sum = 0;--newline--        for (int i = m; i >= l; i--) {--newline--    --tab--sum += nums[i];  --newline--    --tab--count += findIndex(arr, upper - sum + 0.5) - findIndex(arr, lower - sum - 0.5);--newline--         }--newline--    --tab----newline--        return countRangeSumSub(nums, l, m, lower, upper) + countRangeSumSub(nums, m + 1, r, lower, upper) + count;--newline--    }--newline--    --newline--    // binary search function--newline--    private int findIndex(long[] arr, double val) {--newline--        int l = 0, r = arr.length - 1, m = 0;--newline--    --tab----newline--        while (l <= r) {--newline--    --tab--m = l + (r - l) / 2;--newline--    --tab----tab----newline--    --tab--if (arr[m] <= val) {--newline--    --tab--    l = m + 1;--newline--    --tab--} else {--newline--    --tab--    r = m - 1;--newline--            }--newline--        }--newline--    --tab----newline--        return l;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Summary of the Divide and Conquer based and Binary Indexed Tree based solutions"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def countRangeSum(self, nums, lower, upper):--newline----tab--        first = [0]--newline----tab--        for num in nums:--newline----tab--            first.append(first[-1] + num)--newline----tab--        def sort(lo, hi):--newline----tab--            mid = (lo + hi) / 2--newline----tab--            if mid == lo:--newline----tab--                return 0--newline----tab--            count = sort(lo, mid) + sort(mid, hi)--newline----tab--            i = j = mid--newline----tab--            for left in first[lo:mid]:--newline----tab--                while i < hi and first[i] - left <  lower: i += 1--newline----tab--                while j < hi and first[j] - left <= upper: j += 1--newline----tab--                count += j - i--newline----tab--            first[lo:hi] = sorted(first[lo:hi])--newline----tab--            return count--newline----tab--        return sort(0, len(first))--newline----tab--    ",
            "topic_title": "Short &amp; simple O(n log n)"
        },
        {
            "java": "public class Solution {--newline--    class SegmentTreeNode {--newline--        SegmentTreeNode left;--newline--        SegmentTreeNode right;--newline--        int count;--newline--        long min;--newline--        long max;--newline--        public SegmentTreeNode(long min, long max) {--newline--            this.min = min;--newline--            this.max = max;--newline--        }--newline--    }--newline--    private SegmentTreeNode buildSegmentTree(Long[] valArr, int low, int high) {--newline--        if(low > high) return null;--newline--        SegmentTreeNode stn = new SegmentTreeNode(valArr[low], valArr[high]);--newline--        if(low == high) return stn;--newline--        int mid = (low + high)/2;--newline--        stn.left = buildSegmentTree(valArr, low, mid);--newline--        stn.right = buildSegmentTree(valArr, mid+1, high);--newline--        return stn;--newline--    }--newline--    private void updateSegmentTree(SegmentTreeNode stn, Long val) {--newline--        if(stn == null) return;--newline--        if(val >= stn.min && val <= stn.max) {--newline--            stn.count++;--newline--            updateSegmentTree(stn.left, val);--newline--            updateSegmentTree(stn.right, val);--newline--        }--newline--    }--newline--    private int getCount(SegmentTreeNode stn, long min, long max) {--newline--        if(stn == null) return 0;--newline--        if(min > stn.max || max < stn.min) return 0;--newline--        if(min <= stn.min && max >= stn.max) return stn.count;--newline--        return getCount(stn.left, min, max) + getCount(stn.right, min, max);--newline--    }--newline----newline--    public int countRangeSum(int[] nums, int lower, int upper) {--newline----newline--        if(nums == null || nums.length == 0) return 0;--newline--        int ans = 0;--newline--        Set<Long> valSet = new HashSet<Long>();--newline--        long sum = 0;--newline--        for(int i = 0; i < nums.length; i++) {--newline--            sum += (long) nums[i];--newline--            valSet.add(sum);--newline--        }--newline----newline--        Long[] valArr = valSet.toArray(new Long[0]);--newline----newline--        Arrays.sort(valArr);--newline--        SegmentTreeNode root = buildSegmentTree(valArr, 0, valArr.length-1);--newline----newline--        for(int i = nums.length-1; i >=0; i--) {--newline--            updateSegmentTree(root, sum);--newline--            sum -= (long) nums[i];--newline--            ans += getCount(root, (long)lower+sum, (long)upper+sum);--newline--        }--newline--        return ans;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java SegmentTree Solution, 36ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--private:    --newline--    int mergeSort(vector<long long>&sum, int left, int right, int lower, int upper)--newline--    {--newline--        int mid, i, res, j, k;--newline--        if(left>right) return 0;--newline--        if(left==right) return ( (sum[left]>=lower) && (sum[left]<=upper) )?1:0;--newline--        else--newline--        {--newline--            vector<long long> temp(right-left+1,0);--newline--            mid = (left+right)/2;--newline--            res = mergeSort(sum, left,mid, lower, upper) + mergeSort(sum, mid+1,right, lower, upper); // merge sort two halfs first, be careful about how to divide [left, mid] and [mid+1, right]--newline--            for(i=left, j=k=mid+1; i<=mid; ++i)--newline--            { // count the valid ranges [i,j], where i is in the first half and j is in the second half--newline--                while(j<=right && sum[j]-sum[i]<lower)  ++j;--newline--                while(k<=right && sum[k]-sum[i]<=upper) ++k;--newline--                res +=k-j;--newline--            }--newline--            for(i=k=left, j=mid+1; k<=right; ++k) //merge the sorted two halfs--newline--                temp[k-left] = (i<=mid) && (j>right || sum[i]<sum[j])?sum[i++]:sum[j++]; --newline--            for(k=left; k<=right; ++k) // copy the sorted results back to sum--newline--                sum[k] = temp[k-left]; --newline--            return res;--newline--        }--newline--    }--newline--public:--newline--    int countRangeSum(vector<int>& nums, int lower, int upper) {--newline--         int len = nums.size(), i;--newline--         vector<long long> sum(len+1, 0);--newline--         for(i=1; i<=len; ++i) sum[i] = sum[i-1]+nums[i-1];--newline--         return mergeSort(sum, 1, len, lower, upper);--newline--    }--newline--};",
            "python": null,
            "topic_title": "8-line multiset  C++ solution (100ms), also binary search tree (180ms) + mergesort(52ms)"
        }
    ],
    "qc": "327.json"
}