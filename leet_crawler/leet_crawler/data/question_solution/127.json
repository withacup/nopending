{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int ladderLength(string beginWord, string endWord, unordered_set<string>& wordDict) {--newline--        unordered_set<string> head, tail, *phead, *ptail;--newline--        head.insert(beginWord);--newline--        tail.insert(endWord);--newline--        int dist = 2;--newline--        while (!head.empty() && !tail.empty()) {--newline--            if (head.size() < tail.size()) {--newline--                phead = &head;--newline--                ptail = &tail;--newline--            }--newline--            else {--newline--                phead = &tail; --newline--                ptail = &head;--newline--            }--newline--            unordered_set<string> temp; --newline--            for (auto itr = phead -> begin(); itr != phead -> end(); itr++) {--newline--                string word = *itr;--newline--                wordDict.erase(word);--newline--                for (int p = 0; p < (int)word.length(); p++) {--newline--                    char letter = word[p];--newline--                    for (int k = 0; k < 26; k++) {--newline--                        word[p] = 'a' + k;--newline--                        if (ptail -> find(word) != ptail -> end())--newline--                            return dist;--newline--                        if (wordDict.find(word) != wordDict.end()) {--newline--                            temp.insert(word);--newline--                            wordDict.erase(word);--newline--                        }--newline--                    }--newline--                    word[p] = letter;--newline--                }--newline--            }--newline--            dist++;--newline--            swap(*phead, temp);--newline--        }--newline--        return 0; --newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Easy 76ms C++ Solution using BFS"
        },
        {
            "java": "public class Solution {--newline----newline--public int ladderLength(String beginWord, String endWord, Set<String> wordList) {--newline----tab--Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();--newline----newline----tab--int len = 1;--newline----tab--int strLen = beginWord.length();--newline----tab--HashSet<String> visited = new HashSet<String>();--newline----tab----newline----tab--beginSet.add(beginWord);--newline----tab--endSet.add(endWord);--newline----tab--while (!beginSet.isEmpty() && !endSet.isEmpty()) {--newline----tab----tab--if (beginSet.size() > endSet.size()) {--newline----tab----tab----tab--Set<String> set = beginSet;--newline----tab----tab----tab--beginSet = endSet;--newline----tab----tab----tab--endSet = set;--newline----tab----tab--}--newline----newline----tab----tab--Set<String> temp = new HashSet<String>();--newline----tab----tab--for (String word : beginSet) {--newline----tab----tab----tab--char[] chs = word.toCharArray();--newline----newline----tab----tab----tab--for (int i = 0; i < chs.length; i++) {--newline----tab----tab----tab----tab--for (char c = 'a'; c <= 'z'; c++) {--newline----tab----tab----tab----tab----tab--char old = chs[i];--newline----tab----tab----tab----tab----tab--chs[i] = c;--newline----tab----tab----tab----tab----tab--String target = String.valueOf(chs);--newline----newline----tab----tab----tab----tab----tab--if (endSet.contains(target)) {--newline----tab----tab----tab----tab----tab----tab--return len + 1;--newline----tab----tab----tab----tab----tab--}--newline----newline----tab----tab----tab----tab----tab--if (!visited.contains(target) && wordList.contains(target)) {--newline----tab----tab----tab----tab----tab----tab--temp.add(target);--newline----tab----tab----tab----tab----tab----tab--visited.add(target);--newline----tab----tab----tab----tab----tab--}--newline----tab----tab----tab----tab----tab--chs[i] = old;--newline----tab----tab----tab----tab--}--newline----tab----tab----tab--}--newline----tab----tab--}--newline----newline----tab----tab--beginSet = temp;--newline----tab----tab--len++;--newline----tab--}--newline----tab----newline----tab--return 0;--newline--}--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Two-end BFS in Java 31ms."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    //BFS\uff0c two-end method--newline--    //traverse the path simultaneously from start node and end node, and merge in the middle--newline--    //the speed will increase (logN/2)^2 times compared with one-end method--newline--    int ladderLength(string start, string end, unordered_set<string> &dict) {--newline--        unordered_set<string> begSet, endSet, *set1, *set2;--newline--        begSet.insert(start);--newline--        endSet.insert(end);--newline--        int h=1, K=start.size();--newline--        while(!begSet.empty()&&!endSet.empty()){--newline--            if(begSet.size()<=endSet.size()){   //Make the size of two sets close for optimization--newline--                set1=&begSet;--tab--//set1 is the forward set--newline--                set2=&endSet;--tab--//set2 provides the target node for set1 to search--newline--            }--newline--            else{--newline--                set1=&endSet;--newline--                set2=&begSet;--newline--            }--newline--            unordered_set<string> itmSet;--tab--//intermediate Set--newline--            h++;--newline--            for(auto i=set1->begin();i!=set1->end();i++){--newline--            --tab--string cur=*i;--newline--            --tab--for(int k=0;k<K;k++){--tab--//iterate the characters in string cur--newline--            --tab----tab--char temp=cur[k];--newline--            --tab----tab--for(int l=0;l<26;l++){--tab--//try all 26 alphabets--newline--            --tab----tab----tab--cur[k]='a'+l;--newline--            --tab----tab----tab--auto f=set2->find(cur);--newline--            --tab----tab----tab--if(f!=set2->end())return h;--newline--            --tab----tab----tab--f=dict.find(cur);--newline--            --tab----tab----tab--if(f!=dict.end()){--newline--            --tab----tab----tab----tab--itmSet.insert(cur);--newline--            --tab----tab----tab----tab--dict.erase(f);--newline--            --tab----tab----tab--}--newline--            --tab----tab--}--newline--            --tab----tab--cur[k]=temp;--newline--            --tab--}--newline--            }--newline--            swap(*set1, itmSet);--newline--        }--newline--        return 0;--newline--    }--newline--}",
            "python": null,
            "topic_title": "Share my two-end BFS in C++ 80ms."
        },
        {
            "java": "public class Solution {--newline--        public int ladderLength(String beginWord, String endWord, List<String> wordList) {Set<String> wordDict = new HashSet<String>(wordList);--newline--            Set<String> reached = new HashSet<String>();--newline--            reached.add(beginWord);--newline--            wordDict.add(endWord);--newline--            int distance = 1;--newline--            while (!reached.contains(endWord)) {--newline--                Set<String> toAdd = new HashSet<String>();--newline--                for (String each : reached) {--newline--                    for (int i = 0; i < each.length(); i++) {--newline--                        char[] chars = each.toCharArray();--newline--                        for (char ch = 'a'; ch <= 'z'; ch++) {--newline--                            chars[i] = ch;--newline--                            String word = new String(chars);--newline--                            if (wordDict.contains(word)) {--newline--                                toAdd.add(word);--newline--                                wordDict.remove(word);--newline--                            }--newline--                        }--newline--                    }--newline--                }--newline--                distance++;--newline--                if (toAdd.size() == 0) return 0;--newline--                reached = toAdd;--newline--            }--newline--            return distance;--newline--        }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Solution using Dijkstra&#x27;s algorithm, with explanation"
        },
        {
            "java": "public class Solution {--newline--    public int ladderLength(String start, String end, Set<String> dict) {--newline--      // Use queue to help BFS--newline--      Queue<String> queue = new LinkedList<String>();--newline--      queue.add(start);--newline--      queue.add(null);--newline--      --newline--      // Mark visited word--newline--      Set<String> visited = new HashSet<String>();--newline--      visited.add(start);--newline--      --newline--      int level = 1;--newline--      --newline--      while (!queue.isEmpty()) {--newline--        String str = queue.poll();--newline--        --newline--        if (str != null) {--newline--          // Modify str's each character (so word distance is 1)--newline--          for (int i = 0; i < str.length(); i++) {--newline--            char[] chars = str.toCharArray();--newline--            --newline--            for (char c = 'a'; c <= 'z'; c++) {--newline--              chars[i] = c;--newline--              --newline--              String word = new String(chars);--newline--              --newline--              // Found the end word--newline--              if (word.equals(end)) return level + 1;--newline--              --newline--              // Put it to the queue--newline--              if (dict.contains(word) && !visited.contains(word)) {--newline--                queue.add(word);--newline--                visited.add(word);--newline--              }--newline--            }--newline--          }--newline--        } else {--newline--          level++;--newline--          --newline--          if (!queue.isEmpty()) { --newline--            queue.add(null);--newline--          }--newline--        }--newline--      }--newline--      --newline--      return 0;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Another accepted Java solution (BFS)"
        }
    ],
    "qc": "127.json"
}