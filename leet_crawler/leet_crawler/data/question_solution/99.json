{
    "posts": [
        {
            "java": "public class Solution {--newline--    --newline--    TreeNode firstElement = null;--newline--    TreeNode secondElement = null;--newline--    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized--newline--    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);--newline--    --newline--    public void recoverTree(TreeNode root) {--newline--        --newline--        // In order traversal to find the two elements--newline--        traverse(root);--newline--        --newline--        // Swap the values of the two nodes--newline--        int temp = firstElement.val;--newline--        firstElement.val = secondElement.val;--newline--        secondElement.val = temp;--newline--    }--newline--    --newline--    private void traverse(TreeNode root) {--newline--        --newline--        if (root == null)--newline--            return;--newline--            --newline--        traverse(root.left);--newline--        --newline--        // Start of \"do some business\", --newline--        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)--newline--        if (firstElement == null && prevElement.val >= root.val) {--newline--            firstElement = prevElement;--newline--        }--newline--    --newline--        // If first element is found, assign the second element to the root (refer to 2 in the example above)--newline--        if (firstElement != null && prevElement.val >= root.val) {--newline--            secondElement = root;--newline--        }        --newline--        prevElement = root;--newline----newline--        // End of \"do some business\"--newline----newline--        traverse(root.right);--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "No Fancy Algorithm, just Simple and Powerful In-Order Traversal"
        },
        {
            "java": "public class Solution {--newline--    public void recoverTree(TreeNode root) {--newline--            TreeNode pre = null;--newline--            TreeNode first = null, second = null;--newline--            // Morris Traversal--newline--            TreeNode temp = null;--newline--    --tab----tab--while(root!=null){--newline--    --tab----tab----tab--if(root.left!=null){--newline--    --tab----tab----tab----tab--// connect threading for root--newline--    --tab----tab----tab----tab--temp = root.left;--newline--    --tab----tab----tab----tab--while(temp.right!=null && temp.right != root)--newline--    --tab----tab----tab----tab----tab--temp = temp.right;--newline--    --tab----tab----tab----tab--// the threading already exists--newline--    --tab----tab----tab----tab--if(temp.right!=null){--newline--    --tab----tab----tab----tab--    if(pre!=null && pre.val > root.val){--newline--    --tab----tab----tab----tab--        if(first==null){first = pre;second = root;}--newline--    --tab----tab----tab----tab--        else{second = root;}--newline--    --tab----tab----tab----tab--    }--newline--    --tab----tab----tab----tab--    pre = root;--newline--    --tab----tab----tab----tab--    --newline--    --tab----tab----tab----tab----tab--temp.right = null;--newline--    --tab----tab----tab----tab----tab--root = root.right;--newline--    --tab----tab----tab----tab--}else{--newline--    --tab----tab----tab----tab----tab--// construct the threading--newline--    --tab----tab----tab----tab----tab--temp.right = root;--newline--    --tab----tab----tab----tab----tab--root = root.left;--newline--    --tab----tab----tab----tab--}--newline--    --tab----tab----tab--}else{--newline--    --tab----tab----tab----tab--if(pre!=null && pre.val > root.val){--newline--    --tab----tab----tab----tab--    if(first==null){first = pre;second = root;}--newline--    --tab----tab----tab----tab--    else{second = root;}--newline--    --tab----tab----tab----tab--}--newline--    --tab----tab----tab----tab--pre = root;--newline--    --tab----tab----tab----tab--root = root.right;--newline--    --tab----tab----tab--}--newline--    --tab----tab--}--newline--    --tab----tab--// swap two node values;--newline--    --tab----tab--if(first!= null && second != null){--newline--    --tab----tab--    int t = first.val;--newline--    --tab----tab--    first.val = second.val;--newline--    --tab----tab--    second.val = t;--newline--    --tab----tab--}--newline--        }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Detail Explain about How Morris Traversal Finds two Incorrect Pointer"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Tree Deserializer and Visualizer for Python"
        },
        {
            "java": "public class Solution {--newline--    public void recoverTree(TreeNode root) {--newline--    --tab--//Morris-traversal--newline--    --tab----newline--        TreeNode first = null;--newline--        TreeNode second = null;--newline--        --newline--        TreeNode pred = null; //rightmost node in left tree--newline--        TreeNode prev = null; --newline--        --newline--        TreeNode curr = root;--newline--        --newline--        while(curr != null){--newline--            //for each node, we compare it with prev node as we did in in-order-traversal--newline--            if(prev != null && curr.val <= prev.val){--newline--                if(first == null) first = prev;--newline--                second = curr;--newline--            }--newline--            --newline--            if(curr.left != null){--newline--                //got left tree, then let's locate its rightmost node in left tree--newline--                pred = curr.left;--newline--                //we may have visited the left tree before, and connect the rightmost node with curr node (root node)--newline--                while(pred.right != null && pred.right != curr){--newline--                    pred = pred.right;--newline--                }--newline--                --newline--                if(pred.right == curr){--newline--                    //if this left tree has been visited before, then we are done with it--newline--                    //cut the connection with currNode and start visit curr's right tree--newline--                    pred.right = null;--newline--                    prev = curr;--newline--                    curr = curr.right;--newline--                }else{--newline--                    //if this left tree has not been visited before, then we create a back edge from rightmost node--newline--                    // to curr node, so we can return to the start point after done the left tree--newline--                    pred.right = curr;--newline--                    curr = curr.left;--newline--                }--newline--                --newline--            }else{--newline--                //no left tree, then just visit its right tree--newline--                prev = curr;--newline--                curr = curr.right;--newline--            }--newline--        }--newline--        --newline--        int temp = first.val;--newline--        first.val = second.val;--newline--        second.val = temp;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my solutions and detailed explanation with recursive&#x2F;iterative in-order-traversal and Morris-traversal"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--    TreeNode* first=NULL;--newline--    TreeNode* second=NULL;--newline--    TreeNode* prev = new TreeNode(INT_MIN);--newline--public:--newline--    void recoverTree(TreeNode* root) {--newline--        help(root);--newline--        swp(first->val, second->val);--newline--    }--newline--    --newline--    void help(TreeNode* root){--newline--        if(root==NULL)  return;--newline--        help(root->left);--newline--        if(first==NULL && prev->val >= root->val)   first=prev;--newline--        if(first!=NULL && prev->val >= root->val)   second=root;--newline--        prev=root;--newline--        help(root->right);--newline--    }--newline--};",
            "python": null,
            "topic_title": "&#91;recommend for beginners&#93;clean C++ implementation with detailed explaination"
        }
    ],
    "qc": "99.json"
}