{
    "posts": [
        {
            "java": "public class Solution {--newline--    public RandomListNode copyRandomList(RandomListNode head) {--newline--    --tab--RandomListNode iter = head, next;--newline--    --newline--    --tab--// First round: make copy of each node,--newline--    --tab--// and link them together side-by-side in a single list.--newline--    --tab--while (iter != null) {--newline--    --tab----tab--next = iter.next;--newline--    --newline--    --tab----tab--RandomListNode copy = new RandomListNode(iter.label);--newline--    --tab----tab--iter.next = copy;--newline--    --tab----tab--copy.next = next;--newline--    --newline--    --tab----tab--iter = next;--newline--    --tab--}--newline--    --newline--    --tab--// Second round: assign random pointers for the copy nodes.--newline--    --tab--iter = head;--newline--    --tab--while (iter != null) {--newline--    --tab----tab--if (iter.random != null) {--newline--    --tab----tab----tab--iter.next.random = iter.random.next;--newline--    --tab----tab--}--newline--    --tab----tab--iter = iter.next.next;--newline--    --tab--}--newline--    --newline--    --tab--// Third round: restore the original list, and extract the copy list.--newline--    --tab--iter = head;--newline--    --tab--RandomListNode pseudoHead = new RandomListNode(0);--newline--    --tab--RandomListNode copy, copyIter = pseudoHead;--newline--    --newline--    --tab--while (iter != null) {--newline--    --tab----tab--next = iter.next.next;--newline--    --newline--    --tab----tab--// extract the copy--newline--    --tab----tab--copy = iter.next;--newline--    --tab----tab--copyIter.next = copy;--newline--    --tab----tab--copyIter = copy;--newline--    --newline--    --tab----tab--// restore the original list--newline--    --tab----tab--iter.next = next;--newline--    --newline--    --tab----tab--iter = next;--newline--    --tab--}--newline--    --newline--    --tab--return pseudoHead.next;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "A solution with constant space complexity O(1) and linear time complexity O(N)"
        },
        {
            "java": "public class Solution {--newline--    public RandomListNode copyRandomList(RandomListNode head) {--newline--      if (head == null) return null;--newline--      --newline--      Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();--newline--      --newline--      // loop 1. copy all the nodes--newline--      RandomListNode node = head;--newline--      while (node != null) {--newline--        map.put(node, new RandomListNode(node.label));--newline--        node = node.next;--newline--      }--newline--      --newline--      // loop 2. assign next and random pointers--newline--      node = head;--newline--      while (node != null) {--newline--        map.get(node).next = map.get(node.next);--newline--        map.get(node).random = map.get(node.random);--newline--        node = node.next;--newline--      }--newline--      --newline--      return map.get(head);--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java O(n) solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    //--newline--    // Here's how the 1st algorithm goes.--newline--    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.--newline--    // Step 1:--newline--    // Build the 2nd list by creating a new node for each node in 1st list. --newline--    // While doing so, insert each new node after it's corresponding node in the 1st list.--newline--    // Step 2:--newline--    // The new head is the 2nd node as that was the first inserted node.--newline--    // Step 3:--newline--    // Fix the random pointers in the 2nd list: (Remember that l1->next is actually l2)--newline--    // l2->random will be the node in 2nd list that corresponds l1->random, --newline--    // which is next node of l1->random.--newline--    // Step 4:--newline--    // Separate the combined list into 2: Splice out nodes that are part of second list. --newline--    // Return the new head that we saved in step 2.--newline--    //--newline--    --newline--    RandomListNode *copyRandomList(RandomListNode *head) {--newline--        RandomListNode *newHead, *l1, *l2;--newline--        if (head == NULL) return NULL;--newline--        for (l1 = head; l1 != NULL; l1 = l1->next->next) {--newline--            l2 = new RandomListNode(l1->label);--newline--            l2->next = l1->next;--newline--            l1->next = l2;--newline--        }--newline--            --newline--        newHead = head->next;--newline--        for (l1 = head; l1 != NULL; l1 = l1->next->next) {--newline--            if (l1->random != NULL) l1->next->random = l1->random->next;--newline--        }--newline--            --newline--        for (l1 = head; l1 != NULL; l1 = l1->next) {--newline--            l2 = l1->next;--newline--            l1->next = l2->next;--newline--            if (l2->next != NULL) l2->next = l2->next->next;--newline--        }--newline--    --newline--        return newHead;--newline--    }--newline--    --newline--    --newline--    //--newline--    // Here's how the 2nd algorithm goes.--newline--    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.--newline--    // Step 1:--newline--    // Build the 2nd list by creating a new node for each node in 1st list. --newline--    // While doing so, set the next pointer of the new node to the random pointer --newline--    // of the corresponding node in the 1st list.  And set the random pointer of the --newline--    // 1st list's node to the newly created node.--newline--    // Step 2:--newline--    // The new head is the node pointed to by the random pointer of the 1st list.--newline--    // Step 3:--newline--    // Fix the random pointers in the 2nd list: (Remember that l1->random is l2)--newline--    // l2->random will be the node in 2nd list that corresponds to the node in the --newline--    // 1st list that is pointed to by l2->next, --newline--    // Step 4:--newline--    // Restore the random pointers of the 1st list and fix the next pointers of the --newline--    // 2nd list. random pointer of the node in 1st list is the next pointer of the --newline--    // corresponding node in the 2nd list.  This is what we had done in the --newline--    // 1st step and now we are reverting back. next pointer of the node in --newline--    // 2nd list is the random pointer of the node in 1st list that is pointed to --newline--    // by the next pointer of the corresponding node in the 1st list.--newline--    // Return the new head that we saved in step 2.--newline--    //--newline--    --newline--    RandomListNode *copyRandomList(RandomListNode *head) {--newline--        RandomListNode *newHead, *l1, *l2;--newline--        if (head == NULL) return NULL;--newline--    --newline--        for (l1 = head; l1 != NULL; l1 = l1->next) {--newline--            l2 = new RandomListNode(l1->label);--newline--            l2->next = l1->random;--newline--            l1->random = l2;--newline--        }--newline--        --newline--        newHead = head->random;--newline--        for (l1 = head; l1 != NULL; l1 = l1->next) {--newline--            l2 = l1->random;--newline--            l2->random = l2->next ? l2->next->random : NULL;--newline--        }--newline--        --newline--        for (l1 = head; l1 != NULL; l1 = l1->next) {--newline--            l2 = l1->random;--newline--            l1->random = l2->next;--newline--            l2->next = l1->next ? l1->next->random : NULL;--newline--        }--newline--    --newline--        return newHead;--newline--    }--newline--}",
            "python": null,
            "topic_title": "2 clean C++ algorithms without using extra array&#x2F;hash table.  Algorithms are explained step by step."
        },
        {
            "java": "/**--newline-- * Definition for singly-linked list with a random pointer.--newline-- * class RandomListNode {--newline-- *     int label;--newline-- *     RandomListNode next, random;--newline-- *     RandomListNode(int x) { this.label = x; }--newline-- * };--newline-- */--newline--public class Solution {--newline--    public RandomListNode copyRandomList(RandomListNode head) {--newline--        if(head==null){--newline--            return null;--newline--        }--newline--        RandomListNode n = head;--newline--        while (n!=null){--newline--            RandomListNode n2 = new RandomListNode(n.label);--newline--            RandomListNode tmp = n.next;--newline--            n.next = n2;--newline--            n2.next = tmp;--newline--            n = tmp;--newline--        }--newline--        --newline--        n=head;--newline--        while(n != null){--newline--            RandomListNode n2 = n.next;--newline--            if(n.random != null)--newline--                n2.random = n.random.next;--newline--            else--newline--                n2.random = null;--newline--            n = n.next.next;--newline--        }--newline--        --newline--        //detach list--newline--        RandomListNode n2 = head.next;--newline--        n = head;--newline--        RandomListNode head2 = head.next;--newline--        while(n2 != null && n != null){--newline--            n.next = n.next.next;--newline--            if (n2.next == null){--newline--                break;--newline--            }--newline--            n2.next = n2.next.next;--newline--            --newline--            n2 = n2.next;--newline--            n = n.next;--newline--        }--newline--        return head2;--newline--        --newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "My accepted Java code. O(n) but need to iterate the list 3 times"
        },
        {
            "java": "public class Solution {--newline--    public RandomListNode copyRandomList(RandomListNode head) {--newline--        if (head == null) {--newline--            return null;--newline--        }--newline--        --newline--        final Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();--newline----newline--        RandomListNode cur = head;--newline--        while(cur != null) {--newline--            map.put(cur, new RandomListNode(cur.label));--newline--            cur = cur.next;--newline--        }--newline--        --newline--        for (Map.Entry<RandomListNode, RandomListNode> entry : map.entrySet()) {--newline--            final RandomListNode newNode = entry.getValue();--newline--            newNode.next = map.get(entry.getKey().next);--newline--            newNode.random = map.get(entry.getKey().random);--newline--        }--newline--        --newline--        return map.get(head);--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Very short JAVA solution with Map"
        }
    ],
    "qc": "138.json"
}