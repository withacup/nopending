{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "(Guaranteed) Really Detailed and Good (Perfect) Explanation of The Skyline Problem"
        },
        {
            "java": "public class Solution {--newline--    --tab--public List<int[]> getSkyline(int[][] buildings) {--newline--        List<int[]> result = new ArrayList<>();--newline--        List<int[]> height = new ArrayList<>();--newline--        for(int[] b:buildings) {--newline--            height.add(new int[]{b[0], -b[2]});--newline--            height.add(new int[]{b[1], b[2]});--newline--        }--newline--        Collections.sort(height, (a, b) -> {--newline--                if(a[0] != b[0]) --newline--                    return a[0] - b[0];--newline--                return a[1] - b[1];--newline--        });--newline--        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));--newline--        pq.offer(0);--newline--        int prev = 0;--newline--        for(int[] h:height) {--newline--            if(h[1] < 0) {--newline--                pq.offer(-h[1]);--newline--            } else {--newline--                pq.remove(h[1]);--newline--            }--newline--            int cur = pq.peek();--newline--            if(prev != cur) {--newline--                result.add(new int[]{h[0], cur});--newline--                prev = cur;--newline--            }--newline--        }--newline--        return result;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Short Java solution"
        },
        {
            "java": "public class Solution {--newline--    public List<int[]> getSkyline(int[][] buildings) {--newline--        List<int[]> result = new ArrayList<>();--newline--        List<int[]> height = new ArrayList<>();--newline--        for(int[] b:buildings) {--newline--            // start point has negative height value--newline--            height.add(new int[]{b[0], -b[2]});--newline--            // end point has normal height value--newline--            height.add(new int[]{b[1], b[2]}); --newline--        }--newline--    --newline--        // sort $height, based on the first value, if necessary, use the second to--newline--        // break ties--newline--        Collections.sort(height, (a, b) -> {--newline--                if(a[0] != b[0]) --newline--                    return a[0] - b[0];--newline--                return a[1] - b[1];--newline--        });--newline--    --newline--        // Use a maxHeap to store possible heights--newline--        Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));--newline--    --newline--        // Provide a initial value to make it more consistent--newline--        pq.offer(0);--newline--    --newline--        // Before starting, the previous max height is 0;--newline--        int prev = 0;--newline--    --newline--        // visit all points in order--newline--        for(int[] h:height) {--newline--            if(h[1] < 0) { // a start point, add height--newline--                pq.offer(-h[1]);--newline--            } else {  // a end point, remove height--newline--                pq.remove(h[1]);--newline--            }--newline--            int cur = pq.peek(); // current max height;--newline--      --newline--            // compare current max height with previous max height, update result and --newline--            // previous max height if necessary--newline--            if(prev != cur) {--newline--                result.add(new int[]{h[0], cur});--newline--                prev = cur;--newline--            }--newline--        }--newline--        return result;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Once for all, explanation with clean Java code(O(n^2)time, O(n) space)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) {--newline--        vector<pair<int, int>> res;--newline--        int cur=0, cur_X, cur_H =-1,  len = buildings.size();--newline--        priority_queue< pair<int, int>> liveBlg; // first: height, second, end time--newline--        while(cur<len || !liveBlg.empty())--newline--        { // if either some new building is not processed or live building queue is not empty--newline--            cur_X = liveBlg.empty()? buildings[cur][0]:liveBlg.top().second; // next timing point to process--newline----newline--            if(cur>=len || buildings[cur][0] > cur_X)--newline--            { //first check if the current tallest building will end before the next timing point--newline--                  // pop up the processed buildings, i.e. those  have height no larger than cur_H and end before the top one--newline--                while(!liveBlg.empty() && ( liveBlg.top().second <= cur_X) ) liveBlg.pop();--newline--            }--newline--            else--newline--            { // if the next new building starts before the top one ends, process the new building in the vector--newline--                cur_X = buildings[cur][0];--newline--                while(cur<len && buildings[cur][0]== cur_X)  // go through all the new buildings that starts at the same point--newline--                {  // just push them in the queue--newline--                    liveBlg.push(make_pair(buildings[cur][2], buildings[cur][1]));--newline--                    cur++;--newline--                }--newline--            }--newline--            cur_H = liveBlg.empty()?0:liveBlg.top().first; // outut the top one--newline--            if(res.empty() || (res.back().second != cur_H) ) res.push_back(make_pair(cur_X, cur_H));--newline--        }--newline--        return res;--newline--    }--newline--};",
            "python": null,
            "topic_title": "My C++ code using one priority queue (812 ms)"
        },
        {
            "java": "public class Solution {--newline----tab--public List<int[]> getSkyline(int[][] buildings) {--newline----tab----tab--if (buildings.length == 0)--newline----tab----tab----tab--return new LinkedList<int[]>();--newline----tab----tab--return recurSkyline(buildings, 0, buildings.length - 1);--newline----tab--}--newline----newline----tab--private LinkedList<int[]> recurSkyline(int[][] buildings, int p, int q) {--newline----tab----tab--if (p < q) {--newline----tab----tab----tab--int mid = p + (q - p) / 2;--newline----tab----tab----tab--return merge(recurSkyline(buildings, p, mid),--newline----tab----tab----tab----tab----tab--recurSkyline(buildings, mid + 1, q));--newline----tab----tab--} else {--newline----tab----tab----tab--LinkedList<int[]> rs = new LinkedList<int[]>();--newline----tab----tab----tab--rs.add(new int[] { buildings[p][0], buildings[p][2] });--newline----tab----tab----tab--rs.add(new int[] { buildings[p][1], 0 });--newline----tab----tab----tab--return rs;--newline----tab----tab--}--newline----tab--}--newline----newline----tab--private LinkedList<int[]> merge(LinkedList<int[]> l1, LinkedList<int[]> l2) {--newline----tab----tab--LinkedList<int[]> rs = new LinkedList<int[]>();--newline----tab----tab--int h1 = 0, h2 = 0;--newline----tab----tab--while (l1.size() > 0 && l2.size() > 0) {--newline----tab----tab----tab--int x = 0, h = 0;--newline----tab----tab----tab--if (l1.getFirst()[0] < l2.getFirst()[0]) {--newline----tab----tab----tab----tab--x = l1.getFirst()[0];--newline----tab----tab----tab----tab--h1 = l1.getFirst()[1];--newline----tab----tab----tab----tab--h = Math.max(h1, h2);--newline----tab----tab----tab----tab--l1.removeFirst();--newline----tab----tab----tab--} else if (l1.getFirst()[0] > l2.getFirst()[0]) {--newline----tab----tab----tab----tab--x = l2.getFirst()[0];--newline----tab----tab----tab----tab--h2 = l2.getFirst()[1];--newline----tab----tab----tab----tab--h = Math.max(h1, h2);--newline----tab----tab----tab----tab--l2.removeFirst();--newline----tab----tab----tab--} else {--newline----tab----tab----tab----tab--x = l1.getFirst()[0];--newline----tab----tab----tab----tab--h1 = l1.getFirst()[1];--newline----tab----tab----tab----tab--h2 = l2.getFirst()[1];--newline----tab----tab----tab----tab--h = Math.max(h1, h2);--newline----tab----tab----tab----tab--l1.removeFirst();--newline----tab----tab----tab----tab--l2.removeFirst();--newline----tab----tab----tab--}--newline----tab----tab----tab--if (rs.size() == 0 || h != rs.getLast()[1]) {--newline----tab----tab----tab----tab--rs.add(new int[] { x, h });--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--rs.addAll(l1);--newline----tab----tab--rs.addAll(l2);--newline----tab----tab--return rs;--newline----tab--}--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my divide and conquer java solution, 464 ms"
        }
    ],
    "qc": "218.json"
}