{
    "posts": [
        {
            "java": "public class Solution {--newline--    public static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};--newline--    --newline--    public int longestIncreasingPath(int[][] matrix) {--newline--        if(matrix.length == 0) return 0;--newline--        int m = matrix.length, n = matrix[0].length;--newline--        int[][] cache = new int[m][n];--newline--        int max = 1;--newline--        for(int i = 0; i < m; i++) {--newline--            for(int j = 0; j < n; j++) {--newline--                int len = dfs(matrix, i, j, m, n, cache);--newline--                max = Math.max(max, len);--newline--            }--newline--        }   --newline--        return max;--newline--    }--newline--    --newline--    public int dfs(int[][] matrix, int i, int j, int m, int n, int[][] cache) {--newline--        if(cache[i][j] != 0) return cache[i][j];--newline--        int max = 1;--newline--        for(int[] dir: dirs) {--newline--            int x = i + dir[0], y = j + dir[1];--newline--            if(x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] <= matrix[i][j]) continue;--newline--            int len = 1 + dfs(matrix, x, y, m, n, cache);--newline--            max = Math.max(max, len);--newline--        }--newline--        cache[i][j] = max;--newline--        return max;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "15ms Concise Java Solution"
        },
        {
            "java": "public class Solution {--newline--    public int longestIncreasingPath(int[][] matrix) {--newline--        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {--newline--            return 0;--newline--        }--newline--        int[][] cache = new int[matrix.length][matrix[0].length];--newline--        int max = 0;--newline--        for (int i = 0; i < matrix.length; i++) {--newline--            for (int j = 0; j < matrix[0].length; j++) {--newline--                int length = findSmallAround(i, j, matrix, cache, Integer.MAX_VALUE);--newline--                max = Math.max(length, max);--newline--            }--newline--        }--newline--        return max;--newline--    }--newline--    private int findSmallAround(int i, int j, int[][] matrix, int[][] cache, int pre) {--newline--        // if out of bond OR current cell value larger than previous cell value.--newline--        if (i < 0 || i >= matrix.length || j < 0 || j >= matrix[0].length || matrix[i][j] >= pre) {--newline--            return 0;--newline--        }--newline--        // if calculated before, no need to do it again--newline--        if (cache[i][j] > 0) {--newline--            return cache[i][j];--newline--        } else {--newline--            int cur = matrix[i][j];--newline--            int tempMax = 0;--newline--            tempMax = Math.max(findSmallAround(i - 1, j, matrix, cache, cur), tempMax);--newline--            tempMax = Math.max(findSmallAround(i + 1, j, matrix, cache, cur), tempMax);--newline--            tempMax = Math.max(findSmallAround(i, j - 1, matrix, cache, cur), tempMax);--newline--            tempMax = Math.max(findSmallAround(i, j + 1, matrix, cache, cur), tempMax);--newline--            cache[i][j] = ++tempMax;--newline--            return tempMax;--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java 14ms relative short &amp; easy to code solution with explanation. O(mn) time O(mn) space. DFS + DP"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def longestIncreasingPath(self, matrix):--newline----tab--        def dfs(i, j):--newline----tab--            if not dp[i][j]:--newline----tab--                val = matrix[i][j]--newline----tab--                dp[i][j] = 1 + max(--newline----tab--                    dfs(i - 1, j) if i and val > matrix[i - 1][j] else 0,--newline----tab--                    dfs(i + 1, j) if i < M - 1 and val > matrix[i + 1][j] else 0,--newline----tab--                    dfs(i, j - 1) if j and val > matrix[i][j - 1] else 0,--newline----tab--                    dfs(i, j + 1) if j < N - 1 and val > matrix[i][j + 1] else 0)--newline----tab--            return dp[i][j]--newline----tab--    --newline----tab--        if not matrix or not matrix[0]: return 0--newline----tab--        M, N = len(matrix), len(matrix[0])--newline----tab--        dp = [[0] * N for i in range(M)]--newline----tab--        return max(dfs(x, y) for x in range(M) for y in range(N))",
            "topic_title": "Python solution, memoization dp, 288ms"
        },
        {
            "java": "public static class Point{--newline--    int x;--newline--    int y;--newline--    public Point(int x, int y) {--newline--        this.x = x;--newline--        this.y = y;--newline--    }--newline--}--newline----newline--public static int longestIncreasingPath(int[][] matrix) {--newline--    if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0)--newline--        return 0;--newline--    int n = matrix.length, m = matrix[0].length, count = m * n, ans = 0;--newline--    while (count > 0) {--newline--        HashSet<Point> remove = new HashSet<Point>();--newline--        // each round, remove the peak number.--newline--        for (int i = 0; i < n; i++) {--newline--            for (int j = 0; j < m; j++) {--newline--                if (matrix[i][j] == Integer.MIN_VALUE)--newline--                    continue;--newline--                boolean up = (i == 0 || matrix[i][j] >= matrix[i - 1][j]);--newline--                boolean bottom = (i == n - 1 || matrix[i][j] >= matrix[i + 1][j]);--newline--                boolean left = (j == 0 || matrix[i][j] >= matrix[i][j - 1]);--newline--                boolean right = (j == m - 1 || matrix[i][j] >= matrix[i][j + 1]);--newline--                if (up && bottom && left && right)--newline--                    remove.add(new Point(i, j));--newline--            }--newline--        }--newline--        for (Point point : remove) {--newline--            matrix[point.x][point.y] = Integer.MIN_VALUE;--newline--            count--;--newline--        }--newline--        ans++;--newline--    }--newline--    return ans;--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Graph theory, Java solution, O(v^2), no DFS"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int longestIncreasingPath(vector<vector<int>>& matrix) {--newline--        int rows = matrix.size();--newline--        if (!rows) return 0;--newline--        int cols = matrix[0].size();--newline--        --newline--        vector<vector<int>> dp(rows, vector<int>(cols, 0));--newline--        std::function<int(int, int)> dfs = [&] (int x, int y) {--newline--            if (dp[x][y]) return dp[x][y];--newline--            vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};--newline--            for (auto &dir : dirs) {--newline--                int xx = x + dir[0], yy = y + dir[1];--newline--                if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;--newline--                if (matrix[xx][yy] <= matrix[x][y]) continue;--newline--                dp[x][y] = std::max(dp[x][y], dfs(xx, yy));--newline--            }--newline--            return ++dp[x][y];--newline--        };--newline--        --newline--        int ret = 0;--newline--        for (int i = 0; i < rows; ++i) {--newline--            for (int j = 0; j < cols; ++j) {--newline--                ret = std::max(ret, dfs(i, j));--newline--            }--newline--        }--newline--        --newline--        return ret;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ DP &#x2F; DFS solution sharing"
        }
    ],
    "qc": "329.json"
}