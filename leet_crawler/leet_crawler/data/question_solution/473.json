{
    "posts": [
        {
            "java": "public class Solution {--newline--    public boolean makesquare(int[] nums) {--newline--    --tab--if (nums == null || nums.length < 4) return false;--newline--        int sum = 0;--newline--        for (int num : nums) sum += num;--newline--        if (sum % 4 != 0) return false;--newline--        --newline--        Arrays.sort(nums);--newline--        reverse(nums);--newline--        --newline--    --tab--return dfs(nums, new int[4], 0, sum / 4);--newline--    }--newline--    --newline--    private boolean dfs(int[] nums, int[] sums, int index, int target) {--newline--    --tab--if (index == nums.length) {--newline--    --tab--    if (sums[0] == target && sums[1] == target && sums[2] == target) {--newline--    --tab----tab--return true;--newline--    --tab--    }--newline--    --tab--    return false;--newline--    --tab--}--newline--    --tab----newline--    --tab--for (int i = 0; i < 4; i++) {--newline--    --tab--    if (sums[i] + nums[index] > target) continue;--newline--    --tab--    sums[i] += nums[index];--newline--            if (dfs(nums, sums, index + 1, target)) return true;--newline--    --tab--    sums[i] -= nums[index];--newline--    --tab--}--newline--    --tab----newline--    --tab--return false;--newline--    }--newline--    --newline--    private void reverse(int[] nums) {--newline--        int i = 0, j = nums.length - 1;--newline--        while (i < j) {--newline--            int temp = nums[i];--newline--            nums[i] = nums[j];--newline--            nums[j] = temp;--newline--            i++; j--;--newline--        }--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java DFS Solution with Explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--    bool dfs(vector<int> &sidesLength,const vector<int> &matches, int index, const int target) {--newline--        if (index == matches.size())--newline--            return sidesLength[0] == sidesLength[1] && sidesLength[1] == sidesLength[2] && sidesLength[2] == sidesLength[3];--newline--        for (int i = 0; i < 4; ++i) {--newline--            if (sidesLength[i] + matches[index] > target) // first--newline--                continue;--newline--            int j = i;--newline--            while (--j >= 0) // third--newline--                if (sidesLength[i] == sidesLength[j]) --newline--                    break;--newline--            if (j != -1) continue;--newline--            sidesLength[i] += matches[index];--newline--            if (dfs(sidesLength, matches, index + 1, target))--newline--                return true;--newline--            sidesLength[i] -= matches[index];--newline--        }--newline--        return false;--newline--    }--newline--public:--newline--    bool makesquare(vector<int>& nums) {--newline--        if (nums.size() < 4) return false;--newline--        int sum = 0;--newline--        for (const int val: nums) {--newline--            sum += val;--newline--        }--newline--        if (sum % 4 != 0) return false;--newline--        sort(nums.begin(), nums.end(), [](const int &l, const int &r){return l > r;}); // second--newline--        vector<int> sidesLength(4, 0);--newline--        return dfs(sidesLength, nums, 0, sum / 4);--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "cpp 6ms solution with DFS"
        },
        {
            "java": "public class Solution {--newline--    public boolean makesquare(int[] nums) {--newline--        if (nums.length < 4) return false;--newline--            --newline--        int perimeter = 0;--newline--        for (int ele : nums) perimeter += ele;--newline--        if (perimeter % 4 != 0) return false;--newline--            --newline--        Arrays.sort(nums);--newline--        int side = perimeter / 4;--newline--            --newline--        for (int i = 0; i < 3; i++) {--newline--            if (!makesquareSub(nums, nums.length - 1, side, new HashSet<>())) return false;--newline--        }--newline--        --newline--        return true;--newline--    }--newline--        --newline--    private boolean makesquareSub(int[] nums, int i, int sum, Set<Integer> set) {--newline--        if (sum == 0) return true;--newline--        if (set.contains(sum) || i < 0) return false;--newline--        --newline--        if (nums[i] > 0 && nums[i] <= sum) {--newline--            nums[i] = -nums[i];--newline--            if (makesquareSub(nums, i - 1, sum + nums[i], set)) return true;--newline--            nums[i] = -nums[i];--newline--        }--newline--            --newline--        if (makesquareSub(nums, i - 1, sum, set)) return true;--newline--            --newline--        set.add(sum);--newline--        return false;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java DFS solution with various optimizations (sorting, sequential-partition, DP)"
        },
        {
            "java": "public class Solution {--newline--    public boolean makesquare(int[] nums) {--newline--            Long sum=0l;--newline--            for(int x:nums){--newline--                sum=sum+x;--newline--            }--newline--            if(sum%4!=0||nums.length<4) return false;--newline--            long width=(sum/4);--newline--            Arrays.sort(nums);--newline--            long sum1=0,sum2=0,sum3=0,sum4=0;--newline--            return helper(nums,nums.length-1,sum1,sum2,sum3,sum4,width);--newline--            --newline--        }--newline--        public boolean helper(int[] a, int i,long sum1,long sum2,long sum3,long sum4, long width){--newline--            if(sum1>width||sum2>width||sum3>width||sum4>width) return false;--newline--            if(i==-1){--newline--                if(sum1==width&&sum2==width&&sum3==width&&sum4==width) return true;--newline--                else return false;--newline--            }--newline--    //check a[i]  belonging to side1,side2,side3,side4--newline--            return helper(a,i-1,sum1+a[i],sum2,sum3,sum4,width)||--newline--            helper(a,i-1,sum1,sum2+a[i],sum3,sum4,width)||--newline--            helper(a,i-1,sum1,sum2,sum3+a[i],sum4,width)||--newline--            helper(a,i-1,sum1,sum2,sum3,sum4+a[i],width);--newline--        }--newline--    ````--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Simple Recursion Java solution. 66ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    bool makesquare(vector<int>& nums) {--newline--        int n = nums.size();--newline--    --newline--        long sum = accumulate(nums.begin(), nums.end(), 0l);--newline--        if (sum % 4)--newline--            return false;--newline--        long sideLen = sum / 4;--newline--        // need to solve the problem of partitioning nums into four equal subsets each having--newline--        // sum equal to sideLen--newline--        vector<int> usedMasks;--newline--        // validHalfSubsets[i] == true iff the subset represented by bitmask i--newline--        // has sum == 2*sideLen, AND the subset represented by i can be further partitioned into--newline--        // two equal subsets. See below for how it is used.--newline--        vector<bool> validHalfSubsets(1<<n, false);--newline--    --newline--        // E.g., if n = 5, (1 << 5 - 1) = 11111 represents the whole set--newline--        int all = (1 << n) - 1;--newline--        // go through all possible subsets each represented by a bitmask--newline--        for (int mask = 0; mask <= all; mask++) {--newline--            long subsetSum = 0;--newline--            // calculate the sum of this subset--newline--            for (int i = 0; i < 32; i++) {--newline--    --tab--    if ((mask >> i) & 1)--newline--    --tab----tab--subsetSum += nums[i];--newline--            }--newline--    --tab--// if this subset has what we want--newline--    --tab--if (subsetSum == sideLen) {--newline--    --tab--    for (int usedMask : usedMasks) {--newline--    --tab--    // if this mask and usedMask are mutually exclusive--newline--    --tab--        if ((usedMask & mask) == 0) {--newline--    --tab----tab--    // then they form a valid half subset whose sum is 2 * sideLen,--newline--                        // that can be further partitioned into two equal subsets (usedMask and mask)--newline--    --tab----tab--    int validHalf = usedMask | mask;--newline--    --tab----tab--    validHalfSubsets[validHalf] = true;--newline--    --tab----tab--    // if in the past we concluded that the other half is also a valid--newline--    --tab----tab--    // half subset, DONE!--newline--    --tab----tab--    if (validHalfSubsets[all ^ validHalf])--newline--    --tab----tab--        return true;--newline--    --tab--        }--newline--                }--newline--    --tab--    usedMasks.push_back(mask);--newline--            }--newline--        }--newline--        return false;--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "C++ bit masking + DP solution with detailed comments"
        }
    ],
    "qc": "473.json"
}