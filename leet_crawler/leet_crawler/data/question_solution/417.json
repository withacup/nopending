{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<int[]> pacificAtlantic(int[][] matrix) {--newline--        List<int[]> res = new LinkedList<>();--newline--        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){--newline--            return res;--newline--        }--newline--        int n = matrix.length, m = matrix[0].length;--newline--        boolean[][]pacific = new boolean[n][m];--newline--        boolean[][]atlantic = new boolean[n][m];--newline--        for(int i=0; i<n; i++){--newline--            dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);--newline--            dfs(matrix, atlantic, Integer.MIN_VALUE, i, m-1);--newline--        }--newline--        for(int i=0; i<m; i++){--newline--            dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);--newline--            dfs(matrix, atlantic, Integer.MIN_VALUE, n-1, i);--newline--        }--newline--        for (int i = 0; i < n; i++) --newline--            for (int j = 0; j < m; j++) --newline--                if (pacific[i][j] && atlantic[i][j]) --newline--                    res.add(new int[] {i, j});--newline--        return res;--newline--    }--newline--    --newline--    int[][]dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};--newline--    --newline--    public void dfs(int[][]matrix, boolean[][]visited, int height, int x, int y){--newline--        int n = matrix.length, m = matrix[0].length;--newline--        if(x<0 || x>=n || y<0 || y>=m || visited[x][y] || matrix[x][y] < height)--newline--            return;--newline--        visited[x][y] = true;--newline--        for(int[]d:dir){--newline--            dfs(matrix, visited, matrix[x][y], x+d[0], y+d[1]);--newline--        }--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java BFS &amp; DFS from Ocean"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<pair<int, int>> res;--newline--    vector<vector<int>> visited;--newline--    void dfs(vector<vector<int>>& matrix, int x, int y, int pre, int preval){--newline--        if (x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size()  --newline--                || matrix[x][y] < pre || (visited[x][y] & preval) == preval) --newline--            return;--newline--        visited[x][y] |= preval;--newline--        if (visited[x][y] == 3) res.push_back({x, y});--newline--        dfs(matrix, x + 1, y, matrix[x][y], visited[x][y]); dfs(matrix, x - 1, y, matrix[x][y], visited[x][y]);--newline--        dfs(matrix, x, y + 1, matrix[x][y], visited[x][y]); dfs(matrix, x, y - 1, matrix[x][y], visited[x][y]);--newline--    }--newline----newline--    vector<pair<int, int>> pacificAtlantic(vector<vector<int>>& matrix) {--newline--        if (matrix.empty()) return res;--newline--        int m = matrix.size(), n = matrix[0].size();--newline--        visited.resize(m, vector<int>(n, 0));--newline--        for (int i = 0; i < m; i++) {--newline--            dfs(matrix, i, 0, INT_MIN, 1);--newline--            dfs(matrix, i, n - 1, INT_MIN, 2);--newline--        }--newline--        for (int i = 0; i < n; i++) {--newline--            dfs(matrix, 0, i, INT_MIN, 1);--newline--            dfs(matrix, m - 1, i, INT_MIN, 2);--newline--        }--newline--        return res;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Very Concise C++ solution using DFS and bit mask"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def pacificAtlantic(self, matrix):--newline----tab--        \"\"\"--newline----tab--        :type matrix: List[List[int]]--newline----tab--        :rtype: List[List[int]]--newline----tab--        \"\"\"--newline----tab--        if not matrix: return []--newline----tab--        self.directions = [(1,0),(-1,0),(0,1),(0,-1)]--newline----tab--        m = len(matrix)--newline----tab--        n = len(matrix[0])--newline----tab--        p_visited = [[False for _ in range(n)] for _ in range(m)]--newline----tab--        --newline----tab--        a_visited = [[False for _ in range(n)] for _ in range(m)]--newline----tab--        result = []--newline----tab--        --newline----tab--        for i in range(m):--newline----tab--            # p_visited[i][0] = True--newline----tab--            # a_visited[i][n-1] = True--newline----tab--            self.dfs(matrix, i, 0, p_visited, m, n)--newline----tab--            self.dfs(matrix, i, n-1, a_visited, m, n)--newline----tab--        for j in range(n):--newline----tab--            # p_visited[0][j] = True--newline----tab--            # a_visited[m-1][j] = True--newline----tab--            self.dfs(matrix, 0, j, p_visited, m, n)--newline----tab--            self.dfs(matrix, m-1, j, a_visited, m, n)--newline----tab--            --newline----tab--        for i in range(m):--newline----tab--            for j in range(n):--newline----tab--                if p_visited[i][j] and a_visited[i][j]:--newline----tab--                    result.append([i,j])--newline----tab--        return result--newline----tab--                --newline----tab--                --newline----tab--    def dfs(self, matrix, i, j, visited, m, n):--newline----tab--        # when dfs called, meaning its caller already verified this point --newline----tab--        visited[i][j] = True--newline----tab--        for dir in self.directions:--newline----tab--            x, y = i + dir[0], j + dir[1]--newline----tab--            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y] or matrix[x][y] < matrix[i][j]:--newline----tab--                continue--newline----tab--            self.dfs(matrix, x, y, visited, m, n)--newline----tab--# 113 / 113 test cases passed.--newline----tab--# Runtime: 196 ms--newline----tab--",
            "topic_title": "Python DFS bests 85%. Tips for all DFS in matrix question."
        },
        {
            "java": "/*--newline--1.Naive solution:--newline--    Standard dfs, which means for each point, we check if it can reach both pacific and atlantic, --newline--    for each point, we can possibly check all the rest of points, O(m*n * m*n)--newline----newline--2.A little improvement:--newline--    What about we 4 hash tables, they keep track of all the points we know so far that --newline--        can reach atlantic--newline--        cannot reach atlantic--newline--        can reach pacific--newline--        cannot reach pacific--newline--    It's doable, still hit TLE, although I didn't hit TLE when not submitting the code, but running it using the provided testing environment--newline----newline--3.On the other hand, we can consider the flip side--newline--    We can let the pacific and atlantic ocean \"flow into\" the matrix as much as possible,--newline--    using 2 boolean arrays, one for each ocean. --newline--    The result are the points that are true in both boolean table--newline--*/--newline----newline----newline--public class Solution {--newline--    public List<int[]> pacificAtlantic(int[][] matrix) {--newline--        List<int[]> result = new ArrayList<int[]>();--newline--        if(matrix.length == 0 || matrix[0].length == 0) return result;   --newline--        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];  // the pacific boolean table--newline--        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length]; // the atlantic booean table--newline--        //initially, all the top and left cells are flooded with pacific water--newline--        //and all the right and bottom cells are flooded with atlantic water--newline--        for(int i = 0; i < matrix.length; i++){--newline--            pacific[i][0] = true;--newline--            atlantic[i][matrix[0].length-1] = true;--newline--        }--newline--        for(int i = 0; i < matrix[0].length; i++){--newline--            pacific[0][i] = true;--newline--            atlantic[matrix.length-1][i] = true; --newline--        }--newline--        //we go around the matrix and try to flood the matrix from 4 side.--newline--        for(int i = 0; i < matrix.length; i++){--newline--            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];--newline--            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];--newline--            water(pacific, pacificVisited, matrix, i,0);--newline--            water(atlantic, atlanticVisited, matrix, i, matrix[0].length - 1);            --newline--        }--newline--        for(int i = 0; i < matrix[0].length; i++){--newline--            boolean[][] pacificVisited = new boolean[matrix.length][matrix[0].length];--newline--            boolean[][] atlanticVisited = new boolean[matrix.length][matrix[0].length];--newline--            water(pacific, pacificVisited, matrix, 0,i);--newline--            water(atlantic, atlanticVisited, matrix, matrix.length - 1, i);            --newline--        }--newline--        //check the shared points among 2 tables--newline--        for(int i = 0; i < matrix.length; i++){--newline--            for(int j = 0; j < matrix[0].length; j++){--newline--                if(pacific[i][j] && atlantic[i][j]){--newline--                    int[] element = {i,j};--newline--                    result.add(element);--newline--                }--newline--            }--newline--        }--newline--        return result;--newline--    }--newline--    //the flood function--newline--    private void water(boolean[][] wet, boolean[][] visited, int[][] matrix, int i , int j){--newline--        wet[i][j] = true;--newline--        visited[i][j] = true;--newline--        int[] x = {0,0,1,-1};--newline--        int[] y = {1,-1,0,0};--newline--        for(int k = 0; k < 4; k++){--newline--            if(i+y[k] >= 0 && i+y[k] < matrix.length && j+x[k] >= 0 && j+x[k] < matrix[0].length --newline--                && !visited[i+y[k]][j+x[k]] && matrix[i+y[k]][j+x[k]] >= matrix[i][j]){--newline--                water(wet, visited, matrix, i+y[k], j+x[k]);--newline--            }--newline--        }--newline--    }--newline--}````--newline----newline--P.S Sometimes you choose an option just because the alternative is just worse.....",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Simple commented java solution with thinking progress O(n)"
        },
        {
            "java": "public class Solution {--newline--    static int[] dx = {-1,0,0,1};--newline--    static int[] dy = {0,1,-1,0};--newline--    public List<int[]> pacificAtlantic(int[][] matrix) {--newline--        List<int[]> res = new ArrayList<>();--newline--        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;--newline--        boolean[][] pacific = new boolean[matrix.length][matrix[0].length];--newline--        boolean[][] atlantic = new boolean[matrix.length][matrix[0].length];--newline--        for (int i = 0; i < matrix.length; i++){--newline--            pacific[i][0] = true;--newline--            atlantic[i][matrix[0].length-1] = true;--newline--        }--newline--        for (int j = 0; j < matrix[0].length; j++){--newline--            pacific[0][j] = true;--newline--            atlantic[matrix.length-1][j] = true;--newline--        }--newline--        for (int i = 0; i < matrix.length; i++){--newline--            explore(pacific, matrix, i, 0);--newline--            explore(atlantic, matrix, i, matrix[0].length-1);--newline--        }--newline--        for (int j = 0; j < matrix[0].length; j++){--newline--            explore(pacific, matrix, 0, j);--newline--            explore(atlantic, matrix, matrix.length-1, j);--newline--        }--newline--        for (int i = 0; i < matrix.length; i++){--newline--            for (int j = 0; j < matrix[0].length; j++){--newline--                if (pacific[i][j] && atlantic[i][j] == true)--newline--                    res.add(new int[]{i,j});--newline--            }--newline--        }--newline--        return res;--newline--        --newline--    }--newline--    private void explore(boolean[][] grid, int[][] matrix, int i, int j){--newline--        grid[i][j] = true;--newline--        for (int d = 0; d < dx.length; d++){--newline--            if (i+dy[d] < grid.length && i+dy[d] >= 0 && --newline--                j + dx[d] < grid[0].length && j + dx[d] >= 0 && --newline--                grid[i+dy[d]][j+dx[d]] == false && matrix[i+dy[d]][j+dx[d]] >= matrix[i][j])--newline--                    explore(grid, matrix, i+dy[d], j+dx[d]);--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA 17ms Solution, Simple and Clear, similar to Number of Islands&#x27;s idea"
        }
    ],
    "qc": "417.json"
}