{
    "posts": [
        {
            "java": "public class Solution {--newline----tab--List<List<String>> results;--newline----tab--List<String> list;--newline----tab--Map<String,List<String>> map;--newline----tab--    public List<List<String>> findLadders(String start, String end, Set<String> dict) {--newline----tab--        results= new ArrayList<List<String>>();--newline----tab--        if (dict.size() == 0)--newline----tab----tab----tab----tab--return results;--newline----tab--        --newline----tab--        int curr=1,next=0;--tab--        --newline----tab--        boolean found=false;--tab--        --newline----tab--        list = new LinkedList<String>();--tab--       --newline----tab----tab----tab--map = new HashMap<String,List<String>>();--newline----tab----tab----tab----newline----tab----tab----tab--Queue<String> queue= new ArrayDeque<String>();--newline----tab----tab----tab--Set<String> unvisited = new HashSet<String>(dict);--newline----tab----tab----tab--Set<String> visited = new HashSet<String>();--newline----tab----tab----tab----newline----tab----tab----tab--queue.add(start);--tab----tab----tab----newline----tab----tab----tab--unvisited.add(end);--newline----tab----tab----tab--unvisited.remove(start);--newline----tab----tab----tab--//BFS--newline----tab----tab----tab--while (!queue.isEmpty()) {--newline----tab----tab----tab--   --newline----tab----tab----tab----tab--String word = queue.poll();--newline----tab----tab----tab----tab--curr--;--tab----tab----tab----tab----newline----tab----tab----tab----tab--for (int i = 0; i < word.length(); i++){--newline----tab----tab----tab----tab--   StringBuilder builder = new StringBuilder(word); --newline----tab----tab----tab----tab----tab--for (char ch='a';  ch <= 'z'; ch++){--newline----tab----tab----tab----tab----tab----tab--builder.setCharAt(i,ch);--newline----tab----tab----tab----tab----tab----tab--String new_word=builder.toString();--tab----newline----tab----tab----tab----tab----tab----tab--if (unvisited.contains(new_word)){--newline----tab----tab----tab----tab----tab----tab----tab--//Handle queue--newline----tab----tab----tab----tab----tab----tab----tab--if (visited.add(new_word)){//Key statement,Avoid Duplicate queue insertion--newline----tab----tab----tab----tab----tab----tab----tab----tab--next++;--newline----tab----tab----tab----tab----tab----tab----tab----tab--queue.add(new_word);--newline----tab----tab----tab----tab----tab----tab----tab--}--newline----tab----tab----tab----tab----tab----tab----tab----newline----tab----tab----tab----tab----tab----tab----tab--if (map.containsKey(new_word))//Build Adjacent Graph--newline----tab----tab----tab----tab----tab----tab----tab----tab--map.get(new_word).add(word);--newline----tab----tab----tab----tab----tab----tab----tab--else{--newline----tab----tab----tab----tab----tab----tab----tab----tab--List<String> l= new LinkedList<String>();--newline----tab----tab----tab----tab----tab----tab----tab----tab--l.add(word);--newline----tab----tab----tab----tab----tab----tab----tab----tab--map.put(new_word, l);--newline----tab----tab----tab----tab----tab----tab----tab--}--newline----tab----tab----tab----tab----tab----tab----tab----newline----tab----tab----tab----tab----tab----tab----tab--if (new_word.equals(end)&&!found) found=true;--tab----tab----newline----tab----tab----tab----tab----tab----tab----tab----tab----tab----tab----tab----tab----tab----tab----newline----tab----tab----tab----tab----tab----tab--}--newline----newline----tab----tab----tab----tab----tab--}//End:Iteration from 'a' to 'z'--newline----tab----tab----tab----tab--}//End:Iteration from the first to the last--newline----tab----tab----tab----tab--if (curr==0){--newline----tab----tab----tab----tab----tab--if (found) break;--newline----tab----tab----tab----tab----tab--curr=next;--newline----tab----tab----tab----tab----tab--next=0;--newline----tab----tab----tab----tab----tab--unvisited.removeAll(visited);--newline----tab----tab----tab----tab----tab--visited.clear();--newline----tab----tab----tab----tab--}--newline----tab----tab----tab--}//End While--newline----newline----tab----tab----tab--backTrace(end,start);--newline----tab----tab----tab----newline----tab----tab----tab--return results;        --newline----tab--    }--newline----tab--    private void backTrace(String word,String start){--newline----tab--    --tab--if (word.equals(start)){--newline----tab--    --tab----tab--list.add(0,start);--newline----tab--    --tab----tab--results.add(new ArrayList<String>(list));--newline----tab--    --tab----tab--list.remove(0);--newline----tab--    --tab----tab--return;--newline----tab--    --tab--}--newline----tab--    --tab--list.add(0,word);--newline----tab--    --tab--if (map.get(word)!=null)--newline----tab--    --tab----tab--for (String s:map.get(word))--newline----tab--    --tab----tab----tab--backTrace(s,start);--newline----tab--    --tab--list.remove(0);--newline----tab--    }--newline----tab--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share two similar Java solution that Accpted by OJ."
        },
        {
            "java": "public class Solution {--newline--    public List<List<String>> findLadders(String start, String end, List<String> wordList) {--newline--       HashSet<String> dict = new HashSet<String>(wordList);--newline--       List<List<String>> res = new ArrayList<List<String>>();         --newline--       HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node--newline--       HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node--newline--       ArrayList<String> solution = new ArrayList<String>();--newline--    --newline--       dict.add(start);          --newline--       bfs(start, end, dict, nodeNeighbors, distance);                 --newline--       dfs(start, end, dict, nodeNeighbors, distance, solution, res);   --newline--       return res;--newline--    }--newline--    --newline--    // BFS: Trace every node's distance from the start node (level by level).--newline--    private void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {--newline--      for (String str : dict)--newline--          nodeNeighbors.put(str, new ArrayList<String>());--newline--    --newline--      Queue<String> queue = new LinkedList<String>();--newline--      queue.offer(start);--newline--      distance.put(start, 0);--newline--    --newline--      while (!queue.isEmpty()) {--newline--          int count = queue.size();--newline--          boolean foundEnd = false;--newline--          for (int i = 0; i < count; i++) {--newline--              String cur = queue.poll();--newline--              int curDistance = distance.get(cur);                --newline--              ArrayList<String> neighbors = getNeighbors(cur, dict);--newline--    --newline--              for (String neighbor : neighbors) {--newline--                  nodeNeighbors.get(cur).add(neighbor);--newline--                  if (!distance.containsKey(neighbor)) {// Check if visited--newline--                      distance.put(neighbor, curDistance + 1);--newline--                      if (end.equals(neighbor))// Found the shortest path--newline--                          foundEnd = true;--newline--                      else--newline--                          queue.offer(neighbor);--newline--                      }--newline--                  }--newline--              }--newline--    --newline--              if (foundEnd)--newline--                  break;--newline--          }--newline--      }--newline--    --newline--    // Find all next level nodes.    --newline--    private ArrayList<String> getNeighbors(String node, Set<String> dict) {--newline--      ArrayList<String> res = new ArrayList<String>();--newline--      char chs[] = node.toCharArray();--newline--    --newline--      for (char ch ='a'; ch <= 'z'; ch++) {--newline--          for (int i = 0; i < chs.length; i++) {--newline--              if (chs[i] == ch) continue;--newline--              char old_ch = chs[i];--newline--              chs[i] = ch;--newline--              if (dict.contains(String.valueOf(chs))) {--newline--                  res.add(String.valueOf(chs));--newline--              }--newline--              chs[i] = old_ch;--newline--          }--newline--    --newline--      }--newline--      return res;--newline--    }--newline--    --newline--    // DFS: output all paths with the shortest distance.--newline--    private void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {--newline--        solution.add(cur);--newline--        if (end.equals(cur)) {--newline--           res.add(new ArrayList<String>(solution));--newline--        } else {--newline--           for (String next : nodeNeighbors.get(cur)) {            --newline--                if (distance.get(next) == distance.get(cur) + 1) {--newline--                     dfs(next, end, dict, nodeNeighbors, distance, solution, res);--newline--                }--newline--            }--newline--        }           --newline--       solution.remove(solution.size() - 1);--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "My concise JAVA solution based on BFS and DFS"
        },
        {
            "java": "public class Solution {--newline--      public List<List<String>> findLadders(String start, String end, Set<String> dict) {--newline--        // hash set for both ends--newline--        Set<String> set1 = new HashSet<String>();--newline--        Set<String> set2 = new HashSet<String>();--newline--        --newline--        // initial words in both ends--newline--        set1.add(start);--newline--        set2.add(end);--newline--        --newline--        // we use a map to help construct the final result--newline--        Map<String, List<String>> map = new HashMap<String, List<String>>();--newline--        --newline--        // build the map--newline--        helper(dict, set1, set2, map, false);--newline--        --newline--        List<List<String>> res = new ArrayList<List<String>>();--newline--        List<String> sol = new ArrayList<String>(Arrays.asList(start));--newline--        --newline--        // recursively build the final result--newline--        generateList(start, end, map, sol, res);--newline--        --newline--        return res;--newline--      }--newline--      --newline--      boolean helper(Set<String> dict, Set<String> set1, Set<String> set2, Map<String, List<String>> map, boolean flip) {--newline--        if (set1.isEmpty()) {--newline--          return false;--newline--        }--newline--        --newline--        if (set1.size() > set2.size()) {--newline--          return helper(dict, set2, set1, map, !flip);--newline--        }--newline--        --newline--        // remove words on current both ends from the dict--newline--        dict.removeAll(set1);--newline--        dict.removeAll(set2);--newline--        --newline--        // as we only need the shortest paths--newline--        // we use a boolean value help early termination--newline--        boolean done = false;--newline--        --newline--        // set for the next level--newline--        Set<String> set = new HashSet<String>();--newline--        --newline--        // for each string in end 1--newline--        for (String str : set1) {--newline--          for (int i = 0; i < str.length(); i++) {--newline--            char[] chars = str.toCharArray();--newline--            --newline--            // change one character for every position--newline--            for (char ch = 'a'; ch <= 'z'; ch++) {--newline--              chars[i] = ch;--newline--              --newline--              String word = new String(chars);--newline--              --newline--              // make sure we construct the tree in the correct direction--newline--              String key = flip ? word : str;--newline--              String val = flip ? str : word;--newline--                  --newline--              List<String> list = map.containsKey(key) ? map.get(key) : new ArrayList<String>();--newline--                  --newline--              if (set2.contains(word)) {--newline--                done = true;--newline--                --newline--                list.add(val);--newline--                map.put(key, list);--newline--              } --newline--              --newline--              if (!done && dict.contains(word)) {--newline--                set.add(word);--newline--                --newline--                list.add(val);--newline--                map.put(key, list);--newline--              }--newline--            }--newline--          }--newline--        }--newline--        --newline--        // early terminate if done is true--newline--        return done || helper(dict, set2, set, map, !flip);--newline--      }--newline--      --newline--      void generateList(String start, String end, Map<String, List<String>> map, List<String> sol, List<List<String>> res) {--newline--        if (start.equals(end)) {--newline--          res.add(new ArrayList<String>(sol));--newline--          return;--newline--        }--newline--        --newline--        // need this check in case the diff between start and end happens to be one--newline--        // e.g \"a\", \"c\", {\"a\", \"b\", \"c\"}--newline--        if (!map.containsKey(start)) {--newline--          return;--newline--        }--newline--        --newline--        for (String word : map.get(start)) {--newline--          sol.add(word);--newline--          generateList(word, end, map, sol, res);--newline--          sol.remove(sol.size() - 1);--newline--        }--newline--      }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Super fast Java solution (two-end BFS)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    std::vector<std::vector<std::string> > findLadders(std::string beginWord, std::string endWord, std::unordered_set<std::string> &dict) {--newline----tab----tab--std::vector<std::vector<std::string> > paths;--newline----tab----tab--std::vector<std::string> path(1, beginWord);--newline----tab----tab--if (beginWord == endWord) {--newline----tab----tab----tab--paths.push_back(path);--newline----tab----tab----tab--return paths;--newline----tab----tab--}--newline--        std::unordered_set<std::string> words1, words2;--newline----tab----tab--words1.insert(beginWord);--newline----tab----tab--words2.insert(endWord);--newline----tab----tab--std::unordered_map<std::string, std::vector<std::string> > nexts;--newline----tab----tab--bool words1IsBegin = false;--newline--        if (findLaddersHelper(words1, words2, dict, nexts, words1IsBegin))--newline----tab----tab----tab--getPath(beginWord, endWord, nexts, path, paths);--newline----tab----tab--return paths;--newline--    }--newline--private:--newline--    bool findLaddersHelper(--newline----tab----tab--std::unordered_set<std::string> &words1,--newline----tab----tab--std::unordered_set<std::string> &words2,--newline----tab----tab--std::unordered_set<std::string> &dict,--newline----tab----tab--std::unordered_map<std::string, std::vector<std::string> > &nexts,--newline----tab----tab--bool &words1IsBegin) {--newline----tab----tab--words1IsBegin = !words1IsBegin;--newline----tab----tab--if (words1.empty())--newline--            return false;--newline----tab----tab--if (words1.size() > words2.size())--newline----tab----tab----tab--return findLaddersHelper(words2, words1, dict, nexts, words1IsBegin);--newline----tab----tab--for (auto it = words1.begin(); it != words1.end(); ++it)--newline----tab----tab----tab--dict.erase(*it);--newline----tab----tab--for (auto it = words2.begin(); it != words2.end(); ++it)--newline----tab----tab----tab--dict.erase(*it);--newline--        std::unordered_set<std::string> words3;--newline----tab----tab--bool reach = false;--newline--        for (auto it = words1.begin(); it != words1.end(); ++it) {--newline----tab----tab----tab--std::string word = *it;--newline----tab----tab----tab--for (auto ch = word.begin(); ch != word.end(); ++ch) {--newline----tab----tab----tab----tab--char tmp = *ch;--newline--                for (*ch = 'a'; *ch <= 'z'; ++(*ch))--newline----tab----tab----tab----tab----tab--if (*ch != tmp)--newline----tab----tab----tab----tab----tab----tab--if (words2.find(word) != words2.end()) {--newline----tab----tab----tab----tab----tab----tab----tab--reach = true;--newline----tab----tab----tab----tab----tab----tab----tab--words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);--newline----tab----tab----tab----tab----tab----tab--}--newline----tab----tab----tab----tab----tab----tab--else if (!reach && dict.find(word) != dict.end()) {--newline----tab----tab----tab----tab----tab----tab----tab--words3.insert(word);--newline----tab----tab----tab----tab----tab----tab----tab--words1IsBegin ? nexts[*it].push_back(word) : nexts[word].push_back(*it);--newline--                        }--newline----tab----tab----tab----tab--*ch = tmp;--newline--            }--newline--        }--newline--        return reach || findLaddersHelper(words2, words3, dict, nexts, words1IsBegin);--newline--    }--newline----tab--void getPath(--newline----tab----tab--std::string beginWord,--newline----tab----tab--std::string &endWord,--newline----tab----tab--std::unordered_map<std::string, std::vector<std::string> > &nexts,--newline----tab----tab--std::vector<std::string> &path,--newline----tab----tab--std::vector<std::vector<std::string> > &paths) {--newline----tab----tab--if (beginWord == endWord)--newline----tab----tab----tab--paths.push_back(path);--newline----tab----tab--else--newline----tab----tab----tab--for (auto it = nexts[beginWord].begin(); it != nexts[beginWord].end(); ++it) {--newline----tab----tab----tab----tab--path.push_back(*it);--newline----tab----tab----tab----tab--getPath(*it, endWord, nexts, path, paths);--newline----tab----tab----tab----tab--path.pop_back();--newline----tab----tab----tab--}--newline----tab--}--newline--};--newline--",
            "python": null,
            "topic_title": "88ms! Accepted c++ solution with two-end BFS. 68ms for Word Ladder and 88ms for Word Ladder II"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Node;--newline----newline--typedef vector<string> Ladder;--newline--typedef unordered_set<string> StringSet;--newline--typedef bool (*NodeCmper) (Node*, Node*);--newline--typedef set<Node*, NodeCmper> NodeSet;--newline----newline--class Node--newline--{--newline--public:--newline--    string word;--newline--    vector<Node*> parents;--newline----newline--    Node(string w) : word(w) {}--newline--    void addparent(Node* parent) { parents.push_back(parent); }--newline----newline--    // Yield all children of this node, and:--newline--    //   1) If the child is found in $targetlayer, which means we found ladders that--newline--    //      connect BEGIN-WORD and END-WORD, then we get all paths through this node--newline--    //      to its ROOT node, and all paths through the target child node to its ROOT--newline--    //      node, and combine the two group of paths to a group of ladders, and append--newline--    //      these ladders to $ladders.--newline--    //   2) Elif the $ladders is empty:--newline--    //       2.1) If the child is found in $nextlayer, then get that child, and add--newline--    //            this node to its parents.--newline--    //       2.2) Else, add the child to nextlayer, and add this node to its parents.--newline--    //   3) Else, do nothing.--newline--    void yieldchildren(NodeSet& nextlayer, StringSet& wordlist, NodeSet& targetlayer,--newline--                       vector<Ladder>& ladders, bool forward)--newline--    {--newline--        string nextword = word;--newline--        for (int i = 0, n = nextword.length(); i < n; i++) {--newline--            char oldchar = nextword[i];--newline--            for (nextword[i] = 'a'; nextword[i] <= 'z'; nextword[i]++) {--newline--                if (wordlist.count(nextword)) {--newline--                    // now we found a valid child-word, let's yield a child.--newline--                    Node* child = new Node(nextword);--newline--                    yield1(child, nextlayer, targetlayer, ladders, forward);--newline--                }--newline--            }--newline--            nextword[i] = oldchar;--newline--        }--newline--    }--newline----newline--    // yield one child, see comment of function `yieldchildren`--newline--    void yield1(Node* child, NodeSet& nextlayer, NodeSet& targetlayer,--newline--                vector<Ladder>& ladders, bool forward) {--newline--        auto itr = targetlayer.find(child);--newline--        if (itr != targetlayer.end()) {--newline--            for (Ladder path1 : this->getpaths()) {--newline--                for (Ladder path2 : (*itr)->getpaths()) {--newline--                    if (forward) {--newline--                        ladders.push_back(path1);--newline--                        ladders.back().insert(ladders.back().end(), path2.rbegin(), path2.rend());--newline--                    } else {--newline--                        ladders.push_back(path2);--newline--                        ladders.back().insert(ladders.back().end(), path1.rbegin(), path1.rend());--newline--                    }--newline--                }--newline--            }--newline--        } else if (ladders.empty()) {--newline--            auto itr = nextlayer.find(child);--newline--            if (itr != nextlayer.end()) {--newline--                (*itr)->addparent(this);--newline--            } else {--newline--                child->addparent(this);--newline--                nextlayer.insert(child);--newline--            }--newline--        }--newline--    }--newline----newline--    vector<Ladder> getpaths()--newline--    {--newline--        vector<Ladder> ladders;--newline--        if (parents.empty()) {--newline--            ladders.push_back(Ladder(1, word));--newline--        } else {--newline--            for (Node* parent : parents) {--newline--                for (Ladder ladder : parent->getpaths()) {--newline--                    ladders.push_back(ladder);--newline--                    ladders.back().push_back(word);--newline--                }--newline--            }--newline--        }--newline--        return ladders;--newline--    }--newline--};--newline----newline--bool nodecmp(Node* pa, Node* pb)--newline--{--newline--    return pa->word < pb->word;--newline--}--newline----newline--class Solution {--newline--public:--newline--    vector<Ladder> findLadders(string begin, string end, StringSet& wordlist) {--newline--        vector<Ladder> ladders;--newline--        Node headroot(begin), tailroot(end);--newline--        NodeSet frontlayer(nodecmp), backlayer(nodecmp);--newline--        NodeSet *ptr_layerA = &frontlayer, *ptr_layerB = &backlayer;--newline--        bool forward = true;--newline----newline--        if (begin == end) {--newline--            ladders.push_back(Ladder(1, begin));--newline--            return ladders;--newline--        }--newline----newline--        frontlayer.insert(&headroot);--newline--        backlayer.insert(&tailroot);--newline--        wordlist.insert(end);--newline--        while (!ptr_layerA->empty() && !ptr_layerB->empty() && ladders.empty()) {--newline--            NodeSet nextlayer(nodecmp);--newline--            if (ptr_layerA->size() > ptr_layerB->size()) {--newline--                swap(ptr_layerA, ptr_layerB);--newline--                forward = ! forward;--newline--            }--newline--            for (Node* node : *ptr_layerA) {--newline--                wordlist.erase(node->word);--newline--            }--newline--            for (Node* node : *ptr_layerA) {--newline--                node->yieldchildren(nextlayer, wordlist, *ptr_layerB, ladders, forward);--newline--            }--newline--            swap(*ptr_layerA, nextlayer);--newline--        }--newline----newline--        return ladders;--newline--    }--newline--};",
            "python": null,
            "topic_title": "The fastest C++ Solution, 56ms!!"
        }
    ],
    "qc": "126.json"
}