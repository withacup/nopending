{
    "posts": [
        {
            "java": "public class Twitter {--newline--    private static int timeStamp=0;--newline--    --newline--    // easy to find if user exist--newline--    private Map<Integer, User> userMap;--newline--    --newline--    // Tweet link to next Tweet so that we can save a lot of time--newline--    // when we execute getNewsFeed(userId)--newline--    private class Tweet{--newline--        public int id;--newline--        public int time;--newline--        public Tweet next;--newline--        --newline--        public Tweet(int id){--newline--            this.id = id;--newline--            time = timeStamp++;--newline--            next=null;--newline--        }--newline--    }--newline--    --newline--    --newline--    // OO design so User can follow, unfollow and post itself--newline--    public class User{--newline--        public int id;--newline--        public Set<Integer> followed;--newline--        public Tweet tweet_head;--newline--        --newline--        public User(int id){--newline--            this.id=id;--newline--            followed = new HashSet<>();--newline--            follow(id); // first follow itself--newline--            tweet_head = null;--newline--        }--newline--        --newline--        public void follow(int id){--newline--            followed.add(id);--newline--        }--newline--        --newline--        public void unfollow(int id){--newline--            followed.remove(id);--newline--        }--newline--        --newline--        --newline--        // everytime user post a new tweet, add it to the head of tweet list.--newline--        public void post(int id){--newline--            Tweet t = new Tweet(id);--newline--            t.next=tweet_head;--newline--            tweet_head=t;--newline--        }--newline--    }--newline--    --newline--    --newline--    --newline----newline--    /** Initialize your data structure here. */--newline--    public Twitter() {--newline--        userMap = new HashMap<Integer, User>();--newline--    }--newline--    --newline--    /** Compose a new tweet. */--newline--    public void postTweet(int userId, int tweetId) {--newline--        if(!userMap.containsKey(userId)){--newline--            User u = new User(userId);--newline--            userMap.put(userId, u);--newline--        }--newline--        userMap.get(userId).post(tweetId);--newline--            --newline--    }--newline--    --newline----newline--    --newline--    // Best part of this.--newline--    // first get all tweets lists from one user including itself and all people it followed.--newline--    // Second add all heads into a max heap. Every time we poll a tweet with --newline--    // largest time stamp from the heap, then we add its next tweet into the heap.--newline--    // So after adding all heads we only need to add 9 tweets at most into this --newline--    // heap before we get the 10 most recent tweet.--newline--    public List<Integer> getNewsFeed(int userId) {--newline--        List<Integer> res = new LinkedList<>();--newline----newline--        if(!userMap.containsKey(userId))   return res;--newline--        --newline--        Set<Integer> users = userMap.get(userId).followed;--newline--        PriorityQueue<Tweet> q = new PriorityQueue<Tweet>(users.size(), (a,b)->(b.time-a.time));--newline--        for(int user: users){--newline--            Tweet t = userMap.get(user).tweet_head;--newline--            // very imporant! If we add null to the head we are screwed.--newline--            if(t!=null){--newline--                q.add(t);--newline--            }--newline--        }--newline--        int n=0;--newline--        while(!q.isEmpty() && n<10){--newline--          Tweet t = q.poll();--newline--          res.add(t.id);--newline--          n++;--newline--          if(t.next!=null)--newline--            q.add(t.next);--newline--        }--newline--        --newline--        return res;--newline--        --newline--    }--newline--    --newline--    /** Follower follows a followee. If the operation is invalid, it should be a no-op. */--newline--    public void follow(int followerId, int followeeId) {--newline--        if(!userMap.containsKey(followerId)){--newline--            User u = new User(followerId);--newline--            userMap.put(followerId, u);--newline--        }--newline--        if(!userMap.containsKey(followeeId)){--newline--            User u = new User(followeeId);--newline--            userMap.put(followeeId, u);--newline--        }--newline--        userMap.get(followerId).follow(followeeId);--newline--    }--newline--    --newline--    /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */--newline--    public void unfollow(int followerId, int followeeId) {--newline--        if(!userMap.containsKey(followerId) || followerId==followeeId)--newline--            return;--newline--        userMap.get(followerId).unfollow(followeeId);--newline--    }--newline--}--newline----newline--/**--newline-- * Your Twitter object will be instantiated and called as such:--newline-- * Twitter obj = new Twitter();--newline-- * obj.postTweet(userId,tweetId);--newline-- * List<Integer> param_2 = obj.getNewsFeed(userId);--newline-- * obj.follow(followerId,followeeId);--newline-- * obj.unfollow(followerId,followeeId);--newline-- */",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java OO Design with most efficient function getNewsFeed"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Twitter(object):--newline----tab----newline----tab--    def __init__(self):--newline----tab--        self.timer = itertools.count(step=-1)--newline----tab--        self.tweets = collections.defaultdict(collections.deque)--newline----tab--        self.followees = collections.defaultdict(set)--newline----tab----newline----tab--    def postTweet(self, userId, tweetId):--newline----tab--        self.tweets[userId].appendleft((next(self.timer), tweetId))--newline----tab----newline----tab--    def getNewsFeed(self, userId):--newline----tab--        tweets = heapq.merge(*(self.tweets[u] for u in self.followees[userId] | {userId}))--newline----tab--        return [t for _, t in itertools.islice(tweets, 10)]--newline----tab----newline----tab--    def follow(self, followerId, followeeId):--newline----tab--        self.followees[followerId].add(followeeId)--newline----tab----newline----tab--    def unfollow(self, followerId, followeeId):--newline----tab--        self.followees[followerId].discard(followeeId)",
            "topic_title": "Python solution"
        },
        {
            "java": "public class Twitter {--newline--    Map<Integer, Set<Integer>> fans = new HashMap<>();--newline--    Map<Integer, LinkedList<Tweet>> tweets = new HashMap<>();--newline--    int cnt = 0;--newline----newline--    public void postTweet(int userId, int tweetId) {--newline--        if (!fans.containsKey(userId)) fans.put(userId, new HashSet<>());--newline--        fans.get(userId).add(userId);--newline--        if (!tweets.containsKey(userId)) tweets.put(userId, new LinkedList<>());--newline--        tweets.get(userId).addFirst(new Tweet(cnt++, tweetId));--newline--    }--newline----newline--    public List<Integer> getNewsFeed(int userId) {--newline--        if (!fans.containsKey(userId)) return new LinkedList<>();--newline--        PriorityQueue<Tweet> feed = new PriorityQueue<>((t1, t2) -> t2.time - t1.time);--newline--        fans.get(userId).stream()--newline--            .filter(f -> tweets.containsKey(f))--newline--            .forEach(f -> tweets.get(f).forEach(feed::add));--newline--        List<Integer> res = new LinkedList<>();--newline--        while (feed.size() > 0 && res.size() < 10) res.add(feed.poll().id);--newline--        return res;--newline--    }--newline----newline--    public void follow(int followerId, int followeeId) {--newline--        if (!fans.containsKey(followerId)) fans.put(followerId, new HashSet<>());--newline--        fans.get(followerId).add(followeeId);--newline--    }--newline----newline--    public void unfollow(int followerId, int followeeId) {--newline--        if (fans.containsKey(followerId) && followeeId != followerId) fans.get(followerId).remove(followeeId);--newline--    }--newline----newline--    class Tweet {--newline--        int time;--newline--        int id;--newline----newline--        Tweet(int time, int id) {--newline--            this.time = time;--newline--            this.id = id;--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Solutions with Two Maps and PriorityQueue"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Twitter--newline--{--newline--    struct Tweet--newline--    {--newline--        int time;--newline--        int id;--newline--        Tweet(int time, int id) : time(time), id(id) {}--newline--    };--newline----newline--    std::unordered_map<int, std::vector<Tweet>> tweets; // [u] = array of tweets by u--newline--    std::unordered_map<int, std::unordered_set<int>> following; // [u] = array of users followed by u--newline----newline--    int time;--newline----newline--public:--newline--    Twitter() : time(0) {}--newline----newline--    void postTweet(int userId, int tweetId)--newline--    {--newline--        tweets[userId].emplace_back(time++, tweetId);--newline--    }--newline----newline--    std::vector<int> getNewsFeed(int userId)--newline--    {--newline--        std::vector<std::pair<Tweet*, Tweet*>> h; // pair of pointers (begin, current)--newline----newline--        for (auto& u: following[userId])--newline--        {--newline--            auto& t = tweets[u];--newline--            if (t.size() > 0)--newline--                h.emplace_back(t.data(), t.data() + t.size() - 1);--newline--        }--newline--        auto& t = tweets[userId]; // self--newline--        if (t.size() > 0)--newline--            h.emplace_back(t.data(), t.data() + t.size() - 1);--newline----newline--        auto f = [](const std::pair<Tweet*, Tweet*>& x, const std::pair<Tweet*, Tweet*>& y) {--newline--            return x.second->time < y.second->time;--newline--        };--newline--        std::make_heap(h.begin(), h.end(), f);--newline----newline--        const int n = 10;--newline--        std::vector<int> o;--newline--        o.reserve(n);--newline--        for (int i = 0; (i < n) && !h.empty(); ++i)--newline--        {--newline--            std::pop_heap(h.begin(), h.end(), f);--newline----newline--            auto& hb = h.back();--newline--            o.push_back(hb.second->id);--newline----newline--            if (hb.first == hb.second--)--newline--                h.pop_back();--newline--            else--newline--                std::push_heap(h.begin(), h.end(), f);--newline--        }--newline--        return o;--newline--    }--newline----newline--    void follow(int followerId, int followeeId)--newline--    {--newline--        if (followerId != followeeId)--newline--            following[followerId].insert(followeeId);--newline--    }--newline----newline--    void unfollow(int followerId, int followeeId)--newline--    {--newline--        following[followerId].erase(followeeId);--newline--    }--newline--};",
            "python": null,
            "topic_title": "72ms C++ solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "import heapq--newline----newline--class Twitter(object):--newline----tab----newline----tab--    def __init__(self):--newline----tab--        self.time = 0--newline----tab--        self.tweets = {}--newline----tab--        self.followee = {}--newline----tab--        --newline----tab----newline----tab--    def postTweet(self, user, tweet):--newline----tab--        self.time += 1--newline----tab--        self.tweets[user] = self.tweets.get(user, []) + [(-self.time,  tweet)]--newline----tab--        --newline----tab--        --newline----tab----newline----tab--    def getNewsFeed(self, user):--newline----tab--        h, tweets = [], self.tweets--newline----tab--        people = self.followee.get(user, set()) | set([user])--newline----tab--        for person in people:--newline----tab--            if person in tweets and tweets[person]:--newline----tab--                time, tweet = tweets[person][-1]--newline----tab--                h.append((time, tweet, person, len(tweets[person]) - 1))--newline----tab--        heapq.heapify(h)--newline----tab--        news = []--newline----tab--        for _ in range(10):--newline----tab--            if h:--newline----tab--                time, tweet, person, idx = heapq.heappop(h)--newline----tab--                news.append(tweet)--newline----tab--                if idx:--newline----tab--                    new_time, new_tweet = tweets[person][idx-1]--newline----tab--                    heapq.heappush(h, (new_time, new_tweet, person, idx - 1))--newline----tab--        return news--newline----tab--        --newline----tab--        --newline----tab----newline----tab--    def follow(self, follower, other):--newline----tab--        self.followee[follower] = self.followee.get(follower, set()) | set([other])--newline----tab--        --newline----tab--        --newline----tab----newline----tab--    def unfollow(self, follower, other):--newline----tab--        if follower in self.followee:--newline----tab--            self.followee[follower].discard(other)--newline----tab--",
            "topic_title": "Simple and Clean Python code, O(logK) for getting news feed"
        }
    ],
    "qc": "355.json"
}