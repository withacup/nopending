{
    "posts": [
        {
            "java": "class DLinkedNode {--newline----tab--int key;--newline----tab--int value;--newline----tab--DLinkedNode pre;--newline----tab--DLinkedNode post;--newline--}--newline----newline--/**--newline-- * Always add the new node right after head;--newline-- */--newline--private void addNode(DLinkedNode node){--newline----tab--node.pre = head;--newline----tab--node.post = head.post;--newline----tab----newline----tab--head.post.pre = node;--newline----tab--head.post = node;--newline--}--newline----newline--/**--newline-- * Remove an existing node from the linked list.--newline-- */--newline--private void removeNode(DLinkedNode node){--newline----tab--DLinkedNode pre = node.pre;--newline----tab--DLinkedNode post = node.post;--newline----tab----newline----tab--pre.post = post;--newline----tab--post.pre = pre;--newline--}--newline----newline--/**--newline-- * Move certain node in between to the head.--newline-- */--newline--private void moveToHead(DLinkedNode node){--newline----tab--this.removeNode(node);--newline----tab--this.addNode(node);--newline--}--newline----newline--// pop the current tail. --newline--private DLinkedNode popTail(){--newline----tab--DLinkedNode res = tail.pre;--newline----tab--this.removeNode(res);--newline----tab--return res;--newline--}--newline----newline--private Hashtable<Integer, DLinkedNode> --newline----tab--cache = new Hashtable<Integer, DLinkedNode>();--newline--private int count;--newline--private int capacity;--newline--private DLinkedNode head, tail;--newline----newline--public LRUCache(int capacity) {--newline----tab--this.count = 0;--newline----tab--this.capacity = capacity;--newline----newline----tab--head = new DLinkedNode();--newline----tab--head.pre = null;--newline----tab----newline----tab--tail = new DLinkedNode();--newline----tab--tail.post = null;--newline----tab----newline----tab--head.post = tail;--newline----tab--tail.pre = head;--newline--}--newline----newline--public int get(int key) {--newline--    --newline----tab--DLinkedNode node = cache.get(key);--newline----tab--if(node == null){--newline----tab----tab--return -1; // should raise exception here.--newline----tab--}--newline----tab----newline----tab--// move the accessed node to the head;--newline----tab--this.moveToHead(node);--newline----tab----newline----tab--return node.value;--newline--}--newline----newline----newline--public void set(int key, int value) {--newline----tab--DLinkedNode node = cache.get(key);--newline----tab----newline----tab--if(node == null){--newline----tab----tab----newline----tab----tab--DLinkedNode newNode = new DLinkedNode();--newline----tab----tab--newNode.key = key;--newline----tab----tab--newNode.value = value;--newline----tab----tab----newline----tab----tab--this.cache.put(key, newNode);--newline----tab----tab--this.addNode(newNode);--newline----tab----tab----newline----tab----tab--++count;--newline----tab----tab----newline----tab----tab--if(count > capacity){--newline----tab----tab----tab--// pop the tail--newline----tab----tab----tab--DLinkedNode tail = this.popTail();--newline----tab----tab----tab--this.cache.remove(tail.key);--newline----tab----tab----tab----count;--newline----tab----tab--}--newline----tab--}else{--newline----tab----tab--// update the value.--newline----tab----tab--node.value = value;--newline----tab----tab--this.moveToHead(node);--newline----tab--}--newline----tab----newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "&#91;Java&#93; Hashtable + Double linked list (with a touch of pseudo nodes)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "C++11 code 74ms - Hash table + List"
        },
        {
            "java": "public class LRUCache {--newline--    private class Node{--newline--        int key, value;--newline--        Node prev, next;--newline--        Node(int k, int v){--newline--            this.key = k;--newline--            this.value = v;--newline--        }--newline--        Node(){--newline--            this(0, 0);--newline--        }--newline--    }--newline--    private int capacity, count;--newline--    private Map<Integer, Node> map;--newline--    private Node head, tail;--newline--    --newline--    public LRUCache(int capacity) {--newline--        this.capacity = capacity;--newline--        this.count = 0;--newline--        map = new HashMap<>();--newline--        head = new Node();--newline--        tail = new Node();--newline--        head.next = tail;--newline--        tail.prev = head;--newline--    }--newline--    --newline--    public int get(int key) {--newline--        Node n = map.get(key);--newline--        if(null==n){--newline--            return -1;--newline--        }--newline--        update(n);--newline--        return n.value;--newline--    }--newline--    --newline--    public void put(int key, int value) {--newline--        Node n = map.get(key);--newline--        if(null==n){--newline--            n = new Node(key, value);--newline--            map.put(key, n);--newline--            add(n);--newline--            ++count;--newline--        }--newline--        else{--newline--            n.value = value;--newline--            update(n);--newline--        }--newline--        if(count>capacity){--newline--            Node toDel = tail.prev;--newline--            remove(toDel);--newline--            map.remove(toDel.key);--newline--            --count;--newline--        }--newline--    }--newline--    --newline--    private void update(Node node){--newline--        remove(node);--newline--        add(node);--newline--    }--newline--    private void add(Node node){--newline--        Node after = head.next;--newline--        head.next = node;--newline--        node.prev = head;--newline--        node.next = after;--newline--        after.prev = node;--newline--    }--newline--    --newline--    private void remove(Node node){--newline--        Node before = node.prev, after = node.next;--newline--        before.next = after;--newline--        after.prev = before;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Laziest implementation: Java&#x27;s LinkedHashMap takes care of everything"
        },
        {
            "java": "public class LRUCache {--newline--    public LRUCache(int capacity) {--newline--    --tab--this.capicity = capacity;--newline--    --tab--map = new HashMap<>();--newline--    --tab--head = new Node(0, 0);--newline--    --tab--tail = new Node(0, 0);--newline--    --tab--head.next = tail;--newline--    --tab--tail.pre = head;--newline--    --tab--head.pre = null;--newline--    --tab--tail.next = null;--newline--    --tab--count = 0;--newline--    }--newline--    --newline--    public void deleteNode(Node node) {--newline--    --tab--node.pre.next = node.next;--newline--    --tab--node.next.pre = node.pre;--newline--    }--newline--    --newline--    public void addToHead(Node node) {--newline--    --tab--node.next = head.next;--newline--    --tab--node.next.pre = node;--newline--    --tab--node.pre = head;--newline--    --tab--head.next = node;--newline--    }--newline--    --newline--    public int get(int key) {--newline--    --tab--if (map.get(key) != null) {--newline--    --tab----tab--Node node = map.get(key);--newline--    --tab----tab--int result = node.value;--newline--    --tab----tab--deleteNode(node);--newline--    --tab----tab--addToHead(node);--newline--    --tab----tab--return result;--newline--    --tab--}--newline--    --tab--return -1;--newline--    }--newline--    --newline--    public void set(int key, int value) {--newline--    --tab--if (map.get(key) != null) {--newline--    --tab----tab--Node node = map.get(key);--newline--    --tab----tab--node.value = value;--newline--    --tab----tab--deleteNode(node);--newline--    --tab----tab--addToHead(node);--newline--    --tab--} else {--newline--    --tab----tab--Node node = new Node(key, value);--newline--    --tab----tab--map.put(key, node);--newline--    --tab----tab--if (count < capicity) {--newline--    --tab----tab----tab--count++;--newline--    --tab----tab----tab--addToHead(node);--newline--    --tab----tab--} else {--newline--    --tab----tab----tab--map.remove(tail.pre.key);--newline--    --tab----tab----tab--deleteNode(tail.pre);--newline--    --tab----tab----tab--addToHead(node);--newline--    --tab----tab--}--newline--    --tab--}--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA-----------Easy Version To Understand!!!!"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Clean Short Standard C++ solution -- NOT writing C in C++ like all other lengthy ones"
        }
    ],
    "qc": "146.json"
}