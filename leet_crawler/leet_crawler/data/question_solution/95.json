{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<TreeNode> generateTrees(int n) {--newline--        --newline--        return genTrees(1,n);--newline--    }--newline--        --newline--    public List<TreeNode> genTrees (int start, int end)--newline--    {--newline----newline--        List<TreeNode> list = new ArrayList<TreeNode>();--newline----newline--        if(start>end)--newline--        {--newline--            list.add(null);--newline--            return list;--newline--        }--newline--        --newline--        if(start == end){--newline--            list.add(new TreeNode(start));--newline--            return list;--newline--        }--newline--        --newline--        List<TreeNode> left,right;--newline--        for(int i=start;i<=end;i++)--newline--        {--newline--            --newline--            left = genTrees(start, i-1);--newline--            right = genTrees(i+1,end);--newline--            --newline--            for(TreeNode lnode: left)--newline--            {--newline--                for(TreeNode rnode: right)--newline--                {--newline--                    TreeNode root = new TreeNode(i);--newline--                    root.left = lnode;--newline--                    root.right = rnode;--newline--                    list.add(root);--newline--                }--newline--            }--newline--                --newline--        }--newline--        --newline--        return list;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "A simple recursive solution"
        },
        {
            "java": "public class Solution {--newline--    public static List<TreeNode> generateTrees(int n) {--newline--        List<TreeNode>[] result = new List[n + 1];--newline--        result[0] = new ArrayList<TreeNode>();--newline--        if (n == 0) {--newline--            return result[0];--newline--        }--newline--    --newline--        result[0].add(null);--newline--        for (int len = 1; len <= n; len++) {--newline--            result[len] = new ArrayList<TreeNode>();--newline--            for (int j = 0; j < len; j++) {--newline--                for (TreeNode nodeL : result[j]) {--newline--                    for (TreeNode nodeR : result[len - j - 1]) {--newline--                        TreeNode node = new TreeNode(j + 1);--newline--                        node.left = nodeL;--newline--                        node.right = clone(nodeR, j + 1);--newline--                        result[len].add(node);--newline--                    }--newline--                }--newline--            }--newline--        }--newline--        return result[n];--newline--    }--newline--    --newline--    private static TreeNode clone(TreeNode n, int offset) {--newline--        if (n == null) {--newline--            return null;--newline--        }--newline--        TreeNode node = new TreeNode(n.val + offset);--newline--        node.left = clone(n.left, offset);--newline--        node.right = clone(n.right, offset);--newline--        return node;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Solution with DP"
        },
        {
            "java": "public class Solution {--newline--    public List<TreeNode> generateTrees(int n) {--newline--    --tab--return generateSubtrees(1, n);--newline--    }--newline--    --newline--    private List<TreeNode> generateSubtrees(int s, int e) {--newline--    --tab--List<TreeNode> res = new LinkedList<TreeNode>();--newline--    --tab--if (s > e) {--newline--    --tab----tab--res.add(null); // empty tree--newline--    --tab----tab--return res;--newline--    --tab--}--newline--    --newline--    --tab--for (int i = s; i <= e; ++i) {--newline--    --tab----tab--List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);--newline--    --tab----tab--List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);--newline--    --newline--    --tab----tab--for (TreeNode left : leftSubtrees) {--newline--    --tab----tab----tab--for (TreeNode right : rightSubtrees) {--newline--    --tab----tab----tab----tab--TreeNode root = new TreeNode(i);--newline--    --tab----tab----tab----tab--root.left = left;--newline--    --tab----tab----tab----tab--root.right = right;--newline--    --tab----tab----tab----tab--res.add(root);--newline--    --tab----tab----tab--}--newline--    --tab----tab--}--newline--    --tab--}--newline--    --tab--return res;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Divide-and-conquer.  F(i) = G(i-1) * G(n-i)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": " class Solution {--newline--    public:--newline--        TreeNode* clone(TreeNode* root){--newline--            if(root == nullptr)--newline--                return nullptr;--newline--            TreeNode* newroot = new TreeNode(root->val);--newline--            newroot->left = clone(root->left);--newline--            newroot->right = clone(root->right);--newline--            return newroot;--newline--        }--newline--        vector<TreeNode *> generateTrees(int n) {--newline--            vector<TreeNode *> res(1,nullptr);--newline--            for(int i = 1; i <= n; i++){--newline--                vector<TreeNode *> tmp;--newline--                for(int j = 0; j<res.size();j++){--newline--                    TreeNode* oldroot = res[j];--newline--                    TreeNode* root = new TreeNode(i);--newline--                    TreeNode* target = clone(oldroot);--newline--                    root->left = target;--newline--                    tmp.push_back(root);--newline--                   --newline--                    if(oldroot!=nullptr){--newline--                        TreeNode* tmpold = oldroot;--newline--                        while(tmpold->right!=nullptr){--newline--                            TreeNode* nonroot = new TreeNode(i);--newline--                            TreeNode *tright = tmpold->right;--newline--                            tmpold->right = nonroot;--newline--                            nonroot->left = tright;--newline--                            TreeNode *target = clone(oldroot);--newline--                            tmp.push_back(target);--newline--                            tmpold->right = tright;--newline--                            tmpold = tmpold->right;--newline--                        }--newline--                        tmpold->right = new TreeNode(i);--newline--                        TreeNode *target = clone(oldroot);--newline--                        tmp.push_back(target);--newline--                        tmpold->right = nullptr;--newline--                    }--newline--                }--newline--                res=tmp;--newline--            }--newline--            return res;--newline--        }--newline--    };",
            "python": null,
            "topic_title": "Share a C++ DP solution with O(1) space"
        },
        {
            "java": "public class Solution {--newline--        public List<TreeNode> generateTrees(int n) {--newline--            List<TreeNode> res = new ArrayList<>();--newline--            res.add(null);--newline--            for(; n > 0; n--) {--newline--                List<TreeNode> next = new ArrayList<>();--newline--                for(TreeNode node: res) {--newline--                    //the special case when Node(n) is root of new tree--newline--                    TreeNode root = new TreeNode(n); --newline--                    root.right = node;--newline--                    next.add(root);--newline--                   //while loop inserts new value to every possible position into the left tree side--newline--                    while(node != null) {--newline--                        TreeNode cRoot = new TreeNode(root.right.val);--newline--                        //clone left subtree--newline--                        cRoot.left = copyTree(root.right.left);--newline--                        //reusing - point new root.right to the original right subtree--newline--                        cRoot.right = root.right.right;--newline--                        //curr is the cutoff node whose right child will be replaced by the new n --newline--                        TreeNode curr = getValNode(cRoot, node.val); --newline--                        //place n as curr's right child, make curr's original right child as the left child of n.--newline--                        TreeNode tmp = curr.left;--newline--                        curr.left = new TreeNode(n);--newline--                        curr.left.right = tmp;--newline--    --newline--                        next.add(cRoot);--newline--                        node = node.left;--newline--                    }--newline--                }--newline--                res = next;--newline--            }--newline--            return res;--newline--        }--newline--        private TreeNode getValNode(TreeNode n, int val) { //find the cutoff node in the new tree--newline--            while(n != null) {--newline--                if(n.val == val) break;--newline--                n = n.left;--newline--            }--newline--            return n;--newline--        }--newline--    --newline--        private TreeNode copyTree(TreeNode root) { //clone the right subtree--newline--            if(root == null) return null;--newline--            TreeNode cRoot = new TreeNode(root.val);--newline--            cRoot.left = copyTree(root.left);--newline--            cRoot.right = copyTree(root.right);--newline--            return cRoot;--newline--        }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA DP Solution and Brute Force Recursive Solution."
        }
    ],
    "qc": "95.json"
}