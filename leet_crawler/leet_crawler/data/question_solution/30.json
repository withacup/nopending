{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--        // travel all the words combinations to maintain a window--newline--        // there are wl(word len) times travel--newline--        // each time, n/wl words, mostly 2 times travel for each word--newline--        // one left side of the window, the other right side of the window--newline--        // so, time complexity O(wl * 2 * N/wl) = O(2N)--newline--        vector<int> findSubstring(string S, vector<string> &L) {--newline--            vector<int> ans;--newline--            int n = S.size(), cnt = L.size();--newline--            if (n <= 0 || cnt <= 0) return ans;--newline--            --newline--            // init word occurence--newline--            unordered_map<string, int> dict;--newline--            for (int i = 0; i < cnt; ++i) dict[L[i]]++;--newline--            --newline--            // travel all sub string combinations--newline--            int wl = L[0].size();--newline--            for (int i = 0; i < wl; ++i) {--newline--                int left = i, count = 0;--newline--                unordered_map<string, int> tdict;--newline--                for (int j = i; j <= n - wl; j += wl) {--newline--                    string str = S.substr(j, wl);--newline--                    // a valid word, accumulate results--newline--                    if (dict.count(str)) {--newline--                        tdict[str]++;--newline--                        if (tdict[str] <= dict[str]) --newline--                            count++;--newline--                        else {--newline--                            // a more word, advance the window left side possiablly--newline--                            while (tdict[str] > dict[str]) {--newline--                                string str1 = S.substr(left, wl);--newline--                                tdict[str1]--;--newline--                                if (tdict[str1] < dict[str1]) count--;--newline--                                left += wl;--newline--                            }--newline--                        }--newline--                        // come to a result--newline--                        if (count == cnt) {--newline--                            ans.push_back(left);--newline--                            // advance one word--newline--                            tdict[S.substr(left, wl)]--;--newline--                            count--;--newline--                            left += wl;--newline--                        }--newline--                    }--newline--                    // not a valid word, reset all vars--newline--                    else {--newline--                        tdict.clear();--newline--                        count = 0;--newline--                        left = j + wl;--newline--                    }--newline--                }--newline--            }--newline--            --newline--            return ans;--newline--        }--newline--}",
            "python": null,
            "topic_title": "An O(N) solution with detailed explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<int> findSubstring(string s, vector<string>& words) {--newline--        unordered_map<string, int> counts;--newline--        for (string word : words)--newline--            counts[word]++;--newline--        int n = s.length(), num = words.size(), len = words[0].length();--newline--        vector<int> indexes;--newline--        for (int i = 0; i < n - num * len + 1; i++) {--newline--            unordered_map<string, int> seen;--newline--            int j = 0;--newline--            for (; j < num; j++) {--newline--                string word = s.substr(i + j * len, len);--newline--                if (counts.find(word) != counts.end()) {--newline--                    seen[word]++;--newline--                    if (seen[word] > counts[word])--newline--                        break;--newline--                } --newline--                else break;--newline--            }--newline--            if (j == num) indexes.push_back(i);--newline--        }--newline--        return indexes;--newline--    }--newline--};",
            "python": null,
            "topic_title": "Naive C++ Solution using two unordered_map (about 20 lines)"
        },
        {
            "java": "public class Solution {--newline--    public List<Integer> findSubstring(String s, String[] words) {--newline--    --tab--int N = s.length();--newline--    --tab--List<Integer> indexes = new ArrayList<Integer>(s.length());--newline--    --tab--if (words.length == 0) {--newline--    --tab----tab--return indexes;--newline--    --tab--}--newline--    --tab--int M = words[0].length();--newline--    --tab--if (N < M * words.length) {--newline--    --tab----tab--return indexes;--newline--    --tab--}--newline--    --tab--int last = N - M + 1;--newline--    --tab----newline--    --tab--//map each string in words array to some index and compute target counters--newline--    --tab--Map<String, Integer> mapping = new HashMap<String, Integer>(words.length);--newline--    --tab--int [][] table = new int[2][words.length];--newline--    --tab--int failures = 0, index = 0;--newline--    --tab--for (int i = 0; i < words.length; ++i) {--newline--    --tab----tab--Integer mapped = mapping.get(words[i]);--newline--    --tab----tab--if (mapped == null) {--newline--    --tab----tab----tab--++failures;--newline--    --tab----tab----tab--mapping.put(words[i], index);--newline--    --tab----tab----tab--mapped = index++;--newline--    --tab----tab--}--newline--    --tab----tab--++table[0][mapped];--newline--    --tab--}--newline--    --tab----newline--    --tab--//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array--newline--    --tab--int [] smapping = new int[last];--newline--    --tab--for (int i = 0; i < last; ++i) {--newline--    --tab----tab--String section = s.substring(i, i + M);--newline--    --tab----tab--Integer mapped = mapping.get(section);--newline--    --tab----tab--if (mapped == null) {--newline--    --tab----tab----tab--smapping[i] = -1;--newline--    --tab----tab--} else {--newline--    --tab----tab----tab--smapping[i] = mapped;--newline--    --tab----tab--}--newline--    --tab--}--newline--    --tab----newline--    --tab--//fix the number of linear scans--newline--    --tab--for (int i = 0; i < M; ++i) {--newline--    --tab----tab--//reset scan variables--newline--    --tab----tab--int currentFailures = failures; //number of current mismatches--newline--    --tab----tab--int left = i, right = i;--newline--    --tab----tab--Arrays.fill(table[1], 0);--newline--    --tab----tab--//here, simple solve the minimum-window-substring problem--newline--    --tab----tab--while (right < last) {--newline--    --tab----tab----tab--while (currentFailures > 0 && right < last) {--newline--    --tab----tab----tab----tab--int target = smapping[right];--newline--    --tab----tab----tab----tab--if (target != -1 && ++table[1][target] == table[0][target]) {--newline--    --tab----tab----tab----tab----tab----currentFailures;--newline--    --tab----tab----tab----tab--}--newline--    --tab----tab----tab----tab--right += M;--newline--    --tab----tab----tab--}--newline--    --tab----tab----tab--while (currentFailures == 0 && left < right) {--newline--    --tab----tab----tab----tab--int target = smapping[left];--newline--    --tab----tab----tab----tab--if (target != -1 && --table[1][target] == table[0][target] - 1) {--newline--    --tab----tab----tab----tab----tab--int length = right - left;--newline--    --tab----tab----tab----tab----tab--//instead of checking every window, we know exactly the length we want--newline--    --tab----tab----tab----tab----tab--if ((length / M) ==  words.length) {--newline--    --tab----tab----tab----tab----tab----tab--indexes.add(left);--newline--    --tab----tab----tab----tab----tab--}--newline--    --tab----tab----tab----tab----tab--++currentFailures;--newline--    --tab----tab----tab----tab--}--newline--    --tab----tab----tab----tab--left += M;--newline--    --tab----tab----tab--}--newline--    --tab----tab--}--newline--    --tab----tab----newline--    --tab--}--newline--    --tab--return indexes;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Accepted Java solution 12ms with explanation"
        },
        {
            "java": "public class Solution {--newline--    public static List<Integer> findSubstring(String S, String[] L) {--newline--        List<Integer> res = new ArrayList<Integer>();--newline--        if (S == null || L == null || L.length == 0) return res;--newline--        int len = L[0].length(); // length of each word--newline--        --newline--        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L--newline--        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);--newline--        --newline--        for (int i = 0; i <= S.length() - len * L.length; i++) {--newline--            Map<String, Integer> copy = new HashMap<String, Integer>(map);--newline--            for (int j = 0; j < L.length; j++) { // checkc if match--newline--                String str = S.substring(i + j*len, i + j*len + len); // next word--newline--                if (copy.containsKey(str)) { // is in remaining words--newline--                    int count = copy.get(str);--newline--                    if (count == 1) copy.remove(str);--newline--                    else copy.put(str, count - 1);--newline--                    if (copy.isEmpty()) { // matches--newline--                        res.add(i);--newline--                        break;--newline--                    }--newline--                } else break; // not in L--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Simple Java Solution with Two Pointers and Map"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--// The general idea:--newline--// Construct a hash function f for L, f: vector<string> -> int, --newline--// Then use the return value of f to check whether a substring is a concatenation --newline--// of all words in L.--newline--// f has two levels, the first level is a hash function f1 for every single word in L.--newline--// f1 : string -> double--newline--// So with f1, L is converted into a vector of float numbers--newline--// Then another hash function f2 is defined to convert a vector of doubles into a single int.--newline--// Finally f(L) := f2(f1(L))--newline--// To obtain lower complexity, we require f1 and f2 can be computed through moving window.--newline--// The following corner case also needs to be considered:--newline--// f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))--newline--// There are many possible options for f2 and f1. --newline--// The following code only shows one possibility (probably not the best), --newline--// f2 is the function \"hash\" in the class,--newline--// f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )--newline--public:--newline--    // The complexity of this function is O(nW).--newline--    double hash(double f, double code[], string &word) {--newline--        double result = 0.;--newline--        for (auto &c : word) result = result * f + code[c];--newline--        return result;--newline--    }--newline--    vector<int> findSubstring(string S, vector<string> &L) {--newline--        uniform_real_distribution<double> unif(0., 1.);--newline--        default_random_engine seed;--newline--        double code[128];--newline--        for (auto &d : code) d = unif(seed);--newline--        double f = unif(seed) / 5. + 0.8;--newline--        double value = 0;--newline----newline--        // The complexity of the following for loop is O(L.size( ) * nW).--newline--        for (auto &str : L) value += log(hash(f, code, str));--newline----newline--        int unit = 1e9;--newline--        int key = (value-floor(value))*unit;--newline--        int nS = S.size(), nL = L.size(), nW = L[0].size();--newline--        double fn = pow(f, nW-1.);--newline--        vector<int> result;--newline--        if (nS < nW) return result;--newline--        vector<double> values(nS-nW+1);--newline--        string word(S.begin(), S.begin()+nW);--newline--        values[0] = hash(f, code, word);--newline----newline--        // Use a moving window to hash every word with length nW in S to a float number, --newline--        // which is stored in vector values[]--newline--        // The complexity of this step is O(nS).--newline--        for (int i=1; i<=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]];--newline----newline--        // This for loop will run nW times, each iteration has a complexity O(nS/nW)--newline--        // So the overall complexity is O(nW * (nS / nW)) = O(nS)--newline--        for (int i=0; i<nW; ++i) {--newline--            int j0=i, j1=i, k=0;--newline--            double sum = 0.;--newline----newline--            // Use a moving window to hash every L.size() continuous words with length nW in S.--newline--            // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW,--newline--            // So the complexity of this while loop is O(nS / nW).--newline--            while(j1<=nS-nW) {--newline--                sum += log(values[j1]);--newline--                ++k;--newline--                j1 += nW;--newline--                if (k==nL) {--newline--                    int key1 = (sum-floor(sum)) * unit;--newline--                    if (key1==key) result.push_back(j0);--newline--                    sum -= log(values[j0]);--newline--                    --k;--newline--                    j0 += nW;--newline--                }--newline--            }--newline--        }--newline--        return result;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "My AC c++ code, O(n) complexity, 26ms"
        }
    ],
    "qc": "30.json"
}