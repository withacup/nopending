{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<Point> outerTrees(Point[] points) {--newline--        Set<Point> result = new HashSet<>();--newline--        --newline--        // Find the leftmost point--newline--        Point first = points[0];--newline--        int firstIndex = 0;--newline--        for (int i = 1; i < points.length; i++) {--newline--            if (points[i].x < first.x) {--newline--                first = points[i];--newline--                firstIndex = i;--newline--            }--newline--        }--newline--        result.add(first);--newline--        --newline--        Point cur = first;--newline--        int curIndex = firstIndex;--newline--        do {--newline--            Point next = points[0];--newline--            int nextIndex = 0;--newline--            for (int i = 1; i < points.length; i++) {--newline--                if (i == curIndex) continue;--newline--                int cross = crossProductLength(cur, points[i], next);--newline--                if (nextIndex == curIndex || cross > 0 ||--newline--                        // Handle collinear points--newline--                        (cross == 0 && distance(points[i], cur) > distance(next, cur))) {--newline--                    next = points[i];--newline--                    nextIndex = i;--newline--                }--newline--            }--newline--            // Handle collinear points--newline--            for (int i = 0; i < points.length; i++) {--newline--                if (i == curIndex) continue;--newline--                int cross = crossProductLength(cur, points[i], next);--newline--                if (cross == 0) {--newline--                    result.add(points[i]);--newline--                }--newline--            }--newline----newline--            cur = next;--newline--            curIndex = nextIndex;--newline--            --newline--        } while (curIndex != firstIndex);--newline--        --newline--        return new ArrayList<Point>(result);--newline--    }--newline--    --newline--    private int crossProductLength(Point A, Point B, Point C) {--newline--        // Get the vectors' coordinates.--newline--        int BAx = A.x - B.x;--newline--        int BAy = A.y - B.y;--newline--        int BCx = C.x - B.x;--newline--        int BCy = C.y - B.y;--newline--    --newline--        // Calculate the Z coordinate of the cross product.--newline--        return (BAx * BCy - BAy * BCx);--newline--    }--newline----newline--    private int distance(Point p1, Point p2) {--newline--        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Solution, Convex Hull Algorithm - Gift wrapping aka Jarvis march"
        },
        {
            "java": "public class Solution {--newline----newline--    public List<Point> outerTrees(Point[] points) {--newline--        if (points.length <= 1)--newline--            return Arrays.asList(points);--newline--        sortByPolar(points, bottomLeft(points));--newline--        Stack<Point> stack = new Stack<>(); --newline--        stack.push(points[0]);                      --newline--        stack.push(points[1]);                              --newline--        for (int i = 2; i < points.length; i++) {--newline--            Point top = stack.pop();                                --newline--            while (ccw(stack.peek(), top, points[i]) < 0)--newline--                top = stack.pop();--newline--            stack.push(top);--newline--            stack.push(points[i]);--newline--        }       --newline--        return new ArrayList<>(stack);--newline--    }                               --newline----newline--    private static Point bottomLeft(Point[] points) {--newline--        Point bottomLeft = points[0];--newline--        for (Point p : points)          --newline--            if (p.y < bottomLeft.y || p.y == bottomLeft.y && p.x < bottomLeft.x)--newline--                bottomLeft = p;                 --newline--        return bottomLeft;                                                  --newline--    }--newline----newline--    /**--newline--     * @return positive if counter-clockwise, negative if clockwise, 0 if collinear--newline--     */--newline--    private static int ccw(Point a, Point b, Point c) {--newline--        return a.x * b.y - a.y * b.x + b.x * c.y - b.y * c.x + c.x * a.y - c.y * a.x;       --newline--    }--newline----newline--    /**--newline--     * @return distance square of |p - q|--newline--     */--newline--    private static int dist(Point p, Point q) {--newline--        return (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);--newline--    }--newline--                              --newline--    private static void sortByPolar(Point[] points, Point r) {--newline--        Arrays.sort(points, (p, q) -> {--newline--            int compPolar = ccw(p, r, q);--newline--            int compDist = dist(p, r) - dist(q, r); --newline--            return compPolar == 0 ? compDist : compPolar;--newline--        });     --newline--        // find collinear points in the end positions--newline--        Point p = points[0], q = points[points.length - 1];--newline--        int i = points.length - 2;--newline--        while (i >= 0 && ccw(p, q, points[i]) == 0)--newline--            i--;    --newline--        // reverse sort order of collinear points in the end positions--newline--        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {--newline--            Point tmp = points[l];--newline--            points[l] = points[h];--newline--            points[h] = tmp;--newline--        }--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Graham scan with adapted sorting to deal with collinear points"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def outerTrees(self, A):--newline----tab--        def sign(p, q, r):--newline----tab--            return cmp((p.x - r.x)*(q.y - r.y), (p.y - r.y)*(q.x - r.x))--newline----tab--        --newline----tab--        def drive(hull, r):--newline----tab--            hull.append(r)--newline----tab--            while len(hull) >= 3 and sign(*hull[-3:]) < 0:--newline----tab--                hull.pop(-2)--newline----tab--            return hull--newline----tab--        --newline----tab--        A.sort(key = lambda p: (p.x, p.y))--newline----tab--        lower = reduce(drive, A, [])--newline----tab--        upper = reduce(drive, A[::-1], [])--newline----tab--        return list(set(lower + upper))--newline----tab--    ",
            "topic_title": "Python, AM Chain with Explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "// Ref: http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.cpp--newline--class Solution {--newline-- public:--newline--  typedef int coord_t;  // coordinate type--newline--  typedef long long coord2_t;  // must be big enough to hold 2*max(|coordinate|)^2--newline--  // 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross--newline--  // product. Returns a positive value, if OAB makes a counter-clockwise turn,--newline--  // negative for clockwise turn, and zero if the points are collinear.--newline--  coord2_t cross(const Point &O, const Point &A, const Point &B) {--newline--    return (A.x - O.x) * (coord2_t)(B.y - O.y) ---newline--           (A.y - O.y) * (coord2_t)(B.x - O.x);--newline--  }--newline----newline--  static bool cmp(Point &p1, Point &p2) {--newline--    return p1.x < p2.x || (p1.x == p2.x && p1.y < p2.y);--newline--  }--newline----newline--  static bool equ(Point &p1, Point &p2) { return p1.x == p2.x && p1.y == p2.y; }--newline--  // Returns a list of points on the convex hull in counter-clockwise order.--newline--  // Note: the last point in the returned list is the same as the first one.--newline--  vector<Point> outerTrees(vector<Point> &P) {--newline--    int n = P.size(), k = 0;--newline--    vector<Point> H(2 * n);--newline----newline--    // Sort points lexicographically--newline--    sort(P.begin(), P.end(), cmp);--newline----newline--    // Build lower hull--newline--    for (int i = 0; i < n; i++) {--newline--      while (k >= 2 && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;--newline--      H[k++] = P[i];--newline--    }--newline----newline--    // Build upper hull--newline--    for (int i = n - 2, t = k + 1; i >= 0; i--) {--newline--      while (k >= t && cross(H[k - 2], H[k - 1], P[i]) < 0) k--;--newline--      H[k++] = P[i];--newline--    }--newline----newline--    // Remove duplicates--newline--    H.resize(k);--newline--    sort(H.begin(), H.end(), cmp);--newline--    H.erase(unique(H.begin(), H.end(), equ), H.end());--newline--    return H;--newline--  }--newline--};--newline--",
            "python": "# http://www.algorithmist.com/index.php/Monotone_Chain_Convex_Hull.py--newline----newline----newline--class Solution(object):--newline----tab----newline----tab--    def outerTrees(self, points):--newline----tab--        \"\"\"Computes the convex hull of a set of 2D points.--newline----tab----newline----tab--        Input: an iterable sequence of (x, y) pairs representing the points.--newline----tab--        Output: a list of vertices of the convex hull in counter-clockwise order,--newline----tab--          starting from the vertex with the lexicographically smallest coordinates.--newline----tab--        Implements Andrew's monotone chain algorithm. O(n log n) complexity.--newline----tab--        \"\"\"--newline----tab----newline----tab--        # Sort the points lexicographically (tuples are compared lexicographically).--newline----tab--        # Remove duplicates to detect the case we have just one unique point.--newline----tab--        # points = sorted(set(points))--newline----tab--        points = sorted(points, key=lambda p: (p.x, p.y))--newline----tab----newline----tab--        # Boring case: no points or a single point, possibly repeated multiple times.--newline----tab--        if len(points) <= 1:--newline----tab--            return points--newline----tab----newline----tab--        # 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.--newline----tab--        # Returns a positive value, if OAB makes a counter-clockwise turn,--newline----tab--        # negative for clockwise turn, and zero if the points are collinear.--newline----tab--        def cross(o, a, b):--newline----tab--            # return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])--newline----tab--            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)--newline----tab----newline----tab--        # Build lower hull--newline----tab--        lower = []--newline----tab--        for p in points:--newline----tab--            while len(lower) >= 2 and cross(lower[-2], lower[-1], p) < 0:--newline----tab--                lower.pop()--newline----tab--            lower.append(p)--newline----tab----newline----tab--        # Build upper hull--newline----tab--        upper = []--newline----tab--        for p in reversed(points):--newline----tab--            while len(upper) >= 2 and cross(upper[-2], upper[-1], p) < 0:--newline----tab--                upper.pop()--newline----tab--            upper.append(p)--newline----tab----newline----tab--        # Concatenation of the lower and upper hulls gives the convex hull.--newline----tab--        # Last point of each list is omitted because it is repeated at the--newline----tab--        # beginning of the other list.--newline----tab--        # return lower[:-1] + upper[:-1]--newline----tab--        return list(set(lower[:-1] + upper[:-1]))--newline----tab--",
            "topic_title": "C++ and Python easy wiki solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def outerTrees(self, points):--newline----tab--            from scipy.spatial import ConvexHull--newline----tab--            import numpy as np--newline----tab--    --newline----tab--            def isHull(point, hull, tol=1e-12):--newline----tab--                return any((abs(np.dot(eq[:-1], point) + eq[-1]) < tol) for eq in hull.equations)--newline----tab--            try:--newline----tab--                hull = ConvexHull([(p.x, p.y) for p in points])--newline----tab--                return [p for p in points if isHull((p.x, p.y), hull)]--newline----tab--            except:--newline----tab--                return points",
            "topic_title": "Find convex hull using scipy with explanation"
        }
    ],
    "qc": "587.json"
}