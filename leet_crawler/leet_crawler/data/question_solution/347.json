{
    "posts": [
        {
            "java": "public class Solution {--newline--    public List<Integer> topKFrequent(int[] nums, int k) {--newline--    --newline--    --tab--List<Integer>[] bucket = new List[nums.length + 1];--newline--    --tab--Map<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();--newline--    --newline--    --tab--for (int n : nums) {--newline--    --tab----tab--frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);--newline--    --tab--}--newline--    --newline--    --tab--for (int key : frequencyMap.keySet()) {--newline--    --tab----tab--int frequency = frequencyMap.get(key);--newline--    --tab----tab--if (bucket[frequency] == null) {--newline--    --tab----tab----tab--bucket[frequency] = new ArrayList<>();--newline--    --tab----tab--}--newline--    --tab----tab--bucket[frequency].add(key);--newline--    --tab--}--newline--    --newline--    --tab--List<Integer> res = new ArrayList<>();--newline--    --newline--    --tab--for (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {--newline--    --tab----tab--if (bucket[pos] != null) {--newline--    --tab----tab----tab--res.addAll(bucket[pos]);--newline--    --tab----tab--}--newline--    --tab--}--newline--    --tab--return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java O(n) Solution - Bucket Sort"
        },
        {
            "java": "// use an array to save numbers into different bucket whose index is the frequency--newline--public class Solution {--newline--    public List<Integer> topKFrequent(int[] nums, int k) {--newline--        Map<Integer, Integer> map = new HashMap<>();--newline--        for(int n: nums){--newline--            map.put(n, map.getOrDefault(n,0)+1);--newline--        }--newline--        --newline--        // corner case: if there is only one number in nums, we need the bucket has index 1.--newline--        List<Integer>[] bucket = new List[nums.length+1];--newline--        for(int n:map.keySet()){--newline--            int freq = map.get(n);--newline--            if(bucket[freq]==null)--newline--                bucket[freq] = new LinkedList<>();--newline--            bucket[freq].add(n);--newline--        }--newline--        --newline--        List<Integer> res = new LinkedList<>();--newline--        for(int i=bucket.length-1; i>0 && k>0; --i){--newline--            if(bucket[i]!=null){--newline--                List<Integer> list = bucket[i]; --newline--                res.addAll(list);--newline--                k-= list.size();--newline--            }--newline--        }--newline--        --newline--        return res;--newline--    }--newline--}--newline----newline----newline----newline--// use maxHeap. Put entry into maxHeap so we can always poll a number with largest frequency--newline--public class Solution {--newline--    public List<Integer> topKFrequent(int[] nums, int k) {--newline--        Map<Integer, Integer> map = new HashMap<>();--newline--        for(int n: nums){--newline--            map.put(n, map.getOrDefault(n,0)+1);--newline--        }--newline--           --newline--        PriorityQueue<Map.Entry<Integer, Integer>> maxHeap = --newline--                         new PriorityQueue<>((a,b)->(b.getValue()-a.getValue()));--newline--        for(Map.Entry<Integer,Integer> entry: map.entrySet()){--newline--            maxHeap.add(entry);--newline--        }--newline--        --newline--        List<Integer> res = new ArrayList<>();--newline--        while(res.size()<k){--newline--            Map.Entry<Integer, Integer> entry = maxHeap.poll();--newline--            res.add(entry.getKey());--newline--        }--newline--        return res;--newline--    }--newline--}--newline----newline----newline----newline--// use treeMap. Use freqncy as the key so we can get all freqencies in order--newline--public class Solution {--newline--    public List<Integer> topKFrequent(int[] nums, int k) {--newline--        Map<Integer, Integer> map = new HashMap<>();--newline--        for(int n: nums){--newline--            map.put(n, map.getOrDefault(n,0)+1);--newline--        }--newline--        --newline--        TreeMap<Integer, List<Integer>> freqMap = new TreeMap<>();--newline--        for(int num : map.keySet()){--newline--           int freq = map.get(num);--newline--           if(!freqMap.containsKey(freq)){--newline--               freqMap.put(freq, new LinkedList<>());--newline--           }--newline--           freqMap.get(freq).add(num);--newline--        }--newline--        --newline--        List<Integer> res = new ArrayList<>();--newline--        while(res.size()<k){--newline--            Map.Entry<Integer, List<Integer>> entry = freqMap.pollLastEntry();--newline--            res.addAll(entry.getValue());--newline--        }--newline--        return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "3 Java Solution using Array, MaxHeap, TreeMap"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<int> topKFrequent(vector<int>& nums, int k) {--newline--        unordered_map<int,int> map;--newline--        for(int num : nums){--newline--            map[num]++;--newline--        }--newline--        --newline--        vector<int> res;--newline--        // pair<first, second>: first is frequency,  second is number--newline--        priority_queue<pair<int,int>> pq; --newline--        for(auto it = map.begin(); it != map.end(); it++){--newline--            pq.push(make_pair(it->second, it->first));--newline--            if(pq.size() > (int)map.size() - k){--newline--                res.push_back(pq.top().second);--newline--                pq.pop();--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ O(n log(n-k)) unordered_map and priority_queue(maxheap) solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<int> topKFrequent(vector<int>& nums, int k) {--newline--        vector<int> res;--newline--        if (!nums.size()) return res;--newline--        unordered_map<int, int> cnt;--newline--        for (auto num : nums) cnt[num]++;--newline--        vector<vector<int>> bucket(nums.size() + 1);--newline--        for (auto kv : cnt) {--newline--            bucket[kv.second].push_back(kv.first);--newline--        }--newline----newline--        for (int i = bucket.size() - 1; i >= 0; --i) {--newline--            for (int j = 0; j < bucket[i].size(); ++j){--newline--                res.push_back(bucket[i][j]);--newline--                if (res.size() == k) return res;--newline--            }--newline--        }--newline----newline--        return res;--newline--    }--newline--};",
            "python": null,
            "topic_title": "3 ways to solve this problem"
        },
        {
            "java": "public class Solution {--newline--    public List<Integer> topKFrequent(int[] nums, int k) {--newline--        Map<Integer, Integer> counterMap = new HashMap<>();--newline--        for(int num : nums) {--newline--            int count = counterMap.getOrDefault(num, 0);--newline--            counterMap.put(num, count+1);--newline--        }--newline--        --newline--        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> a.getValue()-b.getValue());--newline--        for(Map.Entry<Integer, Integer> entry : counterMap.entrySet()) {--newline--            pq.offer(entry);--newline--            if(pq.size() > k) pq.poll();--newline--        }--newline--        --newline--        List<Integer> res = new LinkedList<>();--newline--        while(!pq.isEmpty()) {--newline--            res.add(0, pq.poll().getKey());--newline--        }--newline--        return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "*Java* straightforward O(N + (N-k)lg k) solution"
        }
    ],
    "qc": "347.json"
}