{
    "posts": [
        {
            "java": "public class Solution {--newline--    public void solveSudoku(char[][] board) {--newline--        if(board == null || board.length == 0)--newline--            return;--newline--        solve(board);--newline--    }--newline--    --newline--    public boolean solve(char[][] board){--newline--        for(int i = 0; i < board.length; i++){--newline--            for(int j = 0; j < board[0].length; j++){--newline--                if(board[i][j] == '.'){--newline--                    for(char c = '1'; c <= '9'; c++){//trial. Try 1 through 9--newline--                        if(isValid(board, i, j, c)){--newline--                            board[i][j] = c; //Put c for this cell--newline--                            --newline--                            if(solve(board))--newline--                                return true; //If it's the solution return true--newline--                            else--newline--                                board[i][j] = '.'; //Otherwise go back--newline--                        }--newline--                    }--newline--                    --newline--                    return false;--newline--                }--newline--            }--newline--        }--newline--        return true;--newline--    }--newline--    --newline--    private boolean isValid(char[][] board, int row, int col, char c){--newline--        for(int i = 0; i < 9; i++) {--newline--            if(board[i][col] != '.' && board[i][col] == c) return false; //check row--newline--            if(board[row][i] != '.' && board[row][i] == c) return false; //check column--newline--            if(board[3 * (row / 3) + i / 3][ 3 * (col / 3) + i % 3] != '.' && --newline--board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; //check 3*3 block--newline--        }--newline--        return true;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Straight Forward Java Solution Using Backtracking"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline----tab--struct cell // encapsulates a single cell on a Sudoku board--newline----tab--{--newline----tab----tab--uint8_t value; // cell value 1..9 or 0 if unset--newline----tab----tab--// number of possible (unconstrained) values for the cell--newline----tab----tab--uint8_t numPossibilities;--newline----tab----tab--// if bitset[v] is 1 then value can't be v--newline----tab----tab--bitset<10> constraints;--newline----tab----tab--cell() : value(0), numPossibilities(9),constraints() {};--newline----tab--};--newline----tab--array<array<cell,9>,9> cells;--newline----newline----tab--// sets the value of the cell to [v]--newline----tab--// the function also propagates constraints to other cells and deduce new values where possible--newline----tab--bool set(int i, int j, int v)--newline----tab--{ --newline----tab----tab--// updating state of the cell--newline----tab----tab--cell& c = cells[i][j];--newline----tab----tab--if (c.value == v)--newline----tab----tab----tab--return true;--newline----tab----tab--if (c.constraints[v])--newline----tab----tab----tab--return false;--newline----tab----tab--c.constraints = bitset<10>(0x3FE); // all 1s--newline----tab----tab--c.constraints.reset(v);--newline----tab----tab--c.numPossibilities = 1;--newline----tab----tab--c.value = v;--newline----newline----tab----tab--// propagating constraints--newline----tab----tab--for (int k = 0; k<9; k++) {--newline----tab----tab----tab--// to the row: --newline----tab----tab----tab--if (i != k && !updateConstraints(k, j, v))--newline----tab----tab----tab----tab--return false;--newline----tab----tab----tab--// to the column:--newline----tab----tab----tab--if (j != k && !updateConstraints(i, k, v))--newline----tab----tab----tab----tab--return false;--newline----tab----tab----tab--// to the 3x3 square:--newline----tab----tab----tab--int ix = (i / 3) * 3 + k / 3;--newline----tab----tab----tab--int jx = (j / 3) * 3 + k % 3;--newline----tab----tab----tab--if (ix != i && jx != j && !updateConstraints(ix, jx, v))--newline----tab----tab----tab----tab--return false;--newline----tab----tab--}--newline----tab----tab--return true;--newline----tab--}--newline----tab--// update constraints of the cell i,j by excluding possibility of 'excludedValue'--newline----tab--// once there's one possibility left the function recurses back into set()--newline----tab--bool updateConstraints(int i, int j, int excludedValue)--newline----tab--{--newline----tab----tab--cell& c = cells[i][j];--newline----tab----tab--if (c.constraints[excludedValue]) {--newline----tab----tab----tab--return true;--newline----tab----tab--}--newline----tab----tab--if (c.value == excludedValue) {--newline----tab----tab----tab--return false;--newline----tab----tab--}--newline----tab----tab--c.constraints.set(excludedValue);--newline----tab----tab--if (--c.numPossibilities > 1)--newline----tab----tab----tab--return true;--newline----tab----tab--for (int v = 1; v <= 9; v++) {--newline----tab----tab----tab--if (!c.constraints[v]) {--newline----tab----tab----tab----tab--return set(i, j, v);--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--assert(false);--newline----tab--}--newline----newline----tab--// backtracking state - list of empty cells--newline----tab--vector<pair<int, int>> bt;--newline----newline----tab--// find values for empty cells--newline----tab--bool findValuesForEmptyCells()--newline----tab--{--newline----tab----tab--// collecting all empty cells--newline----tab----tab--bt.clear();--newline----tab----tab--for (int i = 0; i < 9; i++) {--newline----tab----tab----tab--for (int j = 0; j < 9; j++) {--newline----tab----tab----tab----tab--if (!cells[i][j].value)--newline----tab----tab----tab----tab----tab--bt.push_back(make_pair(i, j));--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--// making backtracking efficient by pre-sorting empty cells by numPossibilities--newline----tab----tab--sort(bt.begin(), bt.end(), [this](const pair<int, int>&a, const pair<int, int>&b) {--newline----tab----tab----tab--return cells[a.first][a.second].numPossibilities < cells[b.first][b.second].numPossibilities; });--newline----tab----tab--return backtrack(0);--newline----tab--}--newline----newline----tab--// Finds value for all empty cells with index >=k--newline----tab--bool backtrack(int k)--newline----tab--{--newline----tab----tab--if (k >= bt.size())--newline----tab----tab----tab--return true;--newline----tab----tab--int i = bt[k].first;--newline----tab----tab--int j = bt[k].second;--newline----tab----tab--// fast path - only 1 possibility--newline----tab----tab--if (cells[i][j].value)--newline----tab----tab----tab--return backtrack(k + 1);--newline----tab----tab--auto constraints = cells[i][j].constraints;--newline----tab----tab--// slow path >1 possibility.--newline----tab----tab--// making snapshot of the state--newline----tab----tab--array<array<cell,9>,9> snapshot(cells);--newline----tab----tab--for (int v = 1; v <= 9; v++) {--newline----tab----tab----tab--if (!constraints[v]) {--newline----tab----tab----tab----tab--if (set(i, j, v)) {--newline----tab----tab----tab----tab----tab--if (backtrack(k + 1))--newline----tab----tab----tab----tab----tab----tab--return true;--newline----tab----tab----tab----tab--}--newline----tab----tab----tab----tab--// restoring from snapshot,--newline----tab----tab----tab----tab--// note: computationally this is cheaper--newline----tab----tab----tab----tab--// than alternative implementation with undoing the changes--newline----tab----tab----tab----tab--cells = snapshot;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return false;--newline----tab--}--newline--public:--newline----tab--void solveSudoku(vector<vector<char>> &board) {--newline----tab----tab--cells = array<array<cell,9>,9>(); // clear array--newline----tab----tab--// Decoding input board into the internal cell matrix.--newline----tab----tab--// As we do it - constraints are propagated and even additional values are set as we go--newline----tab----tab--// (in the case if it is possible to unambiguously deduce them).--newline----tab----tab--for (int i = 0; i < 9; i++)--newline----tab----tab--{--newline----tab----tab----tab--for (int j = 0; j < 9; j++) {--newline----tab----tab----tab----tab--if (board[i][j] != '.' && !set(i, j, board[i][j] - '0'))--newline----tab----tab----tab----tab----tab--return; // sudoku is either incorrect or unsolvable--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--// if we're lucky we've already got a solution,--newline----tab----tab--// however, if we have empty cells we need to use backtracking to fill them--newline----tab----tab--if (!findValuesForEmptyCells())--newline----tab----tab----tab--return; // sudoku is unsolvable--newline----newline----tab----tab--// copying the solution back to the board--newline----tab----tab--for (int i = 0; i < 9; i++)--newline----tab----tab--{--newline----tab----tab----tab--for (int j = 0; j < 9; j++) {--newline----tab----tab----tab----tab--if (cells[i][j].value)--newline----tab----tab----tab----tab----tab--board[i][j] = cells[i][j].value + '0';--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab--}--newline--};--newline--",
            "python": null,
            "topic_title": "Sharing my 2ms C++ solution with comments and explanations."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    // Original author: Hsien Loong Lee (http://bit.ly/1zfIGMc)--newline--    // Slight modification by @1337c0d3r to adapt to run on LeetCode OJ.--newline--    // https://leetcode.com/problems/sudoku-solver/--newline--    int InBlock[81], InRow[81], InCol[81];--newline--    --newline--    const int BLANK = 0;--newline--    const int ONES = 0x3fe; --tab--// Binary 1111111110--newline--    --newline--    int Entry[81];--tab--// Records entries 1-9 in the grid, as the corresponding bit set to 1--newline--    int Block[9], Row[9], Col[9];--tab--// Each int is a 9-bit array--newline--    --newline--    int SeqPtr = 0;--newline--    int Sequence[81];--newline--    --newline--    --newline--    --newline--    void SwapSeqEntries(int S1, int S2)--newline--    {--newline--         int temp = Sequence[S2];--newline--         Sequence[S2] = Sequence[S1];--newline--         Sequence[S1] = temp;--newline--    }--newline--    --newline--    --newline--    void InitEntry(int i, int j, int val)--newline--    {--newline--    --tab-- int Square = 9 * i + j;--newline--    --tab-- int valbit = 1 << val;--newline--         int SeqPtr2;--newline--    --newline--         // add suitable checks for data consistency--newline--         --newline--    --tab-- Entry[Square] = valbit;--newline--    --tab-- Block[InBlock[Square]] &= ~valbit;--newline--    --tab-- Col[InCol[Square]] &= ~valbit; // Simpler Col[j] &= ~valbit;--newline--    --tab-- Row[InRow[Square]] &= ~valbit; // Simpler Row[i] &= ~valbit;--newline--    --newline--         SeqPtr2 = SeqPtr;--newline--         while (SeqPtr2 < 81 && Sequence[SeqPtr2] != Square)--newline--               SeqPtr2++ ;--newline--    --newline--         SwapSeqEntries(SeqPtr, SeqPtr2);--newline--         SeqPtr++;--newline--    }--newline--    --newline--    --newline--    void PrintArray(char **board)--newline--    {--newline--         int i, j, valbit, val, Square;--newline--         char ch;--newline--         --newline--         Square = 0;--newline--    --newline--         for (i = 0; i < 9; i++) {--newline--             for (j = 0; j < 9; j++) {--newline--                 valbit = Entry[Square++];--newline--                 if (valbit == 0) ch = '-';--newline--                 else {--newline--                     for (val = 1; val <= 9; val++) --newline--                         if (valbit == (1 << val)) {--newline--                            ch = '0' + val;--newline--                            break;--newline--                         }--newline--                 }    --newline--                 board[i][j] = ch;--newline--             }--newline--         }--newline--    }--newline--    --newline--    --newline--    int NextSeq(int S)--newline--    {--newline--        int S2, Square, Possibles, BitCount;--newline--        int T, MinBitCount = 100;--newline--    --newline--        for (T = S; T < 81; T++) {--newline--            Square = Sequence[T];--newline--            Possibles = Block[InBlock[Square]] & Row[InRow[Square]] & Col[InCol[Square]];--newline--            BitCount = 0;--newline--            while (Possibles) {--newline--               Possibles &= ~(Possibles & -Possibles);--newline--               BitCount++;--newline--            }--newline--    --newline--            if (BitCount < MinBitCount) {--newline--               MinBitCount = BitCount;--newline--               S2 = T;--newline--            }--newline--        }--newline--    --newline--        return S2;--newline--    }--newline--    --newline--    --newline--    void Place(int S, char** board)--newline--    {--newline--        if (S >= 81) {--newline--            PrintArray(board);--newline--            return;--newline--        }--newline--    --newline--        int S2 = NextSeq(S);--newline--        SwapSeqEntries(S, S2);--newline--    --newline--        int Square = Sequence[S];--newline--    --newline--        int --tab--BlockIndex = InBlock[Square],--newline--    --tab----tab----tab--RowIndex = InRow[Square],--newline--    --tab----tab----tab--ColIndex = InCol[Square];--newline--    --newline--        int --tab--Possibles = Block[BlockIndex] & Row[RowIndex] & Col[ColIndex];--newline--        while (Possibles) {--newline--              int valbit = Possibles & (-Possibles); // Lowest 1 bit in Possibles--newline--              Possibles &= ~valbit;--newline--              Entry[Square] = valbit;--newline--              Block[BlockIndex] &= ~valbit;--newline--              Row[RowIndex] &= ~valbit;--newline--              Col[ColIndex] &= ~valbit;--newline--    --tab----tab----tab----tab----newline--              Place(S + 1, board);--newline--    --newline--              Entry[Square] = BLANK; // Could be moved out of the loop--newline--              Block[BlockIndex] |= valbit;--newline--              Row[RowIndex] |= valbit;--newline--              Col[ColIndex] |= valbit;--newline--    --tab--}--newline--    --newline--        SwapSeqEntries(S, S2);--newline--    }--newline--    --newline--    void solveSudoku(char **board, int m, int n) {--newline--        SeqPtr = 0;--newline--        int i, j, Square;--newline--    --newline--    --tab--for (i = 0; i < 9; i++)--newline--    --tab----tab--for (j = 0; j < 9; j++) {--newline--    --tab----tab----tab--Square = 9 * i + j;--newline--    --tab----tab----tab--InRow[Square] = i;--newline--    --tab----tab----tab--InCol[Square] = j;--newline--    --tab----tab----tab--InBlock[Square] = (i / 3) * 3 + ( j / 3);--newline--    --tab----tab--}--newline--    --newline--    --newline--    --tab--for (Square = 0; Square < 81; Square++) {--newline--            Sequence[Square] = Square;--newline--    --tab----tab--Entry[Square] = BLANK;--newline--        }--newline--        --newline--    --tab--for (i = 0; i < 9; i++) --newline--    --tab----tab--Block[i] = Row[i] = Col[i] = ONES;--newline--        --newline--        for (int i = 0; i < 9; ++i)--newline--           for (int j = 0; j < 9; ++j) {--newline--               if ('.' != board[i][j])--newline--                    InitEntry(i, j, board[i][j] - '0');--newline--           }--newline--           --newline--        Place(SeqPtr, board);--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "Singapore prime minister Lee Hsien Loong&#x27;s Sudoku Solver code runs in 1ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    bool check(vector<vector<char>> &board, int i, int j, char val)--newline--    {--newline--        int row = i - i%3, column = j - j%3;--newline--        for(int x=0; x<9; x++) if(board[x][j] == val) return false;--newline--        for(int y=0; y<9; y++) if(board[i][y] == val) return false;--newline--        for(int x=0; x<3; x++)--newline--        for(int y=0; y<3; y++)--newline--            if(board[row+x][column+y] == val) return false;--newline--        return true;--newline--    }--newline--    bool solveSudoku(vector<vector<char>> &board, int i, int j)--newline--    {--newline--        if(i==9) return true;--newline--        if(j==9) return solveSudoku(board, i+1, 0);--newline--        if(board[i][j] != '.') return solveSudoku(board, i, j+1);--newline--    --newline--        for(char c='1'; c<='9'; c++)--newline--        {--newline--            if(check(board, i, j, c))--newline--            {--newline--                board[i][j] = c;--newline--                if(solveSudoku(board, i, j+1)) return true;--newline--                board[i][j] = '.';--newline--            }--newline--        }--newline--            --newline--        return false;--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "Simple and Clean Solution &#x2F; C++"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline----tab--bool isValidSudoku(vector<vector<char> > &board) {--newline----tab----tab--return true;--newline----tab--}--newline----tab--void solveSudoku(vector<vector<char> > &board) {--newline----tab----tab--util(board, 0);--newline----tab--}--newline----tab--bool util(vector<vector<char>>& board, int pos)--newline----tab--{--newline----tab----tab--if (pos >= 81)--newline----tab----tab----tab--return true;--newline----tab----tab--int i = pos / 9;--newline----tab----tab--int j = pos % 9;--newline----tab----tab--if (board[i][j] != '.')--newline----tab----tab----tab--return util(board, pos + 1);--newline----tab----tab--else--newline----tab----tab--{--newline----tab----tab----tab--for (char c = '1'; c <= '9'; c++)--newline----tab----tab----tab--{--newline----tab----tab----tab----tab--if (!isInRow(board, i,c) && !isInCol(board, j, c) && !isInRec(board, i, j, c))--newline----tab----tab----tab----tab--{--newline----tab----tab----tab----tab----tab--board[i][j] = c;--newline----tab----tab----tab----tab----tab--if (util(board, pos + 1))--newline----tab----tab----tab----tab----tab----tab--return true;--newline----tab----tab----tab----tab----tab--else--newline----tab----tab----tab----tab----tab----tab--board[i][j] = '.';--newline----tab----tab----tab----tab--}--newline----tab----tab----tab--}--newline----tab----tab----tab--return false;--newline----tab----tab--}--newline----tab--}--newline----newline----tab--bool isInRow(vector<vector<char>>& board, int i, char c)--newline----tab--{--newline----tab----tab--vector<char>& row = board[i];--newline----tab----tab--for (int k = 0; k < 9; k++)--newline----tab----tab--{--newline----tab----tab----tab--if (row[k] == c)--newline----tab----tab----tab----tab--return true;--newline----tab----tab--}--newline----tab----tab--return false;--newline----tab--}--newline----tab--bool isInCol(vector<vector<char>>& board,int j, char c)--newline----tab--{--newline----tab----tab--for (int k = 0; k < 9; k++)--newline----tab----tab--{--newline----tab----tab----tab--if (board[k][j] == c)--newline----tab----tab----tab----tab--return true;--newline----tab----tab--}--newline----tab----tab--return false;--newline----tab--}--newline----tab--bool isInRec(vector<vector<char>>& board, int i, int j, char c)--newline----tab--{--newline----tab----tab--int bigrow = i / 3, bigcol = j / 3;--newline----tab----tab--for (int m = 3 * bigrow; m < 3 * (bigrow + 1); m++)--newline----tab----tab--{--newline----tab----tab----tab--for (int n = 3 * bigcol; n < 3 * (bigcol + 1); n++)--newline----tab----tab----tab----tab--if (board[m][n] == c)--newline----tab----tab----tab----tab----tab--return true;--newline----tab----tab--}--newline----tab----tab--return false;--newline----tab--}--newline--};",
            "python": null,
            "topic_title": "A simple DFS solution"
        }
    ],
    "qc": "37.json"
}