{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int findRotateSteps(String ring, String key) {--newline--        int n = ring.length();--newline--        int m = key.length();--newline--        int[][] dp = new int[m + 1][n];--newline--        --newline--        for (int i = m - 1; i >= 0; i--) {--newline--            for (int j = 0; j < n; j++) {--newline--                dp[i][j] = Integer.MAX_VALUE;--newline--                for (int k = 0; k < n; k++) {--newline--                    if (ring.charAt(k) == key.charAt(i)) {--newline--                        int diff = Math.abs(j - k);--newline--                        int step = Math.min(diff, n - diff);--newline--                        dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);--newline--                    }--newline--                }--newline--            }--newline--        }--newline--        --newline--        return dp[0][0] + m;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Concise Java DP Solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int findRotateSteps(string ring, string key) {--newline--        int size = ring.size();--newline--        int ksize = key.size();--newline--        vector<vector<int>> mp(26);   //Optimazed_1 use vector instead of unordered_map--newline--            //stored index of each ,pay attention to duplcate characters.--newline--        for(int i=0;i<size;++i){--newline--            mp[ring[i]-'a'].push_back(i);--newline--        }--newline--        --newline--        vector<int> dp (size,INT_MAX);   //Optimazed_2,use less space --newline--        dp[0] = 0;--newline--        --newline--        vector<int> startIndex(1,0);// starting index--newline----newline--        for(int i=1;i<=ksize;++i){--newline--            vector<int> nextDp(size,INT_MAX);--newline--            for(auto it:mp[key[i-1]-'a']){--newline--                for(int j=0;j<startIndex.size();++j){--newline--                    int minDist = min((startIndex[j] + size -it)%size,(it + size - startIndex[j])%size) + dp[startIndex[j]];// Look at the above explanation--newline--                    nextDp[it] =min(nextDp[it],minDist);--newline--                }--newline--            }--newline--            startIndex = mp[key[i-1]-'a'];--newline--            dp = nextDp;--newline--        }--newline--        --newline--        int res = INT_MAX;--newline--        for(int i=0;i<size;++i){--newline--            res = min(res,dp[i]);--newline--        }  // get the smallest value(step)--newline--        --newline--        return res + ksize;--newline--    }--newline--};--newline----newline--",
            "python": null,
            "topic_title": "Shared my C++ dp solution ,19ms"
        },
        {
            "java": "public class Solution {--newline--    Map<String, Map<Integer, Integer>> memo;--newline--    public int findRotateSteps(String ring, String key) {--newline--        memo = new HashMap<>();--newline--        return dfs(ring, key, 0);--newline--    }--newline--    --newline--    private int findPos(String ring, char ch){ // find first occurrence clockwise--newline--        return ring.indexOf(ch);--newline--    }--newline--    --newline--    private int findBackPos(String ring, char ch){ //find first occurrence  anti-clockwise--newline--        if(ring.charAt(0) == ch) return 0;--newline--        for(int i = ring.length()-1;i>0;i--){--newline--            if(ring.charAt(i) == ch) return i;--newline--        }--newline--        return 0;--newline--    }--newline--    --newline--    private int dfs(String ring, String key, int i){--newline--        if(i == key.length()) return 0;--newline--        int res = 0;--newline--        char ch = key.charAt(i);--newline--        if(memo.containsKey(ring) && memo.get(ring).containsKey(i)) return memo.get(ring).get(i);--newline--        int f = findPos(ring, ch);--newline--        int b = findBackPos(ring, ch);--newline--        int forward = 1+f+dfs(ring.substring(f)+ring.substring(0, f), key, i+1);--newline--        int back = 1+ring.length()-b + dfs(ring.substring(b)+ring.substring(0, b),key, i+1);--newline--        res = Math.min(forward, back);--newline--        Map<Integer, Integer> ans = memo.getOrDefault(ring, new HashMap<>());--newline--        ans.put(i, res);--newline--        memo.put(ring, ans);--newline--        return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Clear Solution, dfs+memoization"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def findRotateSteps(self, ring, key):--newline----tab--        n = len(ring)--newline----tab--        #the distance between two points (i, j) on the ring--newline----tab--        def dist(i, j):--newline----tab--            return min(abs(i - j), n - abs(i - j))--newline----tab--        #build the position list for each character in ring    --newline----tab--        h = {}--newline----tab--        for i in xrange(n):--newline----tab--            a = ring[i]--newline----tab--            if a in h: h[a].append(i)--newline----tab--            else: h[a] = [i]--newline----tab--        --newline----tab--        pcl_pre = [[0,0]] #list of possible previous position of the ring and the cost--newline----tab--        for k in key:--newline----tab--            pl_k = h[k] #obtain the location list of character k--newline----tab--            pcl_next = [[p, 0] for p in pl_k] #list of possible next position of the ring and the cost--newline----tab--            --newline----tab--            for pc_next in pcl_next:--newline----tab--                p_next = pc_next[0] #next possible position--newline----tab--                #Find minimum cost to p_next--newline----tab--                cmin = dist(p_next, pcl_pre[0][0]) + pcl_pre[0][1]--newline----tab--                for pc_pre in pcl_pre:--newline----tab--                    cmin = min(cmin, dist(p_next, pc_pre[0]) + pc_pre[1])--newline----tab--                pc_next[1] = cmin--newline----tab--            --newline----tab--            pcl_pre = pcl_next--newline----tab--        --newline----tab--        #Find the min cost for all possible end positions--newline----tab--        cmin = pcl_pre[0][1]--newline----tab--        for pc in pcl_pre:--newline----tab--            cmin = min(cmin, pc[1])--newline----tab--        return len(key) + cmin--newline----tab--",
            "topic_title": "Python Solution (222 ms)"
        },
        {
            "java": "// by fallcreek--newline--public class Solution {--newline--    public int findRotateSteps(String ring, String key) {        --newline--        int[][] dp = new int[ring.length()][key.length()];--newline--        for(int[] line : dp)    Arrays.fill(line, -1);--newline--        --newline--        return helper(ring, 0, key, 0, dp) + key.length();--newline--    }--newline--    --newline--    public int helper(String ring, int rIndex, String key, int kIndex, int[][] dp){--newline--        if(kIndex == key.length()) return 0;--newline--        if(dp[rIndex][kIndex] != -1) return dp[rIndex][kIndex];--newline--        --newline--        char dest = key.charAt(kIndex);--newline--        --newline--        int nextIndex = ring.indexOf(dest);--newline--        int sol = Integer.MAX_VALUE;--newline--        do{--newline--            int move = Math.min(Math.abs(rIndex - nextIndex), ring.length() - Math.abs(rIndex - nextIndex));--newline--            int remain = helper(ring, nextIndex, key, kIndex + 1, dp);--newline--            sol = Math.min(sol, move + remain);--newline--            nextIndex = ring.indexOf(dest, nextIndex + 1);--newline--        }while(nextIndex != -1);--newline--        dp[rIndex][kIndex] = sol;--newline--        return sol;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA DP with explanation"
        }
    ],
    "qc": "514.json"
}