{
    "posts": [
        {
            "java": "public class LFUCache {--newline--    private Node head = null;--newline--    private int cap = 0;--newline--    private HashMap<Integer, Integer> valueHash = null;--newline--    private HashMap<Integer, Node> nodeHash = null;--newline--    --newline--    public LFUCache(int capacity) {--newline--        this.cap = capacity;--newline--        valueHash = new HashMap<Integer, Integer>();--newline--        nodeHash = new HashMap<Integer, Node>();--newline--    }--newline--    --newline--    public int get(int key) {--newline--        if (valueHash.containsKey(key)) {--newline--            increaseCount(key);--newline--            return valueHash.get(key);--newline--        }--newline--        return -1;--newline--    }--newline--    --newline--    public void put(int key, int value) {--newline--        if ( cap == 0 ) return;--newline--        if (valueHash.containsKey(key)) {--newline--            valueHash.put(key, value);--newline--        } else {--newline--            if (valueHash.size() < cap) {--newline--                valueHash.put(key, value);--newline--            } else {--newline--                removeOld();--newline--                valueHash.put(key, value);--newline--            }--newline--            addToHead(key);--newline--        }--newline--        increaseCount(key);--newline--    }--newline--    --newline--    private void addToHead(int key) {--newline--        if (head == null) {--newline--            head = new Node(0);--newline--            head.keys.add(key);--newline--        } else if (head.count > 0) {--newline--            Node node = new Node(0);--newline--            node.keys.add(key);--newline--            node.next = head;--newline--            head.prev = node;--newline--            head = node;--newline--        } else {--newline--            head.keys.add(key);--newline--        }--newline--        nodeHash.put(key, head);      --newline--    }--newline--    --newline--    private void increaseCount(int key) {--newline--        Node node = nodeHash.get(key);--newline--        node.keys.remove(key);--newline--        --newline--        if (node.next == null) {--newline--            node.next = new Node(node.count+1);--newline--            node.next.prev = node;--newline--            node.next.keys.add(key);--newline--        } else if (node.next.count == node.count+1) {--newline--            node.next.keys.add(key);--newline--        } else {--newline--            Node tmp = new Node(node.count+1);--newline--            tmp.keys.add(key);--newline--            tmp.prev = node;--newline--            tmp.next = node.next;--newline--            node.next.prev = tmp;--newline--            node.next = tmp;--newline--        }--newline----newline--        nodeHash.put(key, node.next);--newline--        if (node.keys.size() == 0) remove(node);--newline--    }--newline--    --newline--    private void removeOld() {--newline--        if (head == null) return;--newline--        int old = 0;--newline--        for (int n: head.keys) {--newline--            old = n;--newline--            break;--newline--        }--newline--        head.keys.remove(old);--newline--        if (head.keys.size() == 0) remove(head);--newline--        nodeHash.remove(old);--newline--        valueHash.remove(old);--newline--    }--newline--    --newline--    private void remove(Node node) {--newline--        if (node.prev == null) {--newline--            head = node.next;--newline--        } else {--newline--            node.prev.next = node.next;--newline--        } --newline--        if (node.next != null) {--newline--            node.next.prev = node.prev;--newline--        }--newline--    }--newline--    --newline--    class Node {--newline--        public int count = 0;--newline--        public LinkedHashSet<Integer> keys = null;--newline--        public Node prev = null, next = null;--newline--        --newline--        public Node(int count) {--newline--            this.count = count;--newline--            keys = new LinkedHashSet<Integer>();--newline--            prev = next = null;--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java O(1) Accept Solution Using HashMap, DoubleLinkedList and LinkedHashSet"
        },
        {
            "java": "public class LFUCache {--newline--    HashMap<Integer, Integer> vals;--newline--    HashMap<Integer, Integer> counts;--newline--    HashMap<Integer, LinkedHashSet<Integer>> lists;--newline--    int cap;--newline--    int min = -1;--newline--    public LFUCache(int capacity) {--newline--        cap = capacity;--newline--        vals = new HashMap<>();--newline--        counts = new HashMap<>();--newline--        lists = new HashMap<>();--newline--        lists.put(1, new LinkedHashSet<>());--newline--    }--newline--    --newline--    public int get(int key) {--newline--        if(!vals.containsKey(key))--newline--            return -1;--newline--        int count = counts.get(key);--newline--        counts.put(key, count+1);--newline--        lists.get(count).remove(key);--newline--        if(count==min && lists.get(count).size()==0)--newline--            min++;--newline--        if(!lists.containsKey(count+1))--newline--            lists.put(count+1, new LinkedHashSet<>());--newline--        lists.get(count+1).add(key);--newline--        return vals.get(key);--newline--    }--newline--    --newline--    public void put(int key, int value) {--newline--        if(cap<=0)--newline--            return;--newline--        if(vals.containsKey(key)) {--newline--            vals.put(key, value);--newline--            get(key);--newline--            return;--newline--        } --newline--        if(vals.size() >= cap) {--newline--            int evit = lists.get(min).iterator().next();--newline--            lists.get(min).remove(evit);--newline--            vals.remove(evit);--newline--        }--newline--        vals.put(key, value);--newline--        counts.put(key, 1);--newline--        min = 1;--newline--        lists.get(1).add(key);--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA O(1) very easy solution using 3 HashMaps and LinkedHashSet"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Concise C++ O(1) solution using 3 hash maps with explanation"
        },
        {
            "java": "public class LFUCache {--newline--    --newline--    class Cache implements Comparable<Cache> {--newline--        int key, f, r;--newline--        public Cache(int k, int f, int r) {key=k;this.f=f;this.r=r;}--newline--        public boolean equals(Object object) {return key==((Cache) object).key;}--newline--        public int hashCode() {return key;}--newline--        public int compareTo(Cache o) {return key==o.key?0:f==o.f?r-o.r:f-o.f;}--newline--    }--newline----newline--    int capacity,id;--newline--    HashMap<Integer, Integer> hashMap;--newline--    HashMap<Integer, Cache> caches;--newline--    TreeSet<Cache> treeSet;--newline----newline--    public LFUCache(int capacity) {--newline--        this.capacity=capacity;--newline--        id=0;--newline--        hashMap=new HashMap<>();--newline--        caches=new HashMap<>();--newline--        treeSet=new TreeSet<>();--newline--    }--newline----newline--    public int get(int key) {--newline--        id++;--newline--        if (hashMap.containsKey(key)) {--newline--            update(key);--newline--            return hashMap.get(key);--newline--        }--newline--        return -1;--newline--    }--newline----newline--    public void put(int key, int value) {--newline--        if (capacity==0) return;--newline--        id++;--newline--        if (hashMap.containsKey(key)) {--newline--            update(key);--newline--            hashMap.put(key, value);--newline--            return;--newline--        }--newline--        if (hashMap.size()==capacity) {--newline--            Cache first=treeSet.pollFirst();--newline--            hashMap.remove(first.key);--newline--            caches.remove(first.key);--newline--        }--newline--        hashMap.put(key, value);--newline--        Cache cache=new Cache(key, 1, id);--newline--        caches.put(key, cache);--newline--        treeSet.add(cache);--newline--    }--newline----newline--    private void update(int key) {--newline--        int f=caches.get(key).f;--newline--        treeSet.remove(caches.get(key));--newline--        Cache cache=new Cache(key, f+1, id);--newline--        caches.put(key, cache);--newline--        treeSet.add(cache);--newline--    }--newline----newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using PriorityQueue, with detailed explanation"
        },
        {
            "java": "private int capacity;--newline--private int count;--newline--private HashMap<Integer, Tuple> map1; // whether appeared--newline--private HashMap<Integer, Tuple> finalNodes; // value : the final node of key times--newline--private Tuple dummyHead;--newline--private Tuple dummyEnd;--newline----newline--public LFUCache(int capacity) {--newline--    this.capacity = capacity;--newline--    count = 0;--newline--    map1 = new HashMap<Integer, Tuple>();--newline--    finalNodes = new HashMap<>();--newline--    dummyHead = new Tuple(0, 0, 0);--newline--    dummyEnd = new Tuple(0, 0, 0);--newline--    dummyHead.next = dummyEnd;--newline--    dummyEnd.prev = dummyHead;--newline--}--newline----newline--public int get(int key) {--newline--    if (capacity == 0 || !map1.containsKey(key)) {--newline--        return -1;--newline--    }--newline--    Tuple old = map1.get(key);--newline--    set(key, old.value);--newline--    return old.value;--newline--}--newline----newline--public void put(int key, int value) {--newline--    if (capacity == 0) {--newline--        return;--newline--    }--newline--    if (map1.containsKey(key)) { // this key has appeared--newline--        Tuple cur = map1.get(key);--newline--        if (finalNodes.get(cur.times) == cur && finalNodes.get(cur.times + 1) == null) { // the position should not change--newline--            finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);--newline--            cur.times++;--newline--            cur.value = value;--newline--            finalNodes.put(cur.times, cur);--newline--            return;--newline--        }--newline--        removeNode(cur); // remove node cur--newline--        if (finalNodes.get(cur.times) == cur) {--newline--            finalNodes.put(cur.times, cur.prev.times == cur.times ? cur.prev : null);--newline--        }--newline--        cur.times++;--newline--        cur.value = value;--newline--        Tuple finalNode = finalNodes.get(cur.times) == null ? finalNodes.get(cur.times - 1) : finalNodes.get(cur.times);--newline--        insertNode(finalNode, cur); --newline--        finalNodes.put(cur.times, cur); // cur is the final node whitch appeared cur.times--newline--    } else if (count == capacity) { // reach limt of the cache--newline--        Tuple head = dummyHead.next;--newline--        removeNode(head); //remove the first which appeared least times and is the least Used--newline--        map1.remove(head.key);--newline--        if (finalNodes.get(head.times) == head) {--newline--            finalNodes.remove(head.times);--newline--        }--newline--        Tuple cur = new Tuple(key, value, 1);--newline--        if (finalNodes.get(1) == null) {--newline--            insertNode(dummyHead, cur);--newline--        } else {--newline--            Tuple finalNode = finalNodes.get(1);--newline--            insertNode(finalNode, cur);--newline--        }--newline--        finalNodes.put(1, cur);--newline--        map1.put(key, cur);--newline--    } else {--newline--        count++;--newline--        Tuple cur = new Tuple(key, value, 1);--newline--        if (finalNodes.get(1) == null){--newline--           insertNode(dummyHead, cur);--newline--        } else {--newline--            Tuple finalNode = finalNodes.get(1);--newline--            insertNode(finalNode, cur);--newline--        }--newline--        finalNodes.put(1, cur);--newline--        map1.put(key, cur);--newline--    }--newline--}--newline----newline--public void insertNode(Tuple t1, Tuple t2) {--newline--    t2.next = t1.next;--newline--    t1.next.prev = t2;--newline--    t1.next = t2;--newline--    t2.prev = t1;--newline--}--newline----newline--public void removeNode(Tuple node) {--newline--    node.next.prev = node.prev;--newline--    node.prev.next = node.next;--newline--}--newline--class Tuple {--newline--    int key;--newline--    int value;--newline--    int times;--newline--    Tuple prev;--newline--    Tuple next;--newline--    public Tuple(int key, int value, int times) {--newline--        this.key = key;--newline--        this.value = value;--newline--        this.times = times;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solutions of three different ways. PriorityQueue : O(capacity)  TreeMap : O(log(capacity)) DoubleLinkedList  : O(1)"
        }
    ],
    "qc": "460.json"
}