{
    "posts": [
        {
            "java": "public class Solution {--newline--    public static List<String> findAllConcatenatedWordsInADict(String[] words) {--newline--        List<String> result = new ArrayList<>();--newline--        Set<String> preWords = new HashSet<>();--newline--        Arrays.sort(words, new Comparator<String>() {--newline--            public int compare (String s1, String s2) {--newline--                return s1.length() - s2.length();--newline--            }--newline--        });--newline--        --newline--        for (int i = 0; i < words.length; i++) {--newline--            if (canForm(words[i], preWords)) {--newline--                result.add(words[i]);--newline--            }--newline--            preWords.add(words[i]);--newline--        }--newline--        --newline--        return result;--newline--    }--newline----tab----newline--    private static boolean canForm(String word, Set<String> dict) {--newline--        if (dict.isEmpty()) return false;--newline----tab--boolean[] dp = new boolean[word.length() + 1];--newline----tab--dp[0] = true;--newline----tab--for (int i = 1; i <= word.length(); i++) {--newline----tab--    for (int j = 0; j < i; j++) {--newline----tab----tab--if (!dp[j]) continue;--newline----tab----tab--if (dict.contains(word.substring(j, i))) {--newline----tab----tab--    dp[i] = true;--newline----tab----tab--    break;--newline----tab----tab--}--newline----tab--    }--newline----tab--}--newline----tab--return dp[word.length()];--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java DP Solution"
        },
        {
            "java": "public class Solution {--newline--    class TrieNode {--newline--        TrieNode[] children;--newline--        String word;--newline--        boolean isEnd;--newline--        boolean combo; //if this word is a combination of simple words--newline--        boolean added; //if this word is already added in result--newline--        public TrieNode() {--newline--            this.children = new TrieNode[26];--newline--            this.word = new String();--newline--            this.isEnd = false;--newline--            this.combo = false;--newline--            this.added = false;--newline--        }--newline--    }--newline--    private void addWord(String str) {--newline--        TrieNode node = root;--newline--        for (char ch : str.toCharArray()) {--newline--            if (node.children[ch - 'a'] == null) {--newline--                node.children[ch - 'a'] = new TrieNode();--newline--            }--newline--            node = node.children[ch - 'a'];--newline--        }--newline--        node.isEnd = true;--newline--        node.word = str;--newline--    }--newline--    private TrieNode root;--newline--    private List<String> result;--newline--    public List<String> findAllConcatenatedWordsInADict(String[] words) {--newline--        root = new TrieNode();--newline--        for (String str : words) {--newline--            if (str.length() == 0) {--newline--                continue;--newline--            }--newline--            addWord(str);--newline--        }--newline--        result = new ArrayList<>();--newline--        dfs(root, 0);--newline--        return result;--newline--    }--newline--    private void dfs(TrieNode node, int multi) {--newline--    --tab--//multi counts how many single words combined in this word--newline--        if(node.isEnd && !node.added && multi > 1) {--newline--            node.combo = true;--newline--            node.added = true;--newline--            result.add(node.word);--newline--        }--newline--        searchWord(node, root, multi);--newline--    }--newline--    private void searchWord(TrieNode node1, TrieNode node2, int multi) {--newline--        if (node2.combo) {--newline--            return;--newline--        }--newline--        if (node2.isEnd) {--newline--            //take the pointer of node2 back to root--newline--            dfs(node1, multi + 1);--newline--        }--newline--        for (int  i = 0; i < 26; i++) {--newline--            if (node1.children[i] != null && node2.children[i] != null) {--newline--                searchWord(node1.children[i], node2.children[i], multi);--newline--            }--newline--        }--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Simple Java Trie + DFS solution 144ms"
        },
        {
            "java": "public List<String> findAllConcatenatedWordsInADict(String[] words) {--newline--        List<String> res = new ArrayList<String>();--newline--        if (words == null || words.length == 0) {--newline--            return res;--newline--        }--newline--        TrieNode root = new TrieNode();--newline--        for (String word : words) { // construct Trie tree--newline--            if (word.length() == 0) {--newline--                continue;--newline--            }--newline--            addWord(word, root);--newline--        }--newline--        for (String word : words) { // test word is a concatenated word or not--newline--            if (word.length() == 0) {--newline--                continue;--newline--            }--newline--            if (testWord(word.toCharArray(), 0, root, 0)) {--newline--                res.add(word);--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--    public boolean testWord(char[] chars, int index, TrieNode root, int count) { // count means how many words during the search path--newline--        TrieNode cur = root;--newline--        int n = chars.length;--newline--        for (int i = index; i < n; i++) {--newline--            if (cur.sons[chars[i] - 'a'] == null) {--newline--                return false;--newline--            }--newline--            if (cur.sons[chars[i] - 'a'].isEnd) {--newline--                if (i == n - 1) { // no next word, so test count to get result.--newline--                    return count >= 1;--newline--                }--newline--                if (testWord(chars, i + 1, root, count + 1)) {--newline--                    return true;--newline--                }--newline--            }--newline--            cur = cur.sons[chars[i] - 'a'];--newline--        }--newline--        return false;--newline--    }--newline--    public void addWord(String str, TrieNode root) {--newline--        char[] chars = str.toCharArray();--newline--        TrieNode cur = root;--newline--        for (char c : chars) {--newline--            if (cur.sons[c - 'a'] == null) {--newline--                cur.sons[c - 'a'] = new TrieNode();--newline--            }--newline--            cur = cur.sons[c - 'a'];--newline--        }--newline--        cur.isEnd = true;--newline--    }--newline--}--newline--class TrieNode {--newline--    TrieNode[] sons;--newline--    boolean isEnd;--newline--    public TrieNode() {--newline--        sons = new TrieNode[26];--newline--    }--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "102ms java Trie + DFS solution. With explanation, easy to understand."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--        vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {--newline--            unordered_set<string> s(words.begin(), words.end());--newline--            vector<string> res;--newline--            for (auto w : words) {--newline--                int n = w.size();--newline--                vector<int> dp(n+1);--newline--                dp[0] = 1;--newline--                for (int i = 0; i < n; i++) {--newline--                    if (dp[i] == 0) continue;--newline--                    for (int j = i+1; j <= n; j++) {--newline--                        if (j - i < n && s.count(w.substr(i, j-i))) dp[j] = 1;--newline--                    }--newline--                    if (dp[n]) { res.push_back(w); break; }--newline--                }--newline--            }--newline--            return res;--newline--        }--newline--    --newline--}",
            "python": null,
            "topic_title": "C++ 772 ms dp solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Python Explanation"
        }
    ],
    "qc": "472.json"
}