{
    "posts": [
        {
            "java": "public class Solution {--newline--        public int maxProfit(int k, int[] prices) {--newline--            int len = prices.length;--newline--            if (k >= len / 2) return quickSolve(prices);--newline--            --newline--            int[][] t = new int[k + 1][len];--newline--            for (int i = 1; i <= k; i++) {--newline--                int tmpMax =  -prices[0];--newline--                for (int j = 1; j < len; j++) {--newline--                    t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);--newline--                    tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);--newline--                }--newline--            }--newline--            return t[k][len - 1];--newline--        }--newline--        --newline--    --newline--        private int quickSolve(int[] prices) {--newline--            int len = prices.length, profit = 0;--newline--            for (int i = 1; i < len; i++)--newline--                // as long as there is a price gap, we gain a profit.--newline--                if (prices[i] > prices[i - 1]) profit += prices[i] - prices[i - 1];--newline--            return profit;--newline--        }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "A Concise DP Solution in Java"
        },
        {
            "java": "public class Solution {--newline--    /**--newline--     * dp[i, j] represents the max profit up until prices[j] using at most i transactions. --newline--     * dp[i, j] = max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]) { jj in range of [0, j-1] }--newline--     *          = max(dp[i, j-1], prices[j] + max(dp[i-1, jj] - prices[jj]))--newline--     * dp[0, j] = 0; 0 transactions makes 0 profit--newline--     * dp[i, 0] = 0; if there is only one price data point you can't make any transaction.--newline--     */--newline--    --newline--    public int maxProfit(int k, int[] prices) {--newline--    --tab--int n = prices.length;--newline--    --tab--if (n <= 1)--newline--    --tab----tab--return 0;--newline--    --tab----newline--    --tab--//if k >= n/2, then you can make maximum number of transactions.--newline--    --tab--if (k >=  n/2) {--newline--    --tab----tab--int maxPro = 0;--newline--    --tab----tab--for (int i = 1; i < n; i++) {--newline--    --tab----tab----tab--if (prices[i] > prices[i-1])--newline--    --tab----tab----tab----tab--maxPro += prices[i] - prices[i-1];--newline--    --tab----tab--}--newline--    --tab----tab--return maxPro;--newline--    --tab--}--newline--    --tab----newline--        int[][] dp = new int[k+1][n];--newline--        for (int i = 1; i <= k; i++) {--newline--        --tab--int localMax = dp[i-1][0] - prices[0];--newline--        --tab--for (int j = 1; j < n; j++) {--newline--        --tab----tab--dp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);--newline--        --tab----tab--localMax = Math.max(localMax, dp[i-1][j] - prices[j]);--newline--        --tab--}--newline--        }--newline--        return dp[k][n-1];--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Clean Java DP solution with comment"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int maxProfit(int k, vector<int> &prices) {--newline--        int n = (int)prices.size(), ret = 0, v, p = 0;--newline--        priority_queue<int> profits;--newline--        stack<pair<int, int> > vp_pairs;--newline--        while (p < n) {--newline--            // find next valley/peak pair--newline--            for (v = p; v < n - 1 && prices[v] >= prices[v+1]; v++);--newline--            for (p = v + 1; p < n && prices[p] >= prices[p-1]; p++);--newline--            // save profit of 1 transaction at last v/p pair, if current v is lower than last v--newline--            while (!vp_pairs.empty() && prices[v] < prices[vp_pairs.top().first]) {--newline--                profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);--newline--                vp_pairs.pop();--newline--            }--newline--            // save profit difference between 1 transaction (last v and current p) and 2 transactions (last v/p + current v/p),--newline--            // if current v is higher than last v and current p is higher than last p--newline--            while (!vp_pairs.empty() && prices[p-1] >= prices[vp_pairs.top().second-1]) {--newline--                profits.push(prices[vp_pairs.top().second-1] - prices[v]);--newline--                v = vp_pairs.top().first;--newline--                vp_pairs.pop();--newline--            }--newline--            vp_pairs.push(pair<int, int>(v, p));--newline--        }--newline--        // save profits of the rest v/p pairs--newline--        while (!vp_pairs.empty()) {--newline--            profits.push(prices[vp_pairs.top().second-1] - prices[vp_pairs.top().first]);--newline--            vp_pairs.pop();--newline--        }--newline--        // sum up first k highest profits--newline--        for (int i = 0; i < k && !profits.empty(); i++) {--newline--            ret += profits.top();--newline--            profits.pop();--newline--        }--newline--        return ret;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ Solution with O(n + klgn) time using Max Heap and Stack"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    public:--newline--        int maxProfit(int k, vector<int> &prices) {--newline--            int len = prices.size();--newline--            if (len<2) return 0;--newline--            if (k>len/2){ // simple case--newline--                int ans = 0;--newline--                for (int i=1; i<len; ++i){--newline--                    ans += max(prices[i] - prices[i-1],0);--newline--                }--newline--                return ans;--newline--            }--newline--            int hold[k+1];--newline--            int rele[k+1];--newline--            for (int i=0;i<=k;++i){--newline--                hold[i] = INT_MIN;--newline--                rele[i] = 0;--newline--            }--newline--            int cur;--newline--            for (int i=0; i<len; ++i){--newline--                cur = prices[i];--newline--                for(int j=k; j>0; --j){--newline--                    rele[j] = max(rele[j],hold[j] + cur);--newline--                    hold[j] = max(hold[j],rele[j-1] - cur);--newline--                }--newline--            }--newline--            return rele[k];--newline--        }--newline--    --newline--}",
            "python": null,
            "topic_title": "Share my C++ DP solution with O(kn) time O(k) space, 10ms"
        },
        {
            "java": "public class Solution {--newline--    //hold[i][k]  ith day k transaction have stock and maximum profit--newline--    //unhold[i][k] ith day k transaction do not have stock at hand and maximum profit--newline--    public int maxProfit(int k, int[] prices) {--newline--        if(k>prices.length/2) return maxP(prices);--newline--        int[][] hold = new int[prices.length][k+1];--newline--        int[][] unhold = new int[prices.length][k+1];--newline--        hold[0][0] = -prices[0];--newline--        for(int i=1;i<prices.length;i++) hold[i][0] = Math.max(hold[i-1][0],-prices[i]);--newline--        for(int j=1;j<=k;j++) hold[0][j] = -prices[0];--newline--        for(int i=1;i<prices.length;i++){--newline--            for(int j=1;j<=k;j++){--newline--                hold[i][j] = Math.max(unhold[i-1][j]-prices[i],hold[i-1][j]);--newline--                unhold[i][j] = Math.max(hold[i-1][j-1]+prices[i],unhold[i-1][j]);--newline--            }--newline--        }--newline--        return Math.max(hold[prices.length-1][k],unhold[prices.length-1][k]);--newline--    }--newline--    public int maxP(int[] prices){--newline--        int res =0;--newline--        for(int i=0;i<prices.length;i++){--newline--            if(i>0 && prices[i] > prices[i-1]){--newline--                res += prices[i]-prices[i-1];--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy understanding and can be easily modified to different situations Java Solution"
        }
    ],
    "qc": "188.json"
}