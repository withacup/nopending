{
    "posts": [
        {
            "java": "public class NumArray {--newline----newline--    class SegmentTreeNode {--newline--        int start, end;--newline--        SegmentTreeNode left, right;--newline--        int sum;--newline----newline--        public SegmentTreeNode(int start, int end) {--newline--            this.start = start;--newline--            this.end = end;--newline--            this.left = null;--newline--            this.right = null;--newline--            this.sum = 0;--newline--        }--newline--    }--newline--      --newline--    SegmentTreeNode root = null;--newline--   --newline--    public NumArray(int[] nums) {--newline--        root = buildTree(nums, 0, nums.length-1);--newline--    }--newline----newline--    private SegmentTreeNode buildTree(int[] nums, int start, int end) {--newline--        if (start > end) {--newline--            return null;--newline--        } else {--newline--            SegmentTreeNode ret = new SegmentTreeNode(start, end);--newline--            if (start == end) {--newline--                ret.sum = nums[start];--newline--            } else {--newline--                int mid = start  + (end - start) / 2;             --newline--                ret.left = buildTree(nums, start, mid);--newline--                ret.right = buildTree(nums, mid + 1, end);--newline--                ret.sum = ret.left.sum + ret.right.sum;--newline--            }         --newline--            return ret;--newline--        }--newline--    }--newline--   --newline--    void update(int i, int val) {--newline--        update(root, i, val);--newline--    }--newline--   --newline--    void update(SegmentTreeNode root, int pos, int val) {--newline--        if (root.start == root.end) {--newline--           root.sum = val;--newline--        } else {--newline--            int mid = root.start + (root.end - root.start) / 2;--newline--            if (pos <= mid) {--newline--                 update(root.left, pos, val);--newline--            } else {--newline--                 update(root.right, pos, val);--newline--            }--newline--            root.sum = root.left.sum + root.right.sum;--newline--        }--newline--    }--newline----newline--    public int sumRange(int i, int j) {--newline--        return sumRange(root, i, j);--newline--    }--newline--    --newline--    public int sumRange(SegmentTreeNode root, int start, int end) {--newline--        if (root.end == end && root.start == start) {--newline--            return root.sum;--newline--        } else {--newline--            int mid = root.start + (root.end - root.start) / 2;--newline--            if (end <= mid) {--newline--                return sumRange(root.left, start, end);--newline--            } else if (start >= mid+1) {--newline--                return sumRange(root.right, start, end);--newline--            }  else {    --newline--                return sumRange(root.right, mid+1, end) + sumRange(root.left, start, mid);--newline--            }--newline--        }--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "17 ms Java solution with segment tree"
        },
        {
            "java": "public class NumArray {--newline----tab--/**--newline----tab-- * Binary Indexed Trees (BIT or Fenwick tree):--newline----tab-- * https://www.topcoder.com/community/data-science/data-science---newline----tab-- * tutorials/binary-indexed-trees/--newline----tab-- * --newline----tab-- * Example: given an array a[0]...a[7], we use a array BIT[9] to--newline----tab-- * represent a tree, where index [2] is the parent of [1] and [3], [6]--newline----tab-- * is the parent of [5] and [7], [4] is the parent of [2] and [6], and--newline----tab-- * [8] is the parent of [4]. I.e.,--newline----tab-- * --newline----tab-- * BIT[] as a binary tree:--newline----tab-- *            ______________*--newline----tab-- *            ______*--newline----tab-- *            __*     __*--newline----tab-- *            *   *   *   *--newline----tab-- * indices: 0 1 2 3 4 5 6 7 8--newline----tab-- * --newline----tab-- * BIT[i] = ([i] is a left child) ? the partial sum from its left most--newline----tab-- * descendant to itself : the partial sum from its parent (exclusive) to--newline----tab-- * itself. (check the range of \"__\").--newline----tab-- * --newline----tab-- * Eg. BIT[1]=a[0], BIT[2]=a[1]+BIT[1]=a[1]+a[0], BIT[3]=a[2],--newline----tab-- * BIT[4]=a[3]+BIT[3]+BIT[2]=a[3]+a[2]+a[1]+a[0],--newline----tab-- * BIT[6]=a[5]+BIT[5]=a[5]+a[4],--newline----tab-- * BIT[8]=a[7]+BIT[7]+BIT[6]+BIT[4]=a[7]+a[6]+...+a[0], ...--newline----tab-- * --newline----tab-- * Thus, to update a[1]=BIT[2], we shall update BIT[2], BIT[4], BIT[8],--newline----tab-- * i.e., for current [i], the next update [j] is j=i+(i&-i) //double the--newline----tab-- * last 1-bit from [i].--newline----tab-- * --newline----tab-- * Similarly, to get the partial sum up to a[6]=BIT[7], we shall get the--newline----tab-- * sum of BIT[7], BIT[6], BIT[4], i.e., for current [i], the next--newline----tab-- * summand [j] is j=i-(i&-i) // delete the last 1-bit from [i].--newline----tab-- * --newline----tab-- * To obtain the original value of a[7] (corresponding to index [8] of--newline----tab-- * BIT), we have to subtract BIT[7], BIT[6], BIT[4] from BIT[8], i.e.,--newline----tab-- * starting from [idx-1], for current [i], the next subtrahend [j] is--newline----tab-- * j=i-(i&-i), up to j==idx-(idx&-idx) exclusive. (However, a quicker--newline----tab-- * way but using extra space is to store the original array.)--newline----tab-- */--newline----newline----tab--int[] nums;--newline----tab--int[] BIT;--newline----tab--int n;--newline----newline----tab--public NumArray(int[] nums) {--newline----tab----tab--this.nums = nums;--newline----newline----tab----tab--n = nums.length;--newline----tab----tab--BIT = new int[n + 1];--newline----tab----tab--for (int i = 0; i < n; i++)--newline----tab----tab----tab--init(i, nums[i]);--newline----tab--}--newline----newline----tab--public void init(int i, int val) {--newline----tab----tab--i++;--newline----tab----tab--while (i <= n) {--newline----tab----tab----tab--BIT[i] += val;--newline----tab----tab----tab--i += (i & -i);--newline----tab----tab--}--newline----tab--}--newline----newline----tab--void update(int i, int val) {--newline----tab----tab--int diff = val - nums[i];--newline----tab----tab--nums[i] = val;--newline----tab----tab--init(i, diff);--newline----tab--}--newline----newline----tab--public int getSum(int i) {--newline----tab----tab--int sum = 0;--newline----tab----tab--i++;--newline----tab----tab--while (i > 0) {--newline----tab----tab----tab--sum += BIT[i];--newline----tab----tab----tab--i -= (i & -i);--newline----tab----tab--}--newline----tab----tab--return sum;--newline----tab--}--newline----newline----tab--public int sumRange(int i, int j) {--newline----tab----tab--return getSum(j) - getSum(i - 1);--newline----tab--}--newline--}--newline----newline--// Your NumArray object will be instantiated and called as such:--newline--// NumArray numArray = new NumArray(nums);--newline--// numArray.sumRange(0, 1);--newline--// numArray.update(1, 10);--newline--// numArray.sumRange(1, 2);",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java using Binary Indexed Tree with clear explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class NumArray {--newline--public:--newline--    --newline--    struct Bucket--newline--    {--newline--        int sum;--newline--        vector<int> val;--newline--    };--newline--    --newline--    int bucketNum;--newline--    int bucketSize;--newline--    vector<Bucket> Bs;--newline----newline--    NumArray(vector<int> &nums) {--newline--        int size = nums.size();--newline--        int bucketNum = (int)sqrt(2*size);--newline--        bucketSize = bucketNum/2;--newline--        while(bucketSize * bucketNum<size) ++bucketSize;--newline--        --newline--        Bs.resize(bucketNum);--newline--        for(int i=0, k=0; i<bucketNum; ++i)--newline--        {--newline--            int temp = 0;--newline--            Bs[i].val.resize(bucketSize);--newline--            for(int j=0; j<bucketSize && k<size; ++j, ++k)--newline--            {--newline--                temp += nums[k];--newline--                Bs[i].val[j] = nums[k];--newline--            }--newline--            Bs[i].sum = temp;--newline--        }--newline--    }--newline----newline--    void update(int i, int val) {--newline--        int x = i / bucketSize;--newline--        int y = i % bucketSize;--newline--        Bs[x].sum += (val - Bs[x].val[y]);--newline--        Bs[x].val[y] = val;--newline--    }--newline----newline--    int sumRange(int i, int j) {--newline--        int x1 = i / bucketSize;--newline--        int y1 = i % bucketSize;--newline----tab----tab--int x2 = j / bucketSize;--newline--        int y2 = j % bucketSize;--newline--        int sum = 0;--newline----newline----tab----tab--if(x1==x2)--newline----tab----tab--{--newline----tab----tab----tab--for(int a=y1; a<=y2; ++a)--newline----tab----tab----tab--{--newline----tab----tab----tab----tab--sum += Bs[x1].val[a];--newline----tab----tab----tab--}--newline----tab----tab----tab--return sum;--newline----tab----tab--}--newline----newline----tab----tab--for(int a=y1; a<bucketSize; ++a)--newline----tab----tab--{--newline----tab----tab----tab--sum += Bs[x1].val[a];--newline----tab----tab--}--newline--        for(int a=x1+1; a<x2; ++a)--newline--        {--newline--            sum += Bs[a].sum;--newline--        }--newline--        for(int b=0; b<=y2; ++b)--newline--        {--newline--            sum += Bs[x2].val[b];--newline--        }--newline--        return sum;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ solution using &quot;buckets&quot;. O(1) for updating and O(n^0.5) for query in the worst case (not the fast)."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "&quot;0 lines&quot; Python"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "struct SegmentTreeNode {--newline--    int start, end, sum;--newline--    SegmentTreeNode* left;--newline--    SegmentTreeNode* right;--newline--    SegmentTreeNode(int a, int b):start(a),end(b),sum(0),left(nullptr),right(nullptr){}--newline--};--newline--class NumArray {--newline--    SegmentTreeNode* root;--newline--public:--newline--    NumArray(vector<int> &nums) {--newline--        int n = nums.size();--newline--        root = buildTree(nums,0,n-1);--newline--    }--newline--   --newline--    void update(int i, int val) {--newline--        modifyTree(i,val,root);--newline--    }--newline----newline--    int sumRange(int i, int j) {--newline--        return queryTree(i, j, root);--newline--    }--newline--    SegmentTreeNode* buildTree(vector<int> &nums, int start, int end) {--newline--        if(start > end) return nullptr;--newline--        SegmentTreeNode* root = new SegmentTreeNode(start,end);--newline--        if(start == end) {--newline--            root->sum = nums[start];--newline--            return root;--newline--        }--newline--        int mid = start + (end - start) / 2;--newline--        root->left = buildTree(nums,start,mid);--newline--        root->right = buildTree(nums,mid+1,end);--newline--        root->sum = root->left->sum + root->right->sum;--newline--        return root;--newline--    }--newline--    int modifyTree(int i, int val, SegmentTreeNode* root) {--newline--        if(root == nullptr) return 0;--newline--        int diff;--newline--        if(root->start == i && root->end == i) {--newline--            diff = val - root->sum;--newline--            root->sum = val;--newline--            return diff;--newline--        }--newline--        int mid = (root->start + root->end) / 2;--newline--        if(i > mid) {--newline--            diff = modifyTree(i,val,root->right);--newline--        } else {--newline--            diff = modifyTree(i,val,root->left);--newline--        }--newline--        root->sum = root->sum + diff;--newline--        return diff;--newline--    }--newline--    int queryTree(int i, int j, SegmentTreeNode* root) {--newline--        if(root == nullptr) return 0;--newline--        if(root->start == i && root->end == j) return root->sum;--newline--        int mid = (root->start + root->end) / 2;--newline--        if(i > mid) return queryTree(i,j,root->right);--newline--        if(j <= mid) return queryTree(i,j,root->left);--newline--        return queryTree(i,mid,root->left) + queryTree(mid+1,j,root->right);--newline--    }--newline--};--newline----newline----newline--// Your NumArray object will be instantiated and called as such:--newline--// NumArray numArray(nums);--newline--// numArray.sumRange(0, 1);--newline--// numArray.update(1, 10);--newline--// numArray.sumRange(1, 2);",
            "python": null,
            "topic_title": "C++, Segment Tree,update and sum are both O(logn)"
        }
    ],
    "qc": "307.json"
}