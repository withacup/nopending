{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int maxSumSubmatrix(vector<vector<int>>& matrix, int k) {--newline--        if (matrix.empty()) return 0;--newline--        int row = matrix.size(), col = matrix[0].size(), res = INT_MIN;--newline--        for (int l = 0; l < col; ++l) {--newline--            vector<int> sums(row, 0);--newline--            for (int r = l; r < col; ++r) {--newline--                for (int i = 0; i < row; ++i) {--newline--                    sums[i] += matrix[i][r];--newline--                }--newline--                --newline--                // Find the max subarray no more than K --newline--                set<int> accuSet;--newline--                accuSet.insert(0);--newline--                int curSum = 0, curMax = INT_MIN;--newline--                for (int sum : sums) {--newline--                    curSum += sum;--newline--                    set<int>::iterator it = accuSet.lower_bound(curSum - k);--newline--                    if (it != accuSet.end()) curMax = std::max(curMax, curSum - *it);--newline--                    accuSet.insert(curSum);--newline--                }--newline--                res = std::max(res, curMax);--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "Accepted C++ codes with explanation and references"
        },
        {
            "java": "public class Solution {--newline--    /* first  consider the situation matrix is 1D--newline--        we can save every sum of 0~i(0<=i<len) and binary search previous sum to find --newline--        possible result for every index, time complexity is O(NlogN).--newline--        so in 2D matrix, we can sum up all values from row i to row j and create a 1D array --newline--        to use 1D array solution.--newline--        If col number is less than row number, we can sum up all values from col i to col j --newline--        then use 1D array solution.--newline--    */--newline--    public int maxSumSubmatrix(int[][] matrix, int target) {--newline--        int row = matrix.length;--newline--        if(row==0)return 0;--newline--        int col = matrix[0].length;--newline--        int m = Math.min(row,col);--newline--        int n = Math.max(row,col);--newline--        //indicating sum up in every row or every column--newline--        boolean colIsBig = col>row;--newline--        int res = Integer.MIN_VALUE;--newline--        for(int i = 0;i<m;i++){--newline--            int[] array = new int[n];--newline--            // sum from row j to row i--newline--            for(int j = i;j>=0;j--){--newline--                int val = 0;--newline--                TreeSet<Integer> set = new TreeSet<Integer>();--newline--                set.add(0);--newline--                //traverse every column/row and sum up--newline--                for(int k = 0;k<n;k++){--newline--                    array[k]=array[k]+(colIsBig?matrix[j][k]:matrix[k][j]);--newline--                    val = val + array[k];--newline--                    //use  TreeMap to binary search previous sum to get possible result --newline--                    Integer subres = set.ceiling(val-target);--newline--                    if(null!=subres){--newline--                        res=Math.max(res,val-subres);--newline--                    }--newline--                    set.add(val);--newline--                }--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Binary Search solution time complexity min(m,n)^2*max(m,n)*log(max(m,n))"
        },
        {
            "java": "public class Solution {--newline--    public int maxSumSubmatrix(int[][] matrix, int k) {--newline--        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)--newline--            return 0;--newline--        int rows = matrix.length, cols = matrix[0].length;--newline--        int[][] areas = new int[rows][cols];--newline--        for (int r = 0; r < rows; r++) {--newline--            for (int c = 0; c < cols; c++) {--newline--                int area = matrix[r][c];--newline--                if (r-1 >= 0)--newline--                    area += areas[r-1][c];--newline--                if (c-1 >= 0)--newline--                    area += areas[r][c-1];--newline--                if (r-1 >= 0 && c-1 >= 0)--newline--                    area -= areas[r-1][c-1];--newline--                areas[r][c] = area;--newline--            }--newline--        }--newline--        int max = Integer.MIN_VALUE;--newline--        for (int r1 = 0; r1 < rows; r1++) {--newline--            for (int r2 = r1; r2 < rows; r2++) {--newline--                TreeSet<Integer> tree = new TreeSet<>();--newline--                tree.add(0);    // padding--newline--                for (int c = 0; c < cols; c++) {--newline--                    int area = areas[r2][c];--newline--                    if (r1-1 >= 0)--newline--                        area -= areas[r1-1][c];--newline--                    Integer ceiling = tree.ceiling(area - k);--newline--                    if (ceiling != null)--newline--                        max = Math.max(max, area - ceiling);--newline--                    tree.add(area);--newline--                }--newline--            }--newline--        }--newline--        return max;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "2 Accepted Java Solution"
        },
        {
            "java": "/*--newline-- * If # of columns is smaller, process one set of columns [i..j) at a time, for each different i<j.--newline-- * For one set of colums [i..j), do it like \"Count of Range Sum\".--newline-- * O(n) = n^2 * mlogm.--newline-- * Assume we have such result.--newline-- */--newline--public class Solution {--newline--    public int maxSumSubmatrix(int[][] matrix, int k) {--newline--        int m = matrix.length, n = matrix[0].length, ans = Integer.MIN_VALUE;--newline--        long[] sum = new long[m+1]; // stores sum of rect[0..p][i..j]--newline--        for (int i = 0; i < n; ++i) {--newline--            long[] sumInRow = new long[m];--newline--            for (int j = i; j < n; ++j) { // for each rect[*][i..j]--newline--                for (int p = 0; p < m; ++p) {--newline--                    sumInRow[p] += matrix[p][j];--newline--                    sum[p+1] = sum[p] + sumInRow[p];--newline--                }--newline--                ans = Math.max(ans, mergeSort(sum, 0, m+1, k));--newline--                if (ans == k) return k;--newline--            }--newline--        }--newline--        return ans;--newline--    }--newline--    int mergeSort(long[] sum, int start, int end, int k) {--newline--        if (end == start+1) return Integer.MIN_VALUE; // need at least 2 to proceed--newline--        int mid = start + (end - start)/2, cnt = 0;--newline--        int ans = mergeSort(sum, start, mid, k);--newline--        if (ans == k) return k;--newline--        ans = Math.max(ans, mergeSort(sum, mid, end, k));--newline--        if (ans == k) return k;--newline--        long[] cache = new long[end-start];--newline--        for (int i = start, j = mid, p = mid; i < mid; ++i) {--newline--            while (j < end && sum[j] - sum[i] <= k) ++j;--newline--            if (j-1 >= mid) {--newline--                ans = Math.max(ans, (int)(sum[j-1] - sum[i]));--newline--                if (ans == k) return k;--newline--            }--newline--            while (p < end && sum[p] < sum[i]) cache[cnt++] = sum[p++];--newline--            cache[cnt++] = sum[i];--newline--        }--newline--        System.arraycopy(cache, 0, sum, start, cnt);--newline--        return ans;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA 117ms, beat 99.81%, merge sort"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def maxSumSubmatrix(self, matrix, k):--newline----tab--        \"\"\"--newline----tab--        :type matrix: List[List[int]]--newline----tab--        :type k: int--newline----tab--        :rtype: int--newline----tab--        \"\"\"--newline----tab--        m = len(matrix)--newline----tab--        n = len(matrix[0]) if m else 0--newline----tab--        --newline----tab--        M = max(m, n)--newline----tab--        N = min(m, n)--newline----tab--        ans = None--newline----tab--        for x in range(N):--newline----tab--            sums = [0] * M--newline----tab--            for y in range(x, N):--newline----tab--                slist, num = [], 0--newline----tab--                for z in range(M):--newline----tab--                    sums[z] += matrix[z][y] if m > n else matrix[y][z]--newline----tab--                    num += sums[z]--newline----tab--                    if num <= k: ans = max(ans, num)--newline----tab--                    i = bisect.bisect_left(slist, num - k)--newline----tab--                    if i != len(slist): ans = max(ans, num - slist[i])--newline----tab--                    bisect.insort(slist, num)--newline----tab--        return ans or 0--newline----tab--",
            "topic_title": "Any Accepted Python Solution?"
        }
    ],
    "qc": "363.json"
}