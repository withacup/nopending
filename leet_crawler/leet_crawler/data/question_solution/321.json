{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int[] maxNumber(int[] nums1, int[] nums2, int k) {--newline--        int n = nums1.length;--newline--        int m = nums2.length;--newline--        int[] ans = new int[k];--newline--        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {--newline--            int[] candidate = merge(maxArray(nums1, i), maxArray(nums2, k - i), k);--newline--            if (greater(candidate, 0, ans, 0)) ans = candidate;--newline--        }--newline--        return ans;--newline--    }--newline--    private int[] merge(int[] nums1, int[] nums2, int k) {--newline--        int[] ans = new int[k];--newline--        for (int i = 0, j = 0, r = 0; r < k; ++r)--newline--            ans[r] = greater(nums1, i, nums2, j) ? nums1[i++] : nums2[j++];--newline--        return ans;--newline--    }--newline--    public boolean greater(int[] nums1, int i, int[] nums2, int j) {--newline--        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {--newline--            i++;--newline--            j++;--newline--        }--newline--        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);--newline--    }--newline--    public int[] maxArray(int[] nums, int k) {--newline--        int n = nums.length;--newline--        int[] ans = new int[k];--newline--        for (int i = 0, j = 0; i < n; ++i) {--newline--            while (n - i + j > k && j > 0 && ans[j - 1] < nums[i]) j--;--newline--            if (j < k) ans[j++] = nums[i];--newline--        }--newline--        return ans;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my greedy solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    #define MIN(a,b) (a<b?a:b)--newline--    #define MAX(a,b) (a>b?a:b)--newline--    // create max number of length t from single non-empty vector--newline--    void getMax(int* num, int& len, int* result, int& t, int& sortedLen)--newline--    {--newline--    --tab--int n, top = 0;--newline--    --tab--result[0] = num[0];--newline--    --tab--const int need2drop = len - t;--newline--    --tab--for (int i = 1; i < len; ++i){--newline--    --tab----tab--n = num[i];--newline--    --tab----tab--while (top >= 0 && result[top] < n && (i - top) <= need2drop) --top; // i - top means already dropped i - top numbers--newline--    --tab----tab--if (i - top > need2drop){--newline--    --tab----tab----tab--sortedLen = MAX(1,top);--newline--    --tab----tab----tab--while (++top < t) result[top] = num[i++];--newline--    --tab----tab----tab--return;--newline--    --tab----tab--}--newline--    --tab----tab--if (++top < t) result[top] = n;--newline--    --tab----tab--else top = t - 1;--newline--    --tab--}--newline--    }--newline--    // create max number of different length from single vector--newline--    void dp(int *num, int len, int&sortedLen, int& minL, int& maxL, int *res, int &k){--newline--    --tab--int  j, *head, *prevhead = res;--newline--    --tab--const int soi = sizeof(int);--newline--    --tab--getMax(num, len, res, maxL,sortedLen);--newline--    --tab--for (int l = maxL; l > MAX(minL,1); --l){--newline--    --tab----tab--head = prevhead + k;--newline--    --tab----tab--memcpy(head, prevhead, l*soi);--newline--    --tab----tab--for (j = sortedLen; j < l; ++j){--newline--    --tab----tab----tab--if (head[j] > head[j - 1]){--newline--    --tab----tab----tab----tab--sortedLen = MAX(1, j - 1);--newline--    --tab----tab----tab----tab--memcpy(head + j - 1, prevhead + j, soi*(l - j));--newline--    --tab----tab----tab----tab--break;--newline--    --tab----tab----tab--}--newline--    --tab----tab--}--newline--    --tab----tab--if (j == l) sortedLen = l;--newline--    --tab----tab--prevhead = head;--newline--    --tab--}--newline--    }--newline--    // merge max number created from single vector--newline--    void merge(int* num1,int len1,int* num2,int len2,int* result,int& resSize){--newline--    --tab--int i = 0, j = 0, k = 0;--newline--    --tab--while (i < resSize){--newline--    --tab----tab--if (j < len1 && k < len2){--newline--    --tab----tab----tab--if (num1[j] > num2[k])--newline--    --tab----tab----tab----tab--result[i++] = num1[j++];--newline--    --tab----tab----tab--else if (num1[j] < num2[k])--newline--    --tab----tab----tab----tab--result[i++] = num2[k++];--newline--    --tab----tab----tab--else{--newline--    --tab----tab----tab----tab--int remaining1 = len1 - j, remaining2 = len2 - k, tmp = num1[j];--newline--    --tab----tab----tab----tab--int flag = memcmp(num1 + j, num2 + k, sizeof(int) * MIN(remaining1, remaining2));--newline--    --tab----tab----tab----tab--flag = (flag == 0 ? (remaining1>remaining2 ? 1 : -1) : flag);--newline--    --tab----tab----tab----tab--int * num = flag > 0 ? num1 : num2;--newline--    --tab----tab----tab----tab--int & cnt = flag > 0 ? j : k;--newline--    --tab----tab----tab----tab--int len = flag > 0 ? len1 : len2;--newline--    --tab----tab----tab----tab--while (num[cnt]==tmp && cnt < len && i<resSize) result[i++] = num[cnt++];--newline--    --tab----tab----tab--}--newline--    --tab----tab--}--newline--    --tab----tab--else if (j < len1) result[i++] = num1[j++];--newline--    --tab----tab--else result[i++] = num2[k++];--newline--    --tab--}--newline--    }--newline--    --newline--    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k){--newline--    --tab--int soi = sizeof(int), len1 = nums1.size(), len2 = nums2.size(), step = k*soi;--newline--    --tab--int minL1 = MAX(0, k - len2), maxL1 = MIN(k, len1), minL2 = k - maxL1, maxL2 = k - minL1, range = maxL1 - minL1 + 1;--newline--    --tab--int * res = new int[range * k * 2 + 2 * k], *dp1 = res + k, *dp2 = res + range*k+k, *tmp=res+range*2*k+k;--newline--    --tab--memset(res, 0, step);--newline--    --tab--int sortedLen1 = 1, sortedLen2 = 1;--newline--    --tab--if (len1 == 0 && len2 > 0) getMax(&nums2[0], len2, res, k, sortedLen2);--newline--    --tab--else if (len1 > 0 && len2 == 0) getMax(&nums1[0], len1, res, k, sortedLen2);--newline--    --tab--else if (len1 > 0 && len2 > 0){--newline--    --tab----tab--dp(&nums1[0], len1, sortedLen1, minL1, maxL1, dp1,k);--newline--    --tab----tab--dp(&nums2[0], len2, sortedLen2, minL2, maxL2, dp2,k);--newline--    --tab----tab--if (sortedLen1 + sortedLen2 > k){--newline--    --tab----tab----tab--merge(dp1 + k*(maxL1 - sortedLen1), sortedLen1, dp2 + k*(maxL2 - sortedLen2), sortedLen2, tmp, k);--newline--    --tab----tab----tab--vector<int> resv(tmp, tmp + k);--newline--    --tab----tab----tab--delete[] res;--newline--    --tab----tab----tab--return resv;--newline--    --tab----tab--}--newline--    --tab----tab--for (int i = minL1; i <= maxL1; ++i){--newline--    --tab----tab----tab--merge(dp1+k*(maxL1-i), i, dp2+k*(maxL2-k+i), (k-i), tmp,k);--newline--    --tab----tab----tab--if (memcmp(res, tmp, step) < 0) memcpy(res, tmp, step);--newline--    --tab----tab--}--newline--    --tab--}--newline--    --tab--vector<int> resv(res, res + k);--newline--    --tab--delete[] res;--newline--    --tab--return resv;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ 16ms, FASTEST, beats 97%."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<int> maxNumber(vector<int> nums1, vector<int> nums2) {--newline--        vector<int> out;--newline--        auto i1 = nums1.begin(), end1 = nums1.end();--newline--        auto i2 = nums2.begin(), end2 = nums2.end();--newline--        while (i1 != end1 || i2 != end2)--newline--            out.push_back(lexicographical_compare(i1, end1, i2, end2) ? *i2++ : *i1++);--newline--        return out;--newline--    }--newline--}",
            "python": "class Solution :--newline----tab--    def maxNumber(self, nums1, nums2, k):--newline----tab--    --newline----tab--        def prep(nums, k):--newline----tab--            drop = len(nums) - k--newline----tab--            out = []--newline----tab--            for num in nums:--newline----tab--                while drop and out and out[-1] < num:--newline----tab--                    out.pop()--newline----tab--                    drop -= 1--newline----tab--                out.append(num)--newline----tab--            return out[:k]--newline----tab--    --newline----tab--        def merge(a, b):--newline----tab--            return [max(a, b).pop(0) for _ in a+b]--newline----tab--    --newline----tab--        return max(merge(prep(nums1, i), prep(nums2, k-i))--newline----tab--                   for i in range(k+1)--newline----tab--                   if i <= len(nums1) and k-i <= len(nums2))--newline----tab--    ",
            "topic_title": "Short Python &#x2F; Ruby &#x2F; C++"
        },
        {
            "java": " /**  * Created by hrwhisper on 2015/11/23.  * http://www.hrwhisper.me/leetcode-create-maximum-number/  */--newline----newline----newline--public class Solution {--newline--    public int[] maxNumber(int[] nums1, int[] nums2, int k) {--newline--        int get_from_nums1 = Math.min(nums1.length, k);--newline--        int[] ans = new int[k];--newline--        for (int i = Math.max(k - nums2.length, 0); i <= get_from_nums1; i++) {--newline--            int[] res1 = new int[i];--newline--            int[] res2 = new int[k - i];--newline--            int[] res = new int[k];--newline--            res1 = solve(nums1, i);--newline--            res2 = solve(nums2, k - i);--newline--            int pos1 = 0, pos2 = 0, tpos = 0;--newline--            --newline--            while (res1.length > 0 && res2.length > 0 && pos1 < res1.length && pos2 < res2.length) {--newline--                if (compare(res1, pos1, res2, pos2))--newline--                    res[tpos++] = res1[pos1++];--newline--                else--newline--                    res[tpos++] = res2[pos2++];--newline--            }--newline--            while (pos1 < res1.length)--newline--                res[tpos++] = res1[pos1++];--newline--            while (pos2 < res2.length)--newline--                res[tpos++] = res2[pos2++];--newline----newline--            if (!compare(ans, 0, res, 0))--newline--                ans = res;--newline--        }--newline----newline--        return ans;--newline--    }--newline----newline--    public boolean compare(int[] nums1, int start1, int[] nums2, int start2) {--newline--        for (; start1 < nums1.length && start2 < nums2.length; start1++, start2++) {--newline--            if (nums1[start1] > nums2[start2]) return true;--newline--            if (nums1[start1] < nums2[start2]) return false;--newline--        }--newline--        return start1 != nums1.length;--newline--    }--newline----newline--    public int[] solve(int[] nums, int k) {--newline--        int[] res = new int[k];--newline--        int len = 0;--newline--        for (int i = 0; i < nums.length; i++) {--newline--            while (len > 0 && len + nums.length - i > k && res[len - 1] < nums[i]) {--newline--                len--;--newline--            }--newline--            if (len < k)--newline--                res[len++] = nums[i];--newline--        }--newline--        return res;--newline--    } }--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my 21ms java solution with comments"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--def maxNumber(self, nums1, nums2, k):--newline----tab--    \"\"\"--newline----tab--    :type nums1: List[int]--newline----tab--    :type nums2: List[int]--newline----tab--    :type k: int--newline----tab--    :rtype: List[int]--newline----tab--    \"\"\"--newline----tab--    n, m= len(nums1),len(nums2)--newline----tab--    ret = [0] * k--newline----tab--    for i in range(0, k+1):--newline----tab--        j = k - i--newline----tab--        if i > n or j > m: continue--newline----tab--        left = self.maxSingleNumber(nums1, i)--newline----tab--        right = self.maxSingleNumber(nums2, j)--newline----tab--        num = self.mergeMax(left, right)--newline----tab--        ret = max(num, ret)--newline----tab--    return ret--newline----tab----newline----tab----newline----tab--def mergeMax(self, nums1, nums2):--newline----tab--    ans = []--newline----tab--    while nums1 or nums2:--newline----tab--        if nums1 > nums2:--newline----tab--            ans += nums1[0],--newline----tab--            nums1 = nums1[1:]--newline----tab--        else:--newline----tab--            ans += nums2[0],--newline----tab--            nums2 = nums2[1:]--newline----tab--    return ans--newline----tab----newline----tab--def maxSingleNumber(self, nums, selects):--newline----tab--    n = len(nums)--newline----tab--    ret = [-1]--newline----tab--    if selects > n : return ret--newline----tab--    while selects > 0:--newline----tab--        start = ret[-1] + 1 #search start--newline----tab--        end = n-selects + 1 #search end--newline----tab--        ret.append( max(range(start, end), key = nums.__getitem__))--newline----tab--        selects -= 1--newline----tab--    ret = [nums[item] for item in ret[1:]]--newline----tab--    return ret",
            "topic_title": "Share my Python solution with explanation"
        }
    ],
    "qc": "321.json"
}