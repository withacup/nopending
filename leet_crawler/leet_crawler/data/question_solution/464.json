{
    "posts": [
        {
            "java": "public class Solution {--newline--    Map<Integer, Boolean> map;--newline--    boolean[] used;--newline--    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {--newline--        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;--newline--        if(sum < desiredTotal) return false;--newline--        if(desiredTotal <= 0) return true;--newline--        --newline--        map = new HashMap();--newline--        used = new boolean[maxChoosableInteger+1];--newline--        return helper(desiredTotal);--newline--    }--newline--    --newline--    public boolean helper(int desiredTotal){--newline--        if(desiredTotal <= 0) return false;--newline--        int key = format(used);--newline--        if(!map.containsKey(key)){--newline--    // try every unchosen number as next step--newline--            for(int i=1; i<used.length; i++){--newline--                if(!used[i]){--newline--                    used[i] = true;--newline--     // check whether this lead to a win (i.e. the other player lose)--newline--                    if(!helper(desiredTotal-i)){--newline--                        map.put(key, true);--newline--                        used[i] = false;--newline--                        return true;--newline--                    }--newline--                    used[i] = false;--newline--                }--newline--            }--newline--            map.put(key, false);--newline--        }--newline--        return map.get(key);--newline--    }--newline--   --newline--// transfer boolean[] to an Integer --newline--    public int format(boolean[] used){--newline--        int num = 0;--newline--        for(boolean b: used){--newline--            num <<= 1;--newline--            if(b) num |= 1;--newline--        }--newline--        return num;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using HashMap with detailed explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--        def canIWin(self, maxChoosableInteger, desiredTotal):--newline----tab--            \"\"\"--newline----tab--            :type maxChoosableInteger: int--newline----tab--            :type desiredTotal: int--newline----tab--            :rtype: bool--newline----tab--            \"\"\"--newline----tab--            if (1 + maxChoosableInteger) * maxChoosableInteger/2 < desiredTotal:--newline----tab--                return False--newline----tab--            self.memo = {}--newline----tab--            return self.helper(range(1, maxChoosableInteger + 1), desiredTotal)--newline----tab--    --newline----tab--            --newline----tab--        def helper(self, nums, desiredTotal):--newline----tab--            --newline----tab--            hash = str(nums)--newline----tab--            if hash in self.memo:--newline----tab--                return self.memo[hash]--newline----tab--            --newline----tab--            if nums[-1] >= desiredTotal:--newline----tab--                return True--newline----tab--                --newline----tab--            for i in range(len(nums)):--newline----tab--                if not self.helper(nums[:i] + nums[i+1:], desiredTotal - nums[i]):--newline----tab--                    self.memo[hash]= True--newline----tab--                    return True--newline----tab--            self.memo[hash] = False--newline----tab--            return False",
            "topic_title": "Python solution, easy to understand"
        },
        {
            "java": "public class Solution {--newline----newline--    private Boolean[] win;--newline--    int choosen = 0;--newline----newline--    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {--newline--        if (desiredTotal == 0) {--newline--            return true;--newline--        }--newline--        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) {--newline--            return false;--newline--        }--newline--        win = new Boolean[1 << maxChoosableInteger];--newline--        return canWin(maxChoosableInteger, desiredTotal, 0);--newline--    }--newline----newline--    private boolean canWin(int n, int total, int now) {--newline--        if (win[choosen] != null)--newline--            return win[choosen];--newline--        if (now >= total) {--newline--            win[choosen] = false;--newline--            return false;--newline--        }--newline--        for (int i = 1; i <= n; i++) {--newline--            int bit = 1 << (i - 1);--newline--            if ((choosen & bit) == 0) {--newline--                choosen ^= bit;--newline--                boolean ulose = !canWin(n, total, now + i);--newline--                choosen ^= bit;--newline----newline--                if (ulose) {--newline--                    win[choosen] = true;--newline--                    return true;--newline--                }--newline--            }--newline--        }--newline--        win[choosen] = false;--newline--        return false;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution"
        },
        {
            "java": "public class Solution {--newline--    Map<Integer, Boolean> set[];--newline--    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {--newline--        if(maxChoosableInteger >= desiredTotal) return true;--newline--        if(maxChoosableInteger+1 >=desiredTotal) return false;--newline--        set = new Map[301];--newline--        for(int i  =0 ;i<301;i++) set[i] = new HashMap<>();--newline--        if(maxChoosableInteger*(maxChoosableInteger+1)/2 < desiredTotal) return false;--newline--        return canWin((1<<maxChoosableInteger+1)-1, desiredTotal);--newline--    }--newline--    --newline--    public boolean canWin(int set1, int total){--newline--        if(set[total].containsKey(set1)) return set[total].get(set1);--newline--        for(int i = 20;i>=1;i--){--newline--            int p = (1<<i);--newline--            if((p&set1) == p){--newline--                int set1next = (set1^p);--newline--                int totalNext = total - i;--newline--                if(totalNext<=0) return true;--newline--                boolean x;--newline--                if(set[totalNext].containsKey(set1next)) x = set[totalNext].get(set1next);--newline--                else x = canWin(set1next, totalNext);--newline--                if(!x){--newline--                    set[total].put(set1, true);--newline--                    return true;--newline--                }--newline--            }--newline--        }--newline--        set[total].put(set1, false);--newline--        return false;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java easy strightforward solution with explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--    unordered_map<unsigned int,bool> cache;--newline--public:--newline--    bool canIWin(int maxChoosableInteger, int desiredTotal) {--newline--        if(maxChoosableInteger>=desiredTotal) return true;--newline--        //the sum of all available numbers are less than desireTotal, which means it cannot reach the desireTotal--newline--        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;--newline--        unsigned int used = (1<<maxChoosableInteger)-1; // use bit to record which number has been used (bit '1' means available, bit '0' means used)--newline--        return play(desiredTotal,used,maxChoosableInteger);--newline--    }--newline--    bool play(int target, unsigned int used, int size){--newline--        if(cache.find(used) != cache.end()) return cache[used];--newline--        //exist available integer >= target, return true--newline--        if(target-1<size && (used > (1<<target-1))){--newline--            cache[used] = true;--newline--            return true;--newline--        }--newline--        int bit = 1;--newline--        for(int i = 0; i<size; i++,bit <<=1){--newline--            if((used & bit)== 0) continue; // the (i+1)th bit is '0', means (i+1) is used--newline--            used ^= bit;--newline--            if(!play(target-i-1,used,size)){--newline--                used |= bit;--newline--                cache[used] = true;--newline--                return true;--newline--            }--newline--            used |= bit;--newline--        }--newline--        cache[used] =  false;--newline--        return false;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ easy understood 269ms solution with comments"
        }
    ],
    "qc": "464.json"
}