{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int findMaximumXOR(int[] nums) {--newline--        int max = 0, mask = 0;--newline--        for(int i = 31; i >= 0; i--){--newline--            mask = mask | (1 << i);--newline--            Set<Integer> set = new HashSet<>();--newline--            for(int num : nums){--newline--                set.add(num & mask);--newline--            }--newline--            int tmp = max | (1 << i);--newline--            for(int prefix : set){--newline--                if(set.contains(tmp ^ prefix)) {--newline--                    max = tmp;--newline--                    break;--newline--                }--newline--            }--newline--        }--newline--        return max;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java O(n) solution using bit manipulation and HashMap"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def findMaximumXOR(self, nums):--newline----tab--        answer = 0--newline----tab--        for i in range(32)[::-1]:--newline----tab--            answer <<= 1--newline----tab--            prefixes = {num >> i for num in nums}--newline----tab--            answer += any(answer^1 ^ p in prefixes for p in prefixes)--newline----tab--        return answer--newline----tab--    ",
            "topic_title": "Python 6 lines, bit by bit"
        },
        {
            "java": "    class Trie {--newline--        Trie[] children;--newline--        public Trie() {--newline--            children = new Trie[2];--newline--        }--newline--    }--newline--    --newline--    public int findMaximumXOR(int[] nums) {--newline--        if(nums == null || nums.length == 0) {--newline--            return 0;--newline--        }--newline--        // Init Trie.--newline--        Trie root = new Trie();--newline--        for(int num: nums) {--newline--            Trie curNode = root;--newline--            for(int i = 31; i >= 0; i --) {--newline--                int curBit = (num >>> i) & 1;--newline--                if(curNode.children[curBit] == null) {--newline--                    curNode.children[curBit] = new Trie();--newline--                }--newline--                curNode = curNode.children[curBit];--newline--            }--newline--        }--newline--        int max = Integer.MIN_VALUE;--newline--        for(int num: nums) {--newline--            Trie curNode = root;--newline--            int curSum = 0;--newline--            for(int i = 31; i >= 0; i --) {--newline--                int curBit = (num >>> i) & 1;--newline--                if(curNode.children[curBit ^ 1] != null) {--newline--                    curSum += (1 << i);--newline--                    curNode = curNode.children[curBit ^ 1];--newline--                }else {--newline--                    curNode = curNode.children[curBit];--newline--                }--newline--            }--newline--            max = Math.max(curSum, max);--newline--        }--newline--        return max;--newline--    }--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java O(n) solution using Trie"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    class TreeNode {--newline--    public:--newline--        TreeNode* next[2];--newline--        TreeNode () {next[0] = NULL; next[1] = NULL;};--newline--    };--newline--    TreeNode* buildTree(vector<int>& nums) {--newline--        TreeNode* root = new TreeNode(), *cur;--newline--        int n = nums.size();--newline--        for (int i = 0; i < n; i++) {--newline--            int num = nums[i];--newline--            cur = root;--newline--            for (int j = 31; j >= 0; j--) {--newline--                int index = ((num >> j) & 1);--newline--                if (cur->next[index] ==  NULL)--newline--                    cur->next[index] = new TreeNode();--newline--                cur = cur->next[index];--newline--            }--newline--        }--newline--        return root;--newline--    }--newline--    --newline--    int helper(TreeNode* cur, int num) {--newline--        int res = 0;--newline--        for (int i = 31; i >= 0; i--) {--newline--            int index = ((num >> i) & 1) ? 0 : 1;--newline--            if (cur->next[index]) {--newline--                res <<= 1;--newline--                res |= 1;--newline--                cur = cur->next[index];--newline--            } else {--newline--                res <<= 1;--newline--                res |= 0;--newline--                cur = cur->next[index ? 0 : 1];--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--    --newline--    int findMaximumXOR(vector<int>& nums) {--newline--        int res = 0;--newline--        TreeNode* root = buildTree(nums);--newline--        --newline--        for (auto i : nums) {--newline--            res = max(res, helper(root, i));--newline--        }--newline--        --newline--        return res;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ Trie 69ms beats 85%"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int findMaximumXOR(vector<int>& nums) {--newline--            int n = nums.size();--newline--            --newline--            if (n == 0 || n == 1)--newline--                return 0;--newline--            if (n == 2)--newline--                return nums.at(0) ^ nums.at(1);--newline--            --newline--            list<int> set0;--newline--            list<int> set1;--newline--            int i;--newline--            int j;--newline--            int maxValue;--newline--            --newline--            for (i = 30; i >= 0; i--) {--newline--                for (j = 0; j < n; j++) {--newline--                    if ((nums.at(j) & (1<<i)) == 0)--newline--                        set0.push_back(nums.at(j));--newline--                    else--newline--                        set1.push_back(nums.at(j));--newline--                }--newline--                --newline--                if (set0.size() != 0 && set1.size() != 0) {--newline--                    maxValue = pow(2, i);--newline--                    break;--newline--                }--newline--                else {--newline--                    set0.clear();--newline--                    set1.clear();--newline--                }--newline--            }--newline--            --newline--            if (i == -1)--newline--                return 0;--newline--            --newline--            maxValue += getMaxXor(set0, set1, i-1);--newline--            --newline--            return maxValue;--newline--    }--newline--    --newline--    int getMaxXor(list<int>& set0, list<int>& set1, int pos) {--newline--            int maxValue;--newline--            list<int> set0list0;--newline--            list<int> set0list1;--newline--            list<int> set1list0;--newline--            list<int> set1list1;--newline--            int i;--newline--            list<int>::iterator it;--newline--            --newline--            if (set0.size() == 0 || set1.size() == 0 || pos < 0)--newline--                return 0;--newline--            --newline--            for (it = set0.begin(); it != set0.end(); it++) {--newline--                int value = *it;--newline--                if ((value & (1<<pos)) == 0)--newline--                    set0list0.push_back(value);--newline--                else--newline--                    set0list1.push_back(value);--newline--            }--newline--            --newline--            for (it = set1.begin(); it != set1.end(); it++) {--newline--                int value = *it;--newline--                if ((value & (1<<pos)) == 0)--newline--                    set1list0.push_back(value);--newline--                else--newline--                    set1list1.push_back(value);--newline--            }--newline--            --newline--            if (set0list0.size() == 0 && set1list0.size() == 0)--newline--                maxValue = getMaxXor(set0, set1, pos-1);--newline--            else if (set0list1.size() == 0 && set1list1.size() == 0)--newline--                maxValue = getMaxXor(set0, set1, pos-1);--newline--            else {--newline--                int maxValue1 = getMaxXor(set0list0, set1list1, pos-1);--newline--                int maxValue2 = getMaxXor(set0list1, set1list0, pos-1);--newline--                maxValue = pow(2, pos) + (maxValue1 > maxValue2 ? maxValue1 : maxValue2);--newline--            }--newline--            --newline--            return maxValue;--newline--     }--newline--    --newline--}",
            "python": null,
            "topic_title": "C++, O(n) solution, explanation added"
        }
    ],
    "qc": "421.json"
}