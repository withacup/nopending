{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int kthSmallest(int[][] matrix, int k) {--newline--        int lo = matrix[0][0], hi = matrix[matrix.length - 1][matrix[0].length - 1] + 1;//[lo, hi)--newline--        while(lo < hi) {--newline--            int mid = lo + (hi - lo) / 2;--newline--            int count = 0,  j = matrix[0].length - 1;--newline--            for(int i = 0; i < matrix.length; i++) {--newline--                while(j >= 0 && matrix[i][j] > mid) j--;--newline--                count += (j + 1);--newline--            }--newline--            if(count < k) lo = mid + 1;--newline--            else hi = mid;--newline--        }--newline--        return lo;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Share my thoughts and Clean Java Code"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution--newline--{--newline--public:--newline----tab--int kthSmallest(vector<vector<int>>& matrix, int k)--newline----tab--{--newline----tab----tab--int n = matrix.size();--newline----tab----tab--int le = matrix[0][0], ri = matrix[n - 1][n - 1];--newline----tab----tab--int mid = 0;--newline----tab----tab--while (le < ri)--newline----tab----tab--{--newline----tab----tab----tab--mid = le + (ri-le)/2;--newline----tab----tab----tab--int num = 0;--newline----tab----tab----tab--for (int i = 0; i < n; i++)--newline----tab----tab----tab--{--newline----tab----tab----tab----tab--int pos = upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin();--newline----tab----tab----tab----tab--num += pos;--newline----tab----tab----tab--}--newline----tab----tab----tab--if (num < k)--newline----tab----tab----tab--{--newline----tab----tab----tab----tab--le = mid + 1;--newline----tab----tab----tab--}--newline----tab----tab----tab--else--newline----tab----tab----tab--{--newline----tab----tab----tab----tab--ri = mid;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return le;--newline----tab--}--newline--};--newline--",
            "python": null,
            "topic_title": "My solution using Binary Search in C++"
        },
        {
            "java": "public class Solution {--newline--    public int kthSmallest(int[][] matrix, int k) {--newline--        int n = matrix.length;--newline--        int lo = matrix[0][0], hi = matrix[n - 1][n - 1];--newline--        while (lo <= hi) {--newline--            int mid = lo + (hi - lo) / 2;--newline--            int count = getLessEqual(matrix, mid);--newline--            if (count < k) lo = mid + 1;--newline--            else hi = mid - 1;--newline--        }--newline--        return lo;--newline--    }--newline--    --newline--    private int getLessEqual(int[][] matrix, int val) {--newline--        int res = 0;--newline--        int n = matrix.length, i = n - 1, j = 0;--newline--        while (i >= 0 && j < n) {--newline--            if (matrix[i][j] > val) i--;--newline--            else {--newline--                res += i + 1;--newline--                j++;--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java 1ms nlog(max -min) solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def kthSmallest(self, matrix, k):--newline----tab----newline----tab--        # The median-of-medians selection function.--newline----tab--        def pick(a, k):--newline----tab--            if k == 1:--newline----tab--                return min(a)--newline----tab--            groups = (a[i:i+5] for i in range(0, len(a), 5))--newline----tab--            medians = [sorted(group)[len(group) / 2] for group in groups]--newline----tab--            pivot = pick(medians, len(medians) / 2 + 1)--newline----tab--            smaller = [x for x in a if x < pivot]--newline----tab--            if k <= len(smaller):--newline----tab--                return pick(smaller, k)--newline----tab--            k -= len(smaller) + a.count(pivot)--newline----tab--            return pivot if k < 1 else pick([x for x in a if x > pivot], k)--newline----tab----newline----tab--        # Find the k1-th and k2th smallest entries in the submatrix.--newline----tab--        def biselect(index, k1, k2):--newline----tab----newline----tab--            # Provide the submatrix.--newline----tab--            n = len(index)--newline----tab--            def A(i, j):--newline----tab--                return matrix[index[i]][index[j]]--newline----tab--            --newline----tab--            # Base case.--newline----tab--            if n <= 2:--newline----tab--                nums = sorted(A(i, j) for i in range(n) for j in range(n))--newline----tab--                return nums[k1-1], nums[k2-1]--newline----tab----newline----tab--            # Solve the subproblem.--newline----tab--            index_ = index[::2] + index[n-1+n%2:]--newline----tab--            k1_ = (k1 + 2*n) / 4 + 1 if n % 2 else n + 1 + (k1 + 3) / 4--newline----tab--            k2_ = (k2 + 3) / 4--newline----tab--            a, b = biselect(index_, k1_, k2_)--newline----tab----newline----tab--            # Prepare ra_less, rb_more and L with saddleback search variants.--newline----tab--            ra_less = rb_more = 0--newline----tab--            L = []--newline----tab--            jb = n   # jb is the first where A(i, jb) is larger than b.--newline----tab--            ja = n   # ja is the first where A(i, ja) is larger than or equal to a.--newline----tab--            for i in range(n):--newline----tab--                while jb and A(i, jb - 1) > b:--newline----tab--                    jb -= 1--newline----tab--                while ja and A(i, ja - 1) >= a:--newline----tab--                    ja -= 1--newline----tab--                ra_less += ja--newline----tab--                rb_more += n - jb--newline----tab--                L.extend(A(i, j) for j in range(jb, ja))--newline----tab--                --newline----tab--            # Compute and return x and y.--newline----tab--            x = a if ra_less <= k1 - 1 else \\--newline----tab--                b if k1 + rb_more - n*n <= 0 else \\--newline----tab--                pick(L, k1 + rb_more - n*n)--newline----tab--            y = a if ra_less <= k2 - 1 else \\--newline----tab--                b if k2 + rb_more - n*n <= 0 else \\--newline----tab--                pick(L, k2 + rb_more - n*n)--newline----tab--            return x, y--newline----tab----newline----tab--        # Set up and run the search.--newline----tab--        n = len(matrix)--newline----tab--        start = max(k - n*n + n-1, 0)--newline----tab--        k -= n*n - (n - start)**2--newline----tab--        return biselect(range(start, min(n, start+k)), k, k)[0]--newline----tab--",
            "topic_title": "O(n) from paper. Yes, O(#rows)."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--struct compare--newline--{--newline--    bool operator()(const pair<int,pair<int, int> >& a, const pair<int,pair<int, int> >& b)--newline--    {--newline--        return a.first>b.first;--newline--    }--newline--};--newline--    int kthSmallest(vector<vector<int>>& arr, int k) {--newline--        --newline--        int n=arr.size(),m=arr[0].size();--newline--        --newline--        priority_queue< pair<int,pair<int, int> >, vector<pair<int, pair<int, int> > >, compare > p;--newline--        --newline--        for(int i=0;i<n;i++)--newline--        p.push(make_pair(arr[i][0],make_pair(i,0)));--newline--        --newline--        int x=k,ans;--newline--        while(x--)--newline--        {--newline--            int e=p.top().first;--newline--            int i=p.top().second.first;--newline--            int j=p.top().second.second;--newline--            ans=e;--newline--            p.pop();--newline--            if(j!=m-1)--newline--            p.push(make_pair(arr[i][j+1],make_pair(i,j+1)));--newline--        }--newline--        return ans;--newline--        --newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ priority queue solution O(klogn)"
        }
    ],
    "qc": "378.json"
}