{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int[] findOrder(int numCourses, int[][] prerequisites) {--newline--        int[] incLinkCounts = new int[numCourses];--newline--        List<List<Integer>> adjs = new ArrayList<>(numCourses);--newline--        initialiseGraph(incLinkCounts, adjs, prerequisites);--newline--        //return solveByBFS(incLinkCounts, adjs);--newline--        return solveByDFS(adjs);--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Two AC solution in Java using BFS and DFS with explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<int> findOrder(int numCourses, vector<pair<int, int>>& prerequisites) {--newline--        vector<unordered_set<int>> graph = make_graph(numCourses, prerequisites);--newline--        vector<int> toposort;--newline--        vector<bool> onpath(numCourses, false), visited(numCourses, false);--newline--        for (int i = 0; i < numCourses; i++)--newline--            if (!visited[i] && dfs(graph, i, onpath, visited, toposort))--newline--                return {};--newline--        reverse(toposort.begin(), toposort.end());--newline--        return toposort;--newline--    }--newline--private:--newline--    vector<unordered_set<int>> make_graph(int numCourses, vector<pair<int, int>>& prerequisites) {--newline--        vector<unordered_set<int>> graph(numCourses);--newline--        for (auto pre : prerequisites)--newline--            graph[pre.second].insert(pre.first);--newline--        return graph;--newline--    }--newline--    bool dfs(vector<unordered_set<int>>& graph, int node, vector<bool>& onpath, vector<bool>& visited, vector<int>& toposort) { --newline--        if (visited[node]) return false;--newline--        onpath[node] = visited[node] = true; --newline--        for (int neigh : graph[node])--newline--            if (onpath[neigh] || dfs(graph, neigh, onpath, visited, toposort))--newline--                return true;--newline--        toposort.push_back(node);--newline--        return onpath[node] = false;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "20+ lines C++ BFS&#x2F;DFS Solutions"
        },
        {
            "java": "public class Solution {--newline--    public int[] findOrder(int numCourses, int[][] prerequisites) {--newline--        List<List<Integer>> adj = new ArrayList<>(numCourses);--newline--        for (int i = 0; i < numCourses; i++) adj.add(i, new ArrayList<>());--newline--        for (int i = 0; i < prerequisites.length; i++) adj.get(prerequisites[i][1]).add(prerequisites[i][0]);--newline--        boolean[] visited = new boolean[numCourses];--newline--        Stack<Integer> stack = new Stack<>();--newline--        for (int i = 0; i < numCourses; i++) {--newline--            if (!topologicalSort(adj, i, stack, visited, new boolean[numCourses])) return new int[0];--newline--        }--newline--        int i = 0;--newline--        int[] result = new int[numCourses];--newline--        while (!stack.isEmpty()) {--newline--            result[i++] = stack.pop();--newline--        }--newline--        return result;--newline--    }--newline--    --newline--    private boolean topologicalSort(List<List<Integer>> adj, int v, Stack<Integer> stack, boolean[] visited, boolean[] isLoop) {--newline--        if (visited[v]) return true;--newline--        if (isLoop[v]) return false;--newline--        isLoop[v] = true;--newline--        for (Integer u : adj.get(v)) {--newline--            if (!topologicalSort(adj, u, stack, visited, isLoop)) return false;--newline--        }--newline--        visited[v] = true;--newline--        stack.push(v);--newline--        return true;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java DFS double cache visiting each vertex once 433ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    # BFS--newline----tab--    def findOrder1(self, numCourses, prerequisites):--newline----tab--        dic = {i: set() for i in xrange(numCourses)}--newline----tab--        neigh = collections.defaultdict(set)--newline----tab--        for i, j in prerequisites:--newline----tab--            dic[i].add(j)--newline----tab--            neigh[j].add(i)--newline----tab--        # queue stores the courses which have no prerequisites--newline----tab--        queue = collections.deque([i for i in dic if not dic[i]])--newline----tab--        count, res = 0, []--newline----tab--        while queue:--newline----tab--            node = queue.popleft()--newline----tab--            res.append(node)--newline----tab--            count += 1--newline----tab--            for i in neigh[node]:--newline----tab--                dic[i].remove(node)--newline----tab--                if not dic[i]:--newline----tab--                    queue.append(i)--newline----tab--        return res if count == numCourses else []--newline----tab--        --newline----tab--    # DFS--newline----tab--    def findOrder(self, numCourses, prerequisites):--newline----tab--        dic = collections.defaultdict(set)--newline----tab--        neigh = collections.defaultdict(set)--newline----tab--        for i, j in prerequisites:--newline----tab--            dic[i].add(j)--newline----tab--            neigh[j].add(i)--newline----tab--        stack = [i for i in xrange(numCourses) if not dic[i]]--newline----tab--        res = []--newline----tab--        while stack:--newline----tab--            node = stack.pop()--newline----tab--            res.append(node)--newline----tab--            for i in neigh[node]:--newline----tab--                dic[i].remove(node)--newline----tab--                if not dic[i]:--newline----tab--                    stack.append(i)--newline----tab--            dic.pop(node)--newline----tab--        return res if not dic else []",
            "topic_title": "Python dfs, bfs solutions with comments."
        },
        {
            "java": "public class Solution {--newline--    public int[] findOrder(int numCourses, int[][] prerequisites) { --newline--        if (numCourses == 0) return null;--newline--        // Convert graph presentation from edges to indegree of adjacent list.--newline--        int indegree[] = new int[numCourses], order[] = new int[numCourses], index = 0;--newline--        for (int i = 0; i < prerequisites.length; i++) // Indegree - how many prerequisites are needed.--newline--            indegree[prerequisites[i][0]]++;    --newline--    --newline--        Queue<Integer> queue = new LinkedList<Integer>();--newline--        for (int i = 0; i < numCourses; i++) --newline--            if (indegree[i] == 0) {--newline--                // Add the course to the order because it has no prerequisites.--newline--                order[index++] = i;--newline--                queue.offer(i);--newline--            }--newline--    --newline--        // How many courses don't need prerequisites. --newline--        while (!queue.isEmpty()) {--newline--            int prerequisite = queue.poll(); // Already finished this prerequisite course.--newline--            for (int i = 0; i < prerequisites.length; i++)  {--newline--                if (prerequisites[i][1] == prerequisite) {--newline--                    indegree[prerequisites[i][0]]--; --newline--                    if (indegree[prerequisites[i][0]] == 0) {--newline--                        // If indegree is zero, then add the course to the order.--newline--                        order[index++] = prerequisites[i][0];--newline--                        queue.offer(prerequisites[i][0]);--newline--                    }--newline--                } --newline--            }--newline--        }--newline--    --newline--        return (index == numCourses) ? order : new int[0];--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Concise JAVA solution based on BFS with comments"
        }
    ],
    "qc": "210.json"
}