{
    "posts": [
        {
            "java": "public class SummaryRanges {--newline--    TreeMap<Integer, Interval> tree;--newline----newline--    public SummaryRanges() {--newline--        tree = new TreeMap<>();--newline--    }--newline----newline--    public void addNum(int val) {--newline--        if(tree.containsKey(val)) return;--newline--        Integer l = tree.lowerKey(val);--newline--        Integer h = tree.higherKey(val);--newline--        if(l != null && h != null && tree.get(l).end + 1 == val && h == val + 1) {--newline--            tree.get(l).end = tree.get(h).end;--newline--            tree.remove(h);--newline--        } else if(l != null && tree.get(l).end + 1 >= val) {--newline--            tree.get(l).end = Math.max(tree.get(l).end, val);--newline--        } else if(h != null && h == val + 1) {--newline--            tree.put(val, new Interval(val, tree.get(h).end));--newline--            tree.remove(h);--newline--        } else {--newline--            tree.put(val, new Interval(val, val));--newline--        }--newline--    }--newline----newline--    public List<Interval> getIntervals() {--newline--        return new ArrayList<>(tree.values());--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using TreeMap, real O(logN) per adding."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class SummaryRanges {--newline--public:--newline--    /** Initialize your data structure here. */--newline--    void addNum(int val) {--newline--        auto it = st.lower_bound(Interval(val, val));--newline--        int start = val, end = val;--newline--        if(it != st.begin() && (--it)->end+1 < val) it++;--newline--        while(it != st.end() && val+1 >= it->start && val-1 <= it->end)--newline--        {--newline--            start = min(start, it->start);--newline--            end = max(end, it->end);--newline--            it = st.erase(it);--newline--        }--newline--        st.insert(it,Interval(start, end));--newline--    }--newline--    --newline--    vector<Interval> getIntervals() {--newline--        vector<Interval> result;--newline--        for(auto val: st) result.push_back(val);--newline--        return result;--newline--    }--newline--private:--newline--    struct Cmp{--newline--        bool operator()(Interval a, Interval b){ return a.start < b.start; }--newline--    };--newline--    set<Interval, Cmp> st;--newline--};",
            "python": null,
            "topic_title": "Very concise c++ solution."
        },
        {
            "java": "public class SummaryRanges {--newline--    class BSTNode {--newline--        Interval interval;--newline--        BSTNode left;--newline--        BSTNode right;--newline--        BSTNode(Interval in){--newline--            interval = in;--newline--        }--newline--    }--newline--    --newline--    BSTNode findMin(BSTNode root) {--newline--        if (root == null) return null;--newline--        if (root.left == null ) return root;--newline--        else return findMin(root.left);--newline--    }--newline--    --newline--    BSTNode remove(Interval x, BSTNode root) {--newline--        if (root == null) return null;--newline--        else if ( x == null ) return root;--newline--        else if (x.start > root.interval.end ) {--newline--            root.right = remove(x, root.right);--newline--        } else if (x.end < root.interval.start ) {--newline--            root.left = remove(x, root.left);--newline--        } else if ( root.left != null && root.right != null) {--newline--            root.interval = findMin(root.right).interval;--newline--            root.right = remove( root.interval, root.right);--newline--        } else {--newline--            root = ( root.left != null ) ? root.left : root.right;--newline--        }--newline--        return root;--newline--    }--newline--    --newline--    BSTNode findKey(int val, BSTNode root) {--newline--        if (root == null) return null;--newline--        if (root.interval.start > val) {--newline--            return findKey(val, root.left);--newline--        } else if (root.interval.end < val) {--newline--            return findKey(val, root.right);--newline--        } else return root;--newline--    }--newline--    --newline--    BSTNode addKey(int val, BSTNode root) {--newline--        if (root == null) {--newline--            root = new BSTNode( new Interval(val, val) ); --newline--        } else if (root.interval.start > val) {--newline--            root.left = addKey(val, root.left);--newline--        } else if (root.interval.end < val) {--newline--            root.right = addKey(val, root.right);--newline--        }  --newline--        return root;--newline--    }--newline--    void inOrder(BSTNode root) {--newline--        if (root != null) {--newline--            inOrder(root.left);--newline--            list.add(root.interval);--newline--            inOrder(root.right);--newline--        }--newline--    }--newline--    --newline--    /** Initialize your data structure here. */--newline--    BSTNode root;--newline--    List<Interval> list = new ArrayList();--newline--    public SummaryRanges() {--newline--        root = null;--newline--    }--newline--    --newline--    public void addNum(int val) {--newline--        if (root == null) {--newline--            root = addKey(val, root);--newline--        } else {--newline--            if ( findKey(val, root) != null) return;--newline--            BSTNode left = findKey(val-1, root);--newline--            BSTNode right = findKey(val+1, root);--newline--            if (left == null && right == null) {--newline--                root = addKey(val, root);--newline--            } else if (left != null && right == null) {--newline--                left.interval.end++;--newline--            } else if (left == null && right != null) {--newline--                right.interval.start--;--newline--            } else {--newline--                Interval l = left.interval;--newline--                int e = right.interval.end;--newline--                root = remove(right.interval, root);--newline--                l.end = e;--newline--            }--newline--        }--newline--    }--newline--    --newline--    public List<Interval> getIntervals() {--newline--        list.clear();--newline--        inOrder(root);--newline--        return list;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java fast log (N) solution (186ms) without using the TreeMap but a customized BST"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class SummaryRanges(object):--newline----tab----newline----tab--  def __init__(self):--newline----tab--    self.intervals = []--newline----tab--    --newline----tab--  def addNum(self, val):--newline----tab--    heapq.heappush(self.intervals, (val, Interval(val, val)))--newline----tab--    --newline----tab--  def getIntervals(self):--newline----tab--    stack = []--newline----tab--    while self.intervals:--newline----tab--        idx, cur = heapq.heappop(self.intervals)--newline----tab--        if not stack:--newline----tab--            stack.append((idx, cur))--newline----tab--        else:--newline----tab--            _, prev = stack[-1]--newline----tab--            if prev.end + 1 >= cur.start:--newline----tab--                prev.end = max(prev.end, cur.end)--newline----tab--            else:--newline----tab--                stack.append((idx, cur))--newline----tab--    self.intervals = stack--newline----tab--    return list(map(lambda x: x[1], stack))",
            "topic_title": "Share my python solution using heap"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class SummaryRanges {--newline--private:--newline--    vector<Interval> intervals = vector<Interval>();--newline--    --newline--    int binarySearch(vector<Interval> intervals, int val) {--newline--        return binarySearchHelper(intervals, 0, intervals.size(), val);--newline--    }--newline--    --newline--    int binarySearchHelper(vector<Interval> intervals, int start, int end, int val) {--newline--        if (start == end) return -1;--newline--        if (start+1 == end && intervals[start].start < val) return start;--newline--        --newline--        int mid = (start + end)/2;--newline--        if (intervals[mid].start == val) {--newline--            return mid;--newline--        } else if (intervals[mid].start < val) {--newline--            return binarySearchHelper(intervals, mid, end, val);--newline--        } else { //intervals[mid] > val--newline--            return binarySearchHelper(intervals, start, mid, val);--newline--        }--newline--    }--newline--    --newline--public:--newline--    /** Initialize your data structure here. */--newline--    SummaryRanges() {--newline--        --newline--    }--newline--    --newline--    /** For a new number n, find the last(biggest) interval--newline--     *  [s,t], such that s < n. If no such interval exists, --newline--     *  return -1.--newline--     */--newline--    void addNum(int val) {--newline--        int index = binarySearch(intervals, val);--newline--        --newline--        // intervals[index] contains val--newline--        if (index != -1 && intervals[index].end >= val) {--newline--            return;--newline--        }--newline--        --newline--        if (index != intervals.size()-1 && val + 1 == intervals[index+1].start) {--newline--            intervals[index+1].start = val;--newline--        } else if (index != -1 && val - 1 == intervals[index].end) {--newline--            intervals[index].end = val;--newline--        } else {--newline--            intervals.insert(intervals.begin() + index + 1, Interval(val, val));--newline--        }--newline--        --newline--        //merge intervals[index] with intervals[index+1]--newline--        if (index != -1 && intervals[index].end + 1 == intervals[index+1].start) {--newline--            intervals[index].end = intervals[index+1].end;--newline--            intervals.erase(intervals.begin()+index+1);--newline--        }--newline--        --newline--        return;--newline--    }--newline--    --newline--    vector<Interval> getIntervals() {--newline--        return this->intervals;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ solution using vector and binary search with explanation"
        }
    ],
    "qc": "352.json"
}