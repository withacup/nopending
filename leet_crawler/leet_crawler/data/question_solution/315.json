{
    "posts": [
        {
            "java": "public class Solution {--newline--    class Node {--newline--        Node left, right;--newline--        int val, sum, dup = 1;--newline--        public Node(int v, int s) {--newline--            val = v;--newline--            sum = s;--newline--        }--newline--    }--newline--    public List<Integer> countSmaller(int[] nums) {--newline--        Integer[] ans = new Integer[nums.length];--newline--        Node root = null;--newline--        for (int i = nums.length - 1; i >= 0; i--) {--newline--            root = insert(nums[i], root, ans, i, 0);--newline--        }--newline--        return Arrays.asList(ans);--newline--    }--newline--    private Node insert(int num, Node node, Integer[] ans, int i, int preSum) {--newline--        if (node == null) {--newline--            node = new Node(num, 0);--newline--            ans[i] = preSum;--newline--        } else if (node.val == num) {--newline--            node.dup++;--newline--            ans[i] = preSum + node.sum;--newline--        } else if (node.val > num) {--newline--            node.sum++;--newline--            node.left = insert(num, node.left, ans, i, preSum);--newline--        } else {--newline--            node.right = insert(num, node.right, ans, i, preSum + node.dup + node.sum);--newline--        }--newline--        return node;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "9ms  short Java BST solution get answer when building BST"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def countSmaller(self, nums):--newline----tab--        def sort(enum):--newline----tab--            half = len(enum) / 2--newline----tab--            if half:--newline----tab--                left, right = sort(enum[:half]), sort(enum[half:])--newline----tab--                m, n = len(left), len(right)--newline----tab--                i = j = 0--newline----tab--                while i < m or j < n:--newline----tab--                    if j == n or i < m and left[i][1] <= right[j][1]:--newline----tab--                        enum[i+j] = left[i]--newline----tab--                        smaller[left[i][0]] += j--newline----tab--                        i += 1--newline----tab--                    else:--newline----tab--                        enum[i+j] = right[j]--newline----tab--                        j += 1--newline----tab--            return enum--newline----tab--        smaller = [0] * len(nums)--newline----tab--        sort(list(enumerate(nums)))--newline----tab--        return smaller",
            "topic_title": "Mergesort solution"
        },
        {
            "java": "public class Solution {--newline--    public List<Integer> countSmaller(int[] nums) {--newline--        Integer[] ans = new Integer[nums.length];--newline--        List<Integer> sorted = new ArrayList<Integer>();--newline--        for (int i = nums.length - 1; i >= 0; i--) {--newline--            int index = findIndex(sorted, nums[i]);--newline--            ans[i] = index;--newline--            sorted.add(index, nums[i]);--newline--        }--newline--        return Arrays.asList(ans);--newline--    }--newline--    private int findIndex(List<Integer> sorted, int target) {--newline--        if (sorted.size() == 0) return 0;--newline--        int start = 0;--newline--        int end = sorted.size() - 1;--newline--        if (sorted.get(end) < target) return end + 1;--newline--        if (sorted.get(start) >= target) return 0;--newline--        while (start + 1 < end) {--newline--            int mid = start + (end - start) / 2;--newline--            if (sorted.get(mid) < target) {--newline--                start = mid + 1;--newline--            } else {--newline--                end = mid;--newline--            }--newline--        }--newline--        if (sorted.get(start) >= target) return start;--newline--        return end;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "My simple AC Java Binary Search code"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--protected:--newline--    void merge_countSmaller(vector<int>& indices, int first, int last, --newline--                            vector<int>& results, vector<int>& nums) {--newline--        int count = last - first;--newline--        if (count > 1) {--newline--            int step = count / 2;--newline--            int mid = first + step;--newline--            merge_countSmaller(indices, first, mid, results, nums);--newline--            merge_countSmaller(indices, mid, last, results, nums);--newline--            vector<int> tmp;--newline--            tmp.reserve(count);--newline--            int idx1 = first;--newline--            int idx2 = mid;--newline--            int semicount = 0;--newline--            while ((idx1 < mid) || (idx2 < last)) {--newline--                if ((idx2 == last) || ((idx1 < mid) &&--newline--                       (nums[indices[idx1]] <= nums[indices[idx2]]))) {--newline----tab----tab----tab----tab----tab--tmp.push_back(indices[idx1]);--newline--                    results[indices[idx1]] += semicount;--newline--                    ++idx1;--newline--                } else {--newline----tab----tab----tab----tab----tab--tmp.push_back(indices[idx2]);--newline--                    ++semicount;--newline--                    ++idx2;--newline--                }--newline--            }--newline--            move(tmp.begin(), tmp.end(), indices.begin()+first);--newline--        }--newline--    }--newline--public:--newline--    vector<int> countSmaller(vector<int>& nums) {--newline--        int n = nums.size();--newline--        vector<int> results(n, 0);--newline--        vector<int> indices(n, 0);--newline--        iota(indices.begin(), indices.end(), 0);--newline--        merge_countSmaller(indices, 0, n, results, nums);--newline--        return results;--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ O(nlogn)-Time O(n)-Space MergeSort Solution with Detail Explanation"
        },
        {
            "java": "public class Solution {--newline--    int[] count;--newline--    public List<Integer> countSmaller(int[] nums) {--newline--        List<Integer> res = new ArrayList<Integer>();     --newline--    --newline--        count = new int[nums.length];--newline--        int[] indexes = new int[nums.length];--newline--        for(int i = 0; i < nums.length; i++){--newline--        --tab--indexes[i] = i;--newline--        }--newline--        mergesort(nums, indexes, 0, nums.length - 1);--newline--        for(int i = 0; i < count.length; i++){--newline--        --tab--res.add(count[i]);--newline--        }--newline--        return res;--newline--    }--newline--    private void mergesort(int[] nums, int[] indexes, int start, int end){--newline--    --tab--if(end <= start){--newline--    --tab----tab--return;--newline--    --tab--}--newline--    --tab--int mid = (start + end) / 2;--newline--    --tab--mergesort(nums, indexes, start, mid);--newline--    --tab--mergesort(nums, indexes, mid + 1, end);--newline--    --tab----newline--    --tab--merge(nums, indexes, start, end);--newline--    }--newline--    private void merge(int[] nums, int[] indexes, int start, int end){--newline--    --tab--int mid = (start + end) / 2;--newline--    --tab--int left_index = start;--newline--    --tab--int right_index = mid+1;--newline--    --tab--int rightcount = 0;    --tab----newline--    --tab--int[] new_indexes = new int[end - start + 1];--newline--    --newline--    --tab--int sort_index = 0;--newline--    --tab--while(left_index <= mid && right_index <= end){--newline--    --tab----tab--if(nums[indexes[right_index]] < nums[indexes[left_index]]){--newline--    --tab----tab----tab--new_indexes[sort_index] = indexes[right_index];--newline--    --tab----tab----tab--rightcount++;--newline--    --tab----tab----tab--right_index++;--newline--    --tab----tab--}else{--newline--    --tab----tab----tab--new_indexes[sort_index] = indexes[left_index];--newline--    --tab----tab----tab--count[indexes[left_index]] += rightcount;--newline--    --tab----tab----tab--left_index++;--newline--    --tab----tab--}--newline--    --tab----tab--sort_index++;--newline--    --tab--}--newline--    --tab--while(left_index <= mid){--newline--    --tab----tab--new_indexes[sort_index] = indexes[left_index];--newline--    --tab----tab--count[indexes[left_index]] += rightcount;--newline--    --tab----tab--left_index++;--newline--    --tab----tab--sort_index++;--newline--    --tab--}--newline--    --tab--while(right_index <= end){--newline--    --tab----tab--new_indexes[sort_index++] = indexes[right_index++];--newline--    --tab--}--newline--    --tab--for(int i = start; i <= end; i++){--newline--    --tab----tab--indexes[i] = new_indexes[i - start];--newline--    --tab--}--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "11ms JAVA solution using merge sort with explanation"
        }
    ],
    "qc": "315.json"
}