{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "         X X X X           X X X X             X X X X--newline--         X X O X  ->       X X O X    ->       X X X X--newline--         X O X X           X 1 X X             X O X X--newline--         X O X X           X 1 X X             X O X X--newline--    --newline----newline--class Solution {--newline--public:--newline----tab--void solve(vector<vector<char>>& board) {--newline--        int i,j;--newline--        int row=board.size();--newline--        if(!row)--newline--        --tab--return;--newline--        int col=board[0].size();--newline----newline----tab----tab--for(i=0;i<row;i++){--newline----tab----tab----tab--check(board,i,0,row,col);--newline----tab----tab----tab--if(col>1)--newline----tab----tab----tab----tab--check(board,i,col-1,row,col);--newline----tab----tab--}--newline----tab----tab--for(j=1;j+1<col;j++){--newline----tab----tab----tab--check(board,0,j,row,col);--newline----tab----tab----tab--if(row>1)--newline----tab----tab----tab----tab--check(board,row-1,j,row,col);--newline----tab----tab--}--newline----tab----tab--for(i=0;i<row;i++)--newline----tab----tab----tab--for(j=0;j<col;j++)--newline----tab----tab----tab----tab--if(board[i][j]=='O')--newline----tab----tab----tab----tab----tab--board[i][j]='X';--newline----tab----tab--for(i=0;i<row;i++)--newline----tab----tab----tab--for(j=0;j<col;j++)--newline----tab----tab----tab----tab--if(board[i][j]=='1')--newline----tab----tab----tab----tab----tab--board[i][j]='O';--newline--    }--newline----tab--void check(vector<vector<char> >&vec,int i,int j,int row,int col){--newline----tab----tab--if(vec[i][j]=='O'){--newline----tab----tab----tab--vec[i][j]='1';--newline----tab----tab----tab--if(i>1)--newline----tab----tab----tab----tab--check(vec,i-1,j,row,col);--newline----tab----tab----tab--if(j>1)--newline----tab----tab----tab----tab--check(vec,i,j-1,row,col);--newline----tab----tab----tab--if(i+1<row)--newline----tab----tab----tab----tab--check(vec,i+1,j,row,col);--newline----tab----tab----tab--if(j+1<col)--newline----tab----tab----tab----tab--check(vec,i,j+1,row,col);--newline----tab----tab--}--newline----tab--}--newline--};",
            "python": null,
            "topic_title": "A really simple and readable C++ solution\uff0conly cost 12ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class UF--newline--{--newline--private:--newline----tab--int* id;     // id[i] = parent of i--newline----tab--int* rank;  // rank[i] = rank of subtree rooted at i (cannot be more than 31)--newline----tab--int count;    // number of components--newline--public:--newline----tab--UF(int N)--newline----tab--{--newline----tab----tab--count = N;--newline----tab----tab--id = new int[N];--newline----tab----tab--rank = new int[N];--newline----tab----tab--for (int i = 0; i < N; i++) {--newline----tab----tab----tab--id[i] = i;--newline----tab----tab----tab--rank[i] = 0;--newline----tab----tab--}--newline----tab--}--newline----tab--~UF()--newline----tab--{--newline----tab----tab--delete [] id;--newline----tab----tab--delete [] rank;--newline----tab--}--newline----tab--int find(int p) {--newline----tab----tab--while (p != id[p]) {--newline----tab----tab----tab--id[p] = id[id[p]];    // path compression by halving--newline----tab----tab----tab--p = id[p];--newline----tab----tab--}--newline----tab----tab--return p;--newline----tab--}--newline----tab--int getCount() {--newline----tab----tab--return count;--newline----tab--}--newline----tab--bool connected(int p, int q) {--newline----tab----tab--return find(p) == find(q);--newline----tab--}--newline----tab--void connect(int p, int q) {--newline----tab----tab--int i = find(p);--newline----tab----tab--int j = find(q);--newline----tab----tab--if (i == j) return;--newline----tab----tab--if (rank[i] < rank[j]) id[i] = j;--newline----tab----tab--else if (rank[i] > rank[j]) id[j] = i;--newline----tab----tab--else {--newline----tab----tab----tab--id[j] = i;--newline----tab----tab----tab--rank[i]++;--newline----tab----tab--}--newline----tab----tab--count--;--newline----tab--}--newline--};--newline----newline--class Solution {--newline--public:--newline--    void solve(vector<vector<char>> &board) {--newline--        int n = board.size();--newline--        if(n==0)    return;--newline--        int m = board[0].size();--newline--        UF uf = UF(n*m+1);--newline--        --newline--        for(int i=0;i<n;i++){--newline--            for(int j=0;j<m;j++){--newline--                if((i==0||i==n-1||j==0||j==m-1)&&board[i][j]=='O') // if a 'O' node is on the boundry, connect it to the dummy node--newline--                    uf.connect(i*m+j,n*m);--newline--                else if(board[i][j]=='O') // connect a 'O' node to its neighbour 'O' nodes--newline--                {--newline--                    if(board[i-1][j]=='O')--newline--                        uf.connect(i*m+j,(i-1)*m+j);--newline--                    if(board[i+1][j]=='O')--newline--                        uf.connect(i*m+j,(i+1)*m+j);--newline--                    if(board[i][j-1]=='O')--newline--                        uf.connect(i*m+j,i*m+j-1);--newline--                    if(board[i][j+1]=='O')--newline--                        uf.connect(i*m+j,i*m+j+1);--newline--                }--newline--            }--newline--        }--newline--        --newline--        for(int i=0;i<n;i++){--newline--            for(int j=0;j<m;j++){--newline--                if(!uf.connected(i*m+j,n*m)){ // if a 'O' node is not connected to the dummy node, it is captured--newline--                    board[i][j]='X';--newline--                }--newline--            }--newline--        }--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Solve it using Union Find"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def solve(self, board):--newline----tab--        if not any(board): return--newline----tab--    --newline----tab--        m, n = len(board), len(board[0])--newline----tab--        save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))]--newline----tab--        while save:--newline----tab--            i, j = save.pop()--newline----tab--            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':--newline----tab--                board[i][j] = 'S'--newline----tab--                save += (i, j-1), (i, j+1), (i-1, j), (i+1, j)--newline----tab--    --newline----tab--        board[:] = [['XO'[c == 'S'] for c in row] for row in board]--newline----tab--    ",
            "topic_title": "9 lines, Python 148 ms"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    void bfsBoundary(vector<vector<char> >& board, int w, int l)--newline--    {--newline--        int width = board.size();--newline--        int length = board[0].size();--newline--        deque<pair<int, int> > q;--newline--        q.push_back(make_pair(w, l));--newline--        board[w][l] = 'B';--newline--        while (!q.empty()) {--newline--            pair<int, int> cur = q.front();--newline--            q.pop_front();--newline--            pair<int, int> adjs[4] = {{cur.first-1, cur.second}, --newline--                {cur.first+1, cur.second}, --newline--                {cur.first, cur.second-1},--newline--                {cur.first, cur.second+1}};--newline--            for (int i = 0; i < 4; ++i)--newline--            {--newline--                int adjW = adjs[i].first;--newline--                int adjL = adjs[i].second;--newline--                if ((adjW >= 0) && (adjW < width) && (adjL >= 0)--newline--                        && (adjL < length) --newline--                        && (board[adjW][adjL] == 'O')) {--newline--                    q.push_back(make_pair(adjW, adjL));--newline--                    board[adjW][adjL] = 'B';--newline--                }--newline--            }--newline--        }--newline--    }--newline--    --newline--    void solve(vector<vector<char> > &board) {--newline--        int width = board.size();--newline--        if (width == 0) //Add this to prevent run-time error!--newline--            return;--newline--        int length = board[0].size();--newline--        if  (length == 0) // Add this to prevent run-time error!--newline--            return;--newline--    --newline--        for (int i = 0; i < length; ++i)--newline--        {--newline--            if (board[0][i] == 'O')--newline--                bfsBoundary(board, 0, i);--newline--    --newline--            if (board[width-1][i] == 'O')--newline--                bfsBoundary(board, width-1, i);--newline--        }--newline--    --newline--        for (int i = 0; i < width; ++i)--newline--        {--newline--            if (board[i][0] == 'O')--newline--                bfsBoundary(board, i, 0);--newline--            if (board[i][length-1] == 'O')--newline--                bfsBoundary(board, i, length-1);--newline--        }--newline--    --newline--        for (int i = 0; i < width; ++i)--newline--        {--newline--            for (int j = 0; j < length; ++j)--newline--            {--newline--                if (board[i][j] == 'O')--newline--                    board[i][j] = 'X';--newline--                else if (board[i][j] == 'B')--newline--                    board[i][j] = 'O';--newline--            }--newline--        }--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "My BFS solution (C++ 28ms)"
        },
        {
            "java": "public class Solution {--newline--    public void solve(char[][] board) {--newline--    --tab--if (board.length == 0 || board[0].length == 0)--newline--    --tab----tab--return;--newline--    --tab--if (board.length < 2 || board[0].length < 2)--newline--    --tab----tab--return;--newline--    --tab--int m = board.length, n = board[0].length;--newline--    --tab--//Any 'O' connected to a boundary can't be turned to 'X', so ...--newline--    --tab--//Start from first and last column, turn 'O' to '*'.--newline--    --tab--for (int i = 0; i < m; i++) {--newline--    --tab----tab--if (board[i][0] == 'O')--newline--    --tab----tab----tab--boundaryDFS(board, i, 0);--newline--    --tab----tab--if (board[i][n-1] == 'O')--newline--    --tab----tab----tab--boundaryDFS(board, i, n-1);--tab----newline--    --tab--}--newline--    --tab--//Start from first and last row, turn '0' to '*'--newline--    --tab--for (int j = 0; j < n; j++) {--newline--    --tab----tab--if (board[0][j] == 'O')--newline--    --tab----tab----tab--boundaryDFS(board, 0, j);--newline--    --tab----tab--if (board[m-1][j] == 'O')--newline--    --tab----tab----tab--boundaryDFS(board, m-1, j);--tab----newline--    --tab--}--newline--    --tab--//post-prcessing, turn 'O' to 'X', '*' back to 'O', keep 'X' intact.--newline--    --tab--for (int i = 0; i < m; i++) {--newline--    --tab----tab--for (int j = 0; j < n; j++) {--newline--    --tab----tab----tab--if (board[i][j] == 'O')--newline--    --tab----tab----tab----tab--board[i][j] = 'X';--newline--    --tab----tab----tab--else if (board[i][j] == '*')--newline--    --tab----tab----tab----tab--board[i][j] = 'O';--newline--    --tab----tab--}--newline--    --tab--}--newline--    }--newline--    //Use DFS algo to turn internal however boundary-connected 'O' to '*';--newline--    private void boundaryDFS(char[][] board, int i, int j) {--newline--    --tab--if (i < 0 || i > board.length - 1 || j <0 || j > board[0].length - 1)--newline--    --tab----tab--return;--newline--    --tab--if (board[i][j] == 'O')--newline--    --tab----tab--board[i][j] = '*';--newline--    --tab--if (i > 1 && board[i-1][j] == 'O')--newline--    --tab----tab--boundaryDFS(board, i-1, j);--newline--    --tab--if (i < board.length - 2 && board[i+1][j] == 'O')--newline--    --tab----tab--boundaryDFS(board, i+1, j);--newline--    --tab--if (j > 1 && board[i][j-1] == 'O')--newline--    --tab----tab--boundaryDFS(board, i, j-1);--newline--    --tab--if (j < board[i].length - 2 && board[i][j+1] == 'O' )--newline--    --tab----tab--boundaryDFS(board, i, j+1);--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java DFS + boundary cell turning solution, simple and clean code, commented."
        }
    ],
    "qc": "130.json"
}