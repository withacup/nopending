{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int strongPasswordChecker(string s) {--newline--        int deleteTarget = max(0, (int)s.length() - 20), addTarget = max(0, 6 - (int)s.length());--newline--        int toDelete = 0, toAdd = 0, toReplace = 0, needUpper = 1, needLower = 1, needDigit = 1;--newline--        --newline--        ///////////////////////////////////--newline--        // For cases of s.length() <= 20 //--newline--        ///////////////////////////////////--newline--        for (int l = 0, r = 0; r < s.length(); r++) {--newline--            if (isupper(s[r])) { needUpper = 0; }               --newline--            if (islower(s[r])) { needLower = 0; }--newline--            if (isdigit(s[r])) { needDigit = 0; }--newline--            --newline--            if (r - l == 2) {                                   // if it's a three-letter window--newline--                if (s[l] == s[l + 1] && s[l + 1] == s[r]) {     // found a three-repeating substr--newline--                    if (toAdd < addTarget) { toAdd++, l = r; }  // insert letter to break repetition if possible--newline--                    else { toReplace++, l = r + 1; }            // replace current word to avoid three repeating chars--newline--                } else { l++; }                                 // keep the window with no more than 3 letters--newline--            }--newline--        }--newline--        if (s.length() <= 20) { return max(addTarget + toReplace, needUpper + needLower + needDigit); }--newline--        --newline--        //////////////////////////////////--newline--        // For cases of s.length() > 20 //--newline--        //////////////////////////////////--newline--        toReplace = 0;                                          // reset toReplace--newline--        vector<unordered_map<int, int>> lenCnts(3);             // to record repetitions with (length % 3) == 0, 1 or 2--newline--        for (int l = 0, r = 0, len; r <= s.length(); r++) {     // record all repetion frequencies--newline--            if (r == s.length() || s[l] != s[r]) {--newline--                if ((len = r - l) > 2) { lenCnts[len % 3][len]++; } // we only care about repetions with length >= 3--newline--                l = r;--newline--            }--newline--        }--newline--        --newline--        /*--newline--            Use deletions to minimize replacements, following below orders:--newline--            (1) Try to delete one letter from repetitions with (length % 3) == 0. Each deletion decreases replacement by 1--newline--            (2) Try to delete two letters from repetitions with (length % 3) == 1. Each deletion decreases repalcement by 1--newline--            (3) Try to delete multiple of three letters from repetions with (length % 3) == 2. Each deletion (of three --newline--            letters) decreases repalcements by 1--newline--        */--newline--        for (int i = 0, numLetters, dec; i < 3; i++) {                --newline--            for (auto it = lenCnts[i].begin(); it != lenCnts[i].end(); it++) {--newline--                if (i < 2) {--newline--                    numLetters = i + 1, dec = min(it->second, (deleteTarget - toDelete) / numLetters);--newline--                    toDelete += dec * numLetters;               // dec is the number of repetitions we'll delete from--newline--                    it->second -= dec;                          // update number of repetitions left--newline--                    --newline--                    // after letters deleted, it fits in the group where (length % 3) == 2--newline--                    if (it->first - numLetters > 2) { lenCnts[2][it->first - numLetters] += dec; }   --newline--                }--newline--                --newline--                // record number of replacements needed--newline--                // note if len is the length of repetition, we need (len / 3) number of replacements--newline--                toReplace += (it->second) * ((it->first) / 3);  --newline--            }    --newline--        }--newline----newline--        int dec = (deleteTarget - toDelete) / 3;                // try to delete multiple of three letters as many as possible--newline--        toReplace -= dec, toDelete -= dec * 3;--newline--        return deleteTarget + max(toReplace, needUpper + needLower + needDigit);--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ 0ms O(n) 35 lines solution with detailed explanation"
        },
        {
            "java": "public class Solution {--newline--    public int strongPasswordChecker(String s) {--newline--        int res = 0, a = 1, A = 1, d = 1;--newline--        char[] carr = s.toCharArray();--newline--        int[] arr = new int[carr.length];--newline--            --newline--        for (int i = 0; i < arr.length;) {--newline--            if (Character.isLowerCase(carr[i])) a = 0;--newline--            if (Character.isUpperCase(carr[i])) A = 0;--newline--            if (Character.isDigit(carr[i])) d = 0;--newline--                --newline--            int j = i;--newline--            while (i < carr.length && carr[i] == carr[j]) i++;--newline--            arr[j] = i - j;--newline--        }--newline--            --newline--        int total_missing = (a + A + d);--newline--    --newline--        if (arr.length < 6) {--newline--            res += total_missing + Math.max(0, 6 - (arr.length + total_missing));--newline--                --newline--        } else {--newline--            int over_len = Math.max(arr.length - 20, 0), left_over = 0;--newline--            res += over_len;--newline--                --newline--            for (int k = 1; k < 3; k++) {--newline--                for (int i = 0; i < arr.length && over_len > 0; i++) {--newline--                    if (arr[i] < 3 || arr[i] % 3 != (k - 1)) continue;--newline--                    arr[i] -= Math.min(over_len, k);--newline--                    over_len -= k;--newline--                }--newline--            }--newline--                --newline--            for (int i = 0; i < arr.length; i++) {--newline--                if (arr[i] >= 3 && over_len > 0) {--newline--                    int need = arr[i] - 2;--newline--                    arr[i] -= over_len;--newline--                    over_len -= need;--newline--                }--newline--                    --newline--                if (arr[i] >= 3) left_over += arr[i] / 3;--newline--            }--newline--                --newline--            res += Math.max(total_missing, left_over);--newline--        }--newline--            --newline--        return res;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "O(n) java solution by analyzing changes allowed to fix each problem"
        },
        {
            "java": "public class Solution {--newline--    public int strongPasswordChecker(String s) {--newline--        --newline--        if(s.length()<2) return 6-s.length();--newline--        --newline--        //Initialize the states, including current ending character(end), existence of lowercase letter(lower), uppercase letter(upper), digit(digit) and number of replicates for ending character(end_rep)--newline--        char end = s.charAt(0);--newline--        boolean upper = end>='A'&&end<='Z', lower = end>='a'&&end<='z', digit = end>='0'&&end<='9';--newline--        --newline--        //Also initialize the number of modification for repeated characters, total number needed for eliminate all consequnce 3 same character by replacement(change), and potential maximun operation of deleting characters(delete). Note delete[0] means maximum number of reduce 1 replacement operation by 1 deletion operation, delete[1] means maximun number of reduce 1 replacement by 2 deletion operation, delete[2] is no use here. --newline--        int end_rep = 1, change = 0;--newline--        int[] delete = new int[3];--newline--        --newline--        for(int i = 1;i<s.length();++i){--newline--            if(s.charAt(i)==end) ++end_rep;--newline--            else{--newline--                change+=end_rep/3;--newline--                if(end_rep/3>0) ++delete[end_rep%3];--newline--                //updating the states--newline--                end = s.charAt(i);--newline--                upper = upper||end>='A'&&end<='Z';--newline--                lower = lower||end>='a'&&end<='z';--newline--                digit = digit||end>='0'&&end<='9';--newline--                end_rep = 1;--newline--            }--newline--        }--newline--        change+=end_rep/3;--newline--        if(end_rep/3>0) ++delete[end_rep%3];--newline--        --newline--        //The number of replcement needed for missing of specific character(lower/upper/digit)--newline--        int check_req = (upper?0:1)+(lower?0:1)+(digit?0:1);--newline--        --newline--        if(s.length()>20){--newline--            int del = s.length()-20;--newline--            --newline--            //Reduce the number of replacement operation by deletion--newline--            if(del<=delete[0]) change-=del;--newline--            else if(del-delete[0]<=2*delete[1]) change-=delete[0]+(del-delete[0])/2;--newline--            else change-=delete[0]+delete[1]+(del-delete[0]-2*delete[1])/3;--newline--            --newline--            return del+Math.max(check_req,change);--newline--        }--newline--        else return Math.max(6-s.length(), Math.max(check_req, change));--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "JAVA Easy Solution with explanation"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution(object):--newline----tab--    def strongPasswordChecker(self, s):--newline----tab--        \"\"\"--newline----tab--        :type s: str--newline----tab--        :rtype: int--newline----tab--        \"\"\"--newline----tab--        missing_type = 3--newline----tab--        if any('a' <= c <= 'z' for c in s): missing_type -= 1--newline----tab--        if any('A' <= c <= 'Z' for c in s): missing_type -= 1--newline----tab--        if any(c.isdigit() for c in s): missing_type -= 1--newline----tab----newline----tab--        change = 0--newline----tab--        one = two = 0--newline----tab--        p = 2--newline----tab--        while p < len(s):--newline----tab--            if s[p] == s[p-1] == s[p-2]:--newline----tab--                length = 2--newline----tab--                while p < len(s) and s[p] == s[p-1]:--newline----tab--                    length += 1--newline----tab--                    p += 1--newline----tab--                    --newline----tab--                change += length / 3--newline----tab--                if length % 3 == 0: one += 1--newline----tab--                elif length % 3 == 1: two += 1--newline----tab--            else:--newline----tab--                p += 1--newline----tab--        --newline----tab--        if len(s) < 6:--newline----tab--            return max(missing_type, 6 - len(s))--newline----tab--        elif len(s) <= 20:--newline----tab--            return max(missing_type, change)--newline----tab--        else:--newline----tab--            delete = len(s) - 20--newline----tab--            --newline----tab--            change -= min(delete, one)--newline----tab--            change -= min(max(delete - one, 0), two * 2) / 2--newline----tab--            change -= max(delete - one - 2 * two, 0) / 3--newline----tab--                --newline----tab--            return delete + max(missing_type, change)--newline----tab--",
            "topic_title": "Simple Python solution"
        },
        {
            "java": "public class Solution {--newline--    public int strongPasswordChecker(String s) {--newline--        int minReplace = getMinReplace(s);--newline----newline--        if (s.length() < 6){--newline--            int insersion = 6 - s.length();--newline--            return Math.max(insersion, minReplace);--newline--        } else if (s.length() <= 20){--newline--            List<Integer> groups = generateGroups(s);--newline--            int replace = 0;--newline--            for (int group : groups){--newline--                replace += group / 3;--newline--            }--newline--            return Math.max(replace, minReplace);--newline--        } else {--newline----newline--            List<Integer> groups = generateGroups(s);--newline----newline--            Collections.sort(groups);--newline----newline--            int charCount = 0;--newline--            int n = 0;--newline--            while (charCount < 20 && n < groups.size()) {--newline--                charCount += groups.get(n);--newline--                n++;--newline--            }--newline----newline--            while (groups.size() > n) {--newline--                groups.remove(groups.size() - 1);--newline--            }--newline----newline--            charCount = 0;--newline----newline--            int badGroup = 0;--newline--            for (int i = 0; i < groups.size(); i++) {--newline--                if (groups.get(i) > 20) {--newline--                    groups.set(i, 20);--newline--                }--newline--                charCount += groups.get(i);--newline--                if (groups.get(i) > 2){--newline--                    badGroup++;--newline--                }--newline--            }--newline----newline--            int deletion = s.length() - 20;--newline----newline--            int toDelete = charCount - 20;--newline----newline--            int remainder = 0;--newline--            while (toDelete > 0 && badGroup > 0) {--newline----newline--                for (int i = 0; i < n; i++) {--newline--                    if (groups.get(i) > 2 && groups.get(i) % 3 == remainder) {--newline--                        int del = Math.min(toDelete, remainder + 1);--newline--                        groups.set(i, groups.get(i) - del);--newline--                        toDelete -= del;--newline--                        if (groups.get(i) <= 2){--newline--                            badGroup--;--newline--                        }--newline--                        if (toDelete == 0 || badGroup == 0) {--newline--                            break;--newline--                        }--newline--                    }--newline--                }--newline--                remainder = (remainder + 1) % 3;--newline--            }--newline----newline--            int replace = 0;--newline--            for (int i = 0; i < groups.size(); i++) {--newline--                replace += groups.get(i) / 3;--newline--            }--newline----newline--            return deletion + Math.max(replace, minReplace);--newline--        }--newline--    }--newline----newline--    /**--newline--     * generate sorted groups--newline--     * groups: # of continuous characters in S--newline--     */--newline--    private List<Integer> generateGroups(String s){--newline--        List<Integer> groups = new ArrayList<>();--newline--        for (int i = 0 ; i < s.length();){--newline--            int j = i;--newline--            while (j < s.length() && s.charAt(j) == s.charAt(i)){--newline--                j++;--newline--            }--newline--            groups.add(j - i);--newline--            i = j;--newline--        }--newline--        return groups;--newline--    }--newline----newline--    /**--newline--     * return # of replacements needed to satisfy 2--newline--     */--newline--    private int getMinReplace(String s){--newline--        boolean[] dls = new boolean[3];--newline--        for(char c : s.toCharArray()){--newline--            dls[getClass(c)] = true;--newline--        }--newline--        int replace = 0;--newline--        for (int i = 0; i < dls.length; i++){--newline--            if (!dls[i]) replace++;--newline--        }--newline--        return replace;--newline--    }--newline----newline--    private int getClass(char c){--newline--        if (c >= '0' && c <= '9'){--newline--            return 0;--newline--        } else if (c >= 'a' && c <= 'z'){--newline--            return 1;--newline--        } else{--newline--            return 2;--newline--        }--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "java with detailed explanation"
        }
    ],
    "qc": "420.json"
}