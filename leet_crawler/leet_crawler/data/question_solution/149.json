{
    "posts": [
        {
            "java": "  /*--newline--     *  A line is determined by two factors,say y=ax+b--newline--     *  --newline--     *  If two points(x1,y1) (x2,y2) are on the same line(Of course). --newline----newline--     *  Consider the gap between two points.--newline----newline--     *  We have (y2-y1)=a(x2-x1),a=(y2-y1)/(x2-x1) a is a rational, b is canceled since b is a constant--newline----newline--     *  If a third point (x3,y3) are on the same line. So we must have y3=ax3+b--newline----newline--     *  Thus,(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a--newline----newline--     *  Since a is a rational, there exists y0 and x0, y0/x0=(y3-y1)/(x3-x1)=(y2-y1)/(x2-x1)=a--newline----newline--     *  So we can use y0&x0 to track a line;--newline--     */--newline--    --newline--    public class Solution{--newline--        public int maxPoints(Point[] points) {--newline--        --tab--if (points==null) return 0;--newline--        --tab--if (points.length<=2) return points.length;--newline--        --tab----newline--        --tab--Map<Integer,Map<Integer,Integer>> map = new HashMap<Integer,Map<Integer,Integer>>();--newline--        --tab--int result=0;--newline--        --tab--for (int i=0;i<points.length;i++){ --newline--        --tab----tab--map.clear();--newline--        --tab----tab--int overlap=0,max=0;--newline--        --tab----tab--for (int j=i+1;j<points.length;j++){--newline--        --tab----tab----tab--int x=points[j].x-points[i].x;--newline--        --tab----tab----tab--int y=points[j].y-points[i].y;--newline--        --tab----tab----tab--if (x==0&&y==0){--newline--        --tab----tab----tab----tab--overlap++;--newline--        --tab----tab----tab----tab--continue;--newline--        --tab----tab----tab--}--newline--        --tab----tab----tab--int gcd=generateGCD(x,y);--newline--        --tab----tab----tab--if (gcd!=0){--newline--        --tab----tab----tab----tab--x/=gcd;--newline--        --tab----tab----tab----tab--y/=gcd;--newline--        --tab----tab----tab--}--newline--        --tab----tab----tab----newline--        --tab----tab----tab--if (map.containsKey(x)){--newline--        --tab----tab----tab----tab--if (map.get(x).containsKey(y)){--newline--        --tab----tab----tab----tab----tab--map.get(x).put(y, map.get(x).get(y)+1);--newline--        --tab----tab----tab----tab--}else{--newline--        --tab----tab----tab----tab----tab--map.get(x).put(y, 1);--newline--        --tab----tab----tab----tab--}   --tab----tab----tab----tab----tab----newline--        --tab----tab----tab--}else{--newline--        --tab----tab----tab----tab--Map<Integer,Integer> m = new HashMap<Integer,Integer>();--newline--        --tab----tab----tab----tab--m.put(y, 1);--newline--        --tab----tab----tab----tab--map.put(x, m);--newline--        --tab----tab----tab--}--newline--        --tab----tab----tab--max=Math.max(max, map.get(x).get(y));--newline--        --tab----tab--}--newline--        --tab----tab--result=Math.max(result, max+overlap+1);--newline--        --tab--}--newline--        --tab--return result;--newline--        --tab----newline--        --tab----newline--        }--newline--        private int generateGCD(int a,int b){--newline--    --newline--        --tab--if (b==0) return a;--newline--        --tab--else return generateGCD(b,a%b);--newline--        --tab----newline--        }--newline--    }",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "A java solution with notes"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int maxPoints(vector<Point> &points) {--newline--        int result = 0;--newline--        for(int i = 0; i < points.size(); i++){--newline--            int samePoint = 1;--newline--            unordered_map<double, int> map;--newline--            for(int j = i + 1; j < points.size(); j++){--newline--                if(points[i].x == points[j].x && points[i].y == points[j].y){--newline--                    samePoint++;--newline--                }--newline--                else if(points[i].x == points[j].x){--newline--                    map[INT_MAX]++;--newline--                }--newline--                else{--newline--                    double slope = double(points[i].y - points[j].y) / double(points[i].x - points[j].x);--newline--                    map[slope]++;--newline--                }--newline--            }--newline--            int localMax = 0;--newline--            for(auto it = map.begin(); it != map.end(); it++){--newline--                localMax = max(localMax, it->second);--newline--            }--newline--            localMax += samePoint;--newline--            result = max(result, localMax);--newline--        }--newline--        return result;--newline--    }--newline--    --newline--}",
            "python": null,
            "topic_title": "Sharing my simple solution with explanation"
        },
        {
            "java": "    /**--newline-- * Definition for a point.--newline-- * class Point {--newline-- *     int x;--newline-- *     int y;--newline-- *     Point() { x = 0; y = 0; }--newline-- *     Point(int a, int b) { x = a; y = b; }--newline-- * }--newline-- */--newline--public class Solution {--newline--    public int maxPoints(Point[] points) {--newline--        if(points.length <= 0) return 0;--newline--        if(points.length <= 2) return points.length;--newline--        int result = 0;--newline--        for(int i = 0; i < points.length; i++){--newline--            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();--newline--            int samex = 1;--newline--            int samep = 0;--newline--            for(int j = 0; j < points.length; j++){--newline--                if(j != i){--newline--                    if((points[j].x == points[i].x) && (points[j].y == points[i].y)){--newline--                        samep++;--newline--                    }--newline--                    if(points[j].x == points[i].x){--newline--                        samex++;--newline--                        continue;--newline--                    }--newline--                    double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);--newline--                    if(hm.containsKey(k)){--newline--                        hm.put(k,hm.get(k) + 1);--newline--                    }else{--newline--                        hm.put(k, 2);--newline--                    }--newline--                    result = Math.max(result, hm.get(k) + samep);--newline--                }--newline--            }--newline--            result = Math.max(result, samex);--newline--        }--newline--        return result;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Accepted Java solution, easy to understand."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int maxPoints(vector<Point> &points) {--newline--        --newline--        if(points.size()<2) return points.size();--newline--        --newline--        int result=0;--newline--        --newline--        for(int i=0; i<points.size(); i++) {--newline--            --newline--            map<pair<int, int>, int> lines;--newline--            int localmax=0, overlap=0, vertical=0;--newline--            --newline--            for(int j=i+1; j<points.size(); j++) {--newline--                --newline--                if(points[j].x==points[i].x && points[j].y==points[i].y) {--newline--                    --newline--                    overlap++;--newline--                    continue;--newline--                }--newline--                else if(points[j].x==points[i].x) vertical++;--newline--                else {--newline--                    --newline--                    int a=points[j].x-points[i].x, b=points[j].y-points[i].y;--newline--                    int gcd=GCD(a, b);--newline--                    --newline--                    a/=gcd;--newline--                    b/=gcd;--newline--                    --newline--                    lines[make_pair(a, b)]++;--newline--                    localmax=max(lines[make_pair(a, b)], localmax);--newline--                }--newline----newline--                localmax=max(vertical, localmax);--newline--            }--newline--            --newline--            result=max(result, localmax+overlap+1);--newline--        }--newline--        --newline--        return result;--newline--    }--newline----newline--private:--newline--    int GCD(int a, int b) {--newline--        --newline--        if(b==0) return a;--newline--        else return GCD(b, a%b);--newline--    }--newline--};",
            "python": null,
            "topic_title": "C++ O(n^2) solution for your reference"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int maxPoints(vector<Point>& points) --newline--    {--newline--        if(points.size()<=2) return points.size();--newline--        int res=0;--newline--        for(int i=0;i<points.size()-1;i++) {--newline--            int numVertical=1,local=1,duplicate=0;--newline--            unordered_map<double,int> map;--newline--            for(int j=i+1;j<points.size();j++) --newline--                if(points[i].x==points[j].x) // special cases--newline--                    if(points[i].y==points[j].y) // duplicate --newline--                        duplicate++;--newline--                    else // vertical--newline--                        numVertical++;--newline--                else {--newline--                    double slope=(points[i].y-points[j].y)*1.0/(points[i].x-points[j].x);--newline--                    map[slope]==0?map[slope]=2:map[slope]++;--newline--                    local=max(local,map[slope]);--newline--                }--newline--            local=max(local+duplicate,numVertical+duplicate);--newline--            res=max(res,local);--newline--        }--newline--        return res;--newline--    }--newline--};",
            "python": null,
            "topic_title": "20-line C++ O(n^2) Hashing Solution"
        }
    ],
    "qc": "149.json"
}