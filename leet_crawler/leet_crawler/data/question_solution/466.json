{
    "posts": [
        {
            "topic_title": "Ugly Java brute force solution, but accepted. 1088ms.",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "java": "public class Solution {--newline--    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {--newline--        char[] array1 = s1.toCharArray(), array2 = s2.toCharArray();--newline--        int count1 = 0, count2 = 0, i = 0, j = 0;--newline--        --newline--        while (count1 < n1) {--newline--            if (array1[i] == array2[j]) {--newline--                j++;--newline--                if (j == array2.length) {--newline--                    j = 0;--newline--                    count2++;--newline--                }--newline--            }--newline--            i++;--newline--            if (i == array1.length) {--newline--                i = 0;--newline--                count1++;--newline--            }--newline--        }--newline--        --newline--        return count2 / n2;--newline--    }--newline--}--newline--"
        },
        {
            "topic_title": "C++ solution inspired by &#64;70664914 with organized explanation",
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int getMaxRepetitions(string s1, int n1, string s2, int n2) {--newline--        vector<int> repeatCount(s2.size() + 1, 0);--newline--        vector<int> nextIndex(s2.size() + 1, 0);--newline--        int j = 0, cnt = 0;--newline--        for (int k = 1; k <= n1; ++k) {--newline--            for (int i = 0; i < s1.size(); ++i) {--newline--                if (s1[i] == s2[j]) {--newline--                    ++j;--newline--                    if (j == s2.size()) {--newline--                        j = 0;--newline--                        ++cnt;--newline--                    }--newline--                }--newline--            }--newline--            repeatCount[k] = cnt;--newline--            nextIndex[k] = j;--newline--            for (int start = 0; start < k; ++start) {--newline--                if (nextIndex[start] == j) {--newline--                    int prefixCount = repeatCount[start];--newline--                    int patternCount = (repeatCount[k] - repeatCount[start]) * (n1 - start) / (k - start);--newline--                    int suffixCount = repeatCount[start + (n1 - start) % (k - start)] - repeatCount[start];--newline--                    return (prefixCount + patternCount + suffixCount) / n2;--newline--                }--newline--            }--newline--        }--newline--        return repeatCount[n1] / n2;--newline--    }--newline--};--newline--",
            "python": null,
            "java": null
        },
        {
            "topic_title": "C++ 0ms O(str1.length*str2.length)",
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int getMaxRepetitions(string s1, int n1, string s2, int n2) {--newline--        vector<int> rapport(102,-1);--newline--        vector<int> rest(102,-1);--newline--        int b=-1;int posRest=0;int rap=0;--newline--        int last=-1;--newline--        rapport[0]=rest[0]=0;//case when n=0--newline--        for(int i=1;i<=s2.size()+1;i++){--newline--            int j;--newline--            for(j=0;j<s1.size();j++){--newline--                if(s2[posRest]==s1[j]){--newline--                    posRest++;--newline--                    if(posRest==s2.size()){--newline--                        rap++;--newline--                        posRest=0;--newline--                    }--newline--                }--newline--            }--newline--            for(int k=0;k<i;k++){--newline--                if(posRest==rest[k]){b=k;last=i;break;}--newline--            }--newline--            rapport[i]=rap;rest[i]=posRest;--newline--            if(b>=0)break;--newline--        }--newline--        int interval=last-b;--newline--        if(b>=n1)return rapport[n1]/n2;--newline--        return ((n1-b)/interval*(rapport[last]-rapport[b])+rapport[(n1-b)%interval+b])/n2;--newline--//corrected thanks to @zhiqing_xiao and @iaming --newline--    }--newline--};--newline--",
            "python": null,
            "java": null
        },
        {
            "topic_title": "Easy-understanding Java Solution with detailed explanation, 21ms!",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "java": "public class Solution {--newline--    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {--newline--        if (!ableToObtain(s1, s2)) return 0; // check if [s1. \u221e] obtains s2--newline--        int cnt=0, k=-1;--newline--        String s=s1;--newline--        StringBuilder remainBuilder; // record `remain string`--newline--        ArrayList<String> stringList=new ArrayList<>(); // record all the `remain string`--newline--        ArrayList<Integer> countList=new ArrayList<>(); // record matching count from start to the current remain string --newline--        stringList.add(\"\"); // record empty string--newline--        countList.add(0);--newline--        for (int i=0;i<=n1;i++) {--newline--            remainBuilder=new StringBuilder();--newline--            cnt+=getRemain(s, s2, remainBuilder); // get the next remain string, returns the count of matching--newline--            String remain=remainBuilder.toString();--newline--            if ((k=stringList.indexOf(remain))!=-1) break; // if there is a loop, break--newline--            stringList.add(remain); // record the remain string into arraylist --newline--            countList.add(cnt);--newline--            s=remain+s1; // append s1 to make a new string--newline--        }--newline--        // here, k is the beginning of the loop--newline--        if (k==-1) return cnt/n2; // if there is no loop--newline--        int countOfLoop=cnt-countList.get(k), loopLength=stringList.size()-k; // get matching count in the loop, and loop length--newline--        cnt=countList.get(k);--newline--        n1-=k;--newline--        cnt+=countOfLoop*(n1/loopLength);--newline--        n1%=loopLength; --newline--        cnt+=countList.get(k+n1)-countList.get(k);--newline--        return cnt/n2;--newline--    }--newline----newline--    // check if [s1. \u221e] obtains s2--newline--    private boolean ableToObtain(String s1, String s2) {--newline--        boolean[] cnt=new boolean[26];--newline--        for (char c: s1.toCharArray()) cnt[c-'a']=true;--newline--        for (char c: s2.toCharArray()) {--newline--            if (!cnt[c-'a']) return false;--newline--        }--newline--        return true;--newline--    }--newline----newline--    // get remain string after s1 obtains s2, return the matching count--newline--    private int getRemain(String s1, String s2, StringBuilder remain) {--newline--        int cnt=0, lastMatch=-1, p2=0;--newline--        for (int p1=0;p1<s1.length();p1++) {--newline--            if (s1.charAt(p1)==s2.charAt(p2)) {--newline--                if (++p2==s2.length()) {--newline--                    p2=0;--newline--                    cnt++;--newline--                    lastMatch=p1;--newline--                }--newline--            }--newline--        }--newline--        remain.append(s1.substring(lastMatch+1));--newline--        return cnt;--newline--    }--newline--}--newline--"
        },
        {
            "topic_title": "Accepted 8ms Java solution with explanation",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "java": "public class Solution {--newline----tab--public int getMaxRepetitions(String s1, int n1, String s2, int n2) {--newline----tab----tab--int m1 = s1.length();--newline----tab----tab--int m2 = s2.length();--newline----tab----tab--if (m1 == 0 || m2 == 0)--newline----tab----tab----tab--return 0;--newline----tab----tab--int i, j;--newline----tab----tab--// extra code to remove unnecessary characters in s1--newline----tab----tab--StringBuffer sb = new StringBuffer();--newline----tab----tab--boolean[] used = new boolean[26];--newline----tab----tab--int[] counts = new int[26]; // count of each character in s1--newline----tab----tab--for (i = 0; i < m2; i++) {--newline----tab----tab----tab--j = s2.charAt(i) - 'a';--newline----tab----tab----tab--used[j] = true;--newline----tab----tab--}--newline----tab----tab--for (i = 0; i < m1; i++) {--newline----tab----tab----tab--j = s1.charAt(i) - 'a';--newline----tab----tab----tab--if (used[j])--newline----tab----tab----tab----tab--sb.append(s1.charAt(i));--newline----tab----tab----tab--counts[j]++;--newline----tab----tab--}--newline----tab----tab--for (i = 0; i < 26; i++) {--newline----tab----tab----tab--if (used[i] && counts[i] == 0) // character in s2 not in s1--newline----tab----tab----tab----tab--return 0;--newline----tab----tab--}--newline----tab----tab--s1 = sb.toString();--newline----tab----tab--m1 = s1.length();--newline----newline----tab----tab--// extra code to reduce s1 and s2 if it contains repeating pattern--newline----tab----tab--for (i = 1; i <= m1 / 2; i++) {--newline----tab----tab----tab--if (m1 % i != 0)--newline----tab----tab----tab----tab--continue;--newline----tab----tab----tab--if (repeatAtK(s1, i)) {--newline----tab----tab----tab----tab--s1 = s1.substring(0, i);--newline----tab----tab----tab----tab--n1 *= m1 / i;--newline----tab----tab----tab----tab--m1 = i;--newline----tab----tab----tab----tab--break;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--for (i = 1; i <= m2 / 2; i++) {--newline----tab----tab----tab--if (m2 % i != 0)--newline----tab----tab----tab----tab--continue;--newline----tab----tab----tab--if (repeatAtK(s2, i)) {--newline----tab----tab----tab----tab--s2 = s2.substring(0, i);--newline----tab----tab----tab----tab--n2 *= m2 / i;--newline----tab----tab----tab----tab--m2 = i;--newline----tab----tab----tab----tab--break;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----newline----tab----tab--int[][] ocs = new int[26][m1]; // occurrences of each character in s1--newline----tab----tab--Arrays.fill(counts, 0);--newline----tab----tab--for (i = 0; i < m1; i++) {--newline----tab----tab----tab--j = s1.charAt(i) - 'a';--newline----tab----tab----tab--ocs[j][counts[j]] = i;--newline----tab----tab----tab--counts[j]++;--newline----tab----tab--}--newline----tab----tab----newline----tab----tab--// simple case--newline----tab----tab--if (m2 == 1) {--newline----tab----tab----tab--j = s2.charAt(0) - 'a';--newline----tab----tab----tab--return counts[j]*n1/n2;--newline----tab----tab--}--newline----newline----tab----tab--return getMaxRepetitionsProcessed(counts, ocs, n1, s2.toCharArray(), n2);--newline----tab--}--newline----newline----tab--public int getMaxRepetitionsProcessed(int[] counts, int[][] ocs, int n1, char[] ca2, int n2) {--newline----tab----tab--int m1 = ocs[0].length;--newline----tab----tab--int m2 = ca2.length;--newline----tab----tab--// <i, j> pairs in slot mod m1/m2--newline----tab----tab--int[][][] r = new int[m1][m2][2];--newline----tab----tab--// pos[c][0] is the current index of character c in i, --newline----tab----tab--// pos[c][1] is which occurrence in s1--newline----tab----tab--int[][] pos = new int[26][2]; --newline----tab----tab--int i, j, k, r1 = 0, r2 = 0;--newline----tab----tab--boolean found = false;--newline----tab----tab--for (i = 0; i < 26; i++) {--newline----tab----tab----tab--pos[i][0] = ocs[i][0];--newline----tab----tab--}--newline----tab----tab--for (i = 0; i < m1; i++) {--newline----tab----tab----tab--for (j = 0; j < m2; j++) {--newline----tab----tab----tab----tab--r[i][j][0] = -1;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--for (i = 0, j = 0; i < m1 * n1; i++, j++) {--newline----tab----tab----tab--k = ca2[j % m2] - 'a';--newline----tab----tab----tab--// move pos[k] to a position equal or after i by iterating k's occurrences--newline----tab----tab----tab--while (pos[k][0] < i) {--newline----tab----tab----tab----tab--pos[k][1]++;--newline----tab----tab----tab----tab--if (pos[k][1] < counts[k]) {--newline----tab----tab----tab----tab----tab--pos[k][0] += ocs[k][pos[k][1]] - ocs[k][pos[k][1] - 1];--newline----tab----tab----tab----tab--} else {--newline----tab----tab----tab----tab----tab--pos[k][1] = 0;--newline----tab----tab----tab----tab----tab--pos[k][0] += ocs[k][0] + m1 - ocs[k][counts[k] - 1];--newline----tab----tab----tab----tab--}--newline----tab----tab----tab--}--newline----tab----tab----tab--i = pos[k][0];--newline----tab----tab----tab--if (i >= m1 * n1) {--newline----tab----tab----tab----tab--return j / m2 / n2;--newline----tab----tab----tab--}--newline----tab----tab----tab--r1 = i % m1;--newline----tab----tab----tab--r2 = j % m2;--newline----tab----tab----tab--if (!found && r[r1][r2][0] < 0) {--newline----tab----tab----tab----tab--r[r1][r2][0] = i;--newline----tab----tab----tab----tab--r[r1][r2][1] = j;--newline----tab----tab----tab--} else if (!found) { // push by mod trick here--newline----tab----tab----tab----tab--int d1 = i - r[r1][r2][0];--newline----tab----tab----tab----tab--int d2 = j - r[r1][r2][1];--newline----tab----tab----tab----tab--k = (m1 * n1 - i) / d1;--newline----tab----tab----tab----tab--i += k * d1;--newline----tab----tab----tab----tab--j += k * d2;--newline----tab----tab----tab----tab--for (r1 = 0; r1 < 26; r1++) { // update all pos[c] the same way as i--newline----tab----tab----tab----tab----tab--pos[r1][0] += k * d1;--newline----tab----tab----tab----tab--}--newline----tab----tab----tab----tab--found = true;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return j / m2 / n2;--newline----tab--}--newline----newline----tab--public boolean repeatAtK(String s, int k) { // check if s is repeated every k characters--newline----tab----tab--int m = s.length();--newline----tab----tab--int x = m / k;--newline----tab----tab--for (int i = 0; i < k; i++) {--newline----tab----tab----tab--for (int j = 0; j < x; j++) {--newline----tab----tab----tab----tab--if (s.charAt(i) != s.charAt(j * k + i))--newline----tab----tab----tab----tab----tab--return false;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return true;--newline----tab--}--newline--}--newline--"
        }
    ],
    "qc": "466.json"
}