{
    "posts": [
        {
            "java": "public class Solution {--newline--    public String removeDuplicateLetters(String s) {--newline--        int[] cnt = new int[26];--newline--        int pos = 0; // the position for the smallest s[i]--newline--        for (int i = 0; i < s.length(); i++) cnt[s.charAt(i) - 'a']++;--newline--        for (int i = 0; i < s.length(); i++) {--newline--            if (s.charAt(i) < s.charAt(pos)) pos = i;--newline--            if (--cnt[s.charAt(i) - 'a'] == 0) break;--newline--        }--newline--        return s.length() == 0 ? \"\" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll(\"\" + s.charAt(pos), \"\"));--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "A short O(n) recursive greedy solution"
        },
        {
            "java": "public class Solution {--newline----newline--    public String removeDuplicateLetters(String s) {--newline--        if (s == null || s.length() <= 1) return s;--newline----newline--        Map<Character, Integer> lastPosMap = new HashMap<>();--newline--        for (int i = 0; i < s.length(); i++) {--newline--            lastPosMap.put(s.charAt(i), i);--newline--        }--newline----newline--        char[] result = new char[lastPosMap.size()];--newline--        int begin = 0, end = findMinLastPos(lastPosMap);--newline----newline--        for (int i = 0; i < result.length; i++) {--newline--            char minChar = 'z' + 1;--newline--            for (int k = begin; k <= end; k++) {--newline--                if (lastPosMap.containsKey(s.charAt(k)) && s.charAt(k) < minChar) {--newline--                    minChar = s.charAt(k);--newline--                    begin = k+1;--newline--                }--newline--            }--newline----newline--            result[i] = minChar;--newline--            if (i == result.length-1) break;--newline----newline--            lastPosMap.remove(minChar);--newline--            if (s.charAt(end) == minChar) end = findMinLastPos(lastPosMap);--newline--        }--newline----newline--        return new String(result);--newline--    }--newline----newline--    private int findMinLastPos(Map<Character, Integer> lastPosMap) {--newline--        if (lastPosMap == null || lastPosMap.isEmpty()) return -1;--newline--        int minLastPos = Integer.MAX_VALUE;--newline--        for (int lastPos : lastPosMap.values()) {--newline--             minLastPos = Math.min(minLastPos, lastPos);--newline--        }--newline--        return minLastPos;--newline--    }--newline----newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy to understand iterative Java solution"
        },
        {
            "java": "public class Solution {--newline--    public String removeDuplicateLetters(String sr) {--newline--    --newline--        int[] res = new int[26]; //will contain number of occurences of character (i+'a')--newline--        boolean[] visited = new boolean[26]; //will contain if character (i+'a') is present in current result Stack--newline--        char[] ch = sr.toCharArray();--newline--        for(char c: ch){  //count number of occurences of character --newline--            res[c-'a']++;--newline--        }--newline--        Stack<Character> st = new Stack<>(); // answer stack--newline--        int index;--newline--        for(char s:ch){ --newline--            index= s-'a';--newline--            res[index]--;   //decrement number of characters remaining in the string to be analysed--newline--            if(visited[index]) //if character is already present in stack, dont bother--newline--                continue;--newline--            //if current character is smaller than last character in stack which occurs later in the string again--newline--            //it can be removed and  added later e.g stack = bc remaining string abc then a can pop b and then c--newline--            while(!st.isEmpty() && s<st.peek() && res[st.peek()-'a']!=0){ --newline--                visited[st.pop()-'a']=false;--newline--            }--newline--            st.push(s); //add current character and mark it as visited--newline--            visited[index]=true;--newline--        }--newline--    --newline--        StringBuilder sb = new StringBuilder();--newline--        //pop character from stack and build answer string from back--newline--        while(!st.isEmpty()){--newline--            sb.insert(0,st.pop());--newline--        }--newline--        return sb.toString();--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using Stack with comments"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    string removeDuplicateLetters(string s) {--newline--        vector<int> cand(256, 0);--newline--        vector<bool> visited(256, false);--newline--        for (char c : s)--newline--            cand[c]++;--newline--        string result = \"0\";--newline--        for (char c : s) {--newline--            cand[c]--;--newline--            if (visited[c]) continue;--newline--            while (c < result.back() && cand[result.back()]) {--newline--                visited[result.back()] = false;--newline--                result.pop_back();--newline--            }--newline--            result += c;--newline--            visited[c] = true;--newline--        }--newline--        return result.substr(1);--newline--    }--newline--}",
            "python": null,
            "topic_title": "C++ simple solution easy understanding"
        },
        {
            "java": "public class Solution {--newline--    public String removeDuplicateLetters(String s) {--newline--        HashMap<Character, ArrayList<Integer>> counts = new HashMap<Character, ArrayList<Integer>>();--newline--        ArrayList<Character> keys = new ArrayList<Character>();--newline--        for (int i = 0; i < s.length(); i++) {--newline--            char c = s.charAt(i);--newline--            if (!counts.containsKey(c)) {--newline--                counts.put(c, new ArrayList<Integer>());--newline--                keys.add(c);--newline--            }--newline--            counts.get(c).add(i);--newline--        }--newline--        Collections.sort(keys);--newline--        StringBuilder sb = new StringBuilder();--newline--        while (!counts.isEmpty()) {--newline--            boolean found = true;--newline--            for (int i = 0; i < keys.size(); i++) {--newline--                int index = counts.get(keys.get(i)).get(0);--newline--                for (int j = 0; j < keys.size(); j++) {--newline--                    ArrayList<Integer> count = counts.get(keys.get(j));--newline--                    if (count.get(count.size() - 1) < index) {--newline--                        found = false;--newline--                        break;--newline--                    }--newline--                }--newline--                if (found) {--newline--                    sb.append(keys.get(i));--newline--                    counts.remove(keys.get(i));--newline--                    keys.remove(i);--newline--                    for (int j = 0; j < keys.size(); j++) {--newline--                        ArrayList<Integer> count = counts.get(keys.get(j));--newline--                        while (count.get(0) < index) {--newline--                            count.remove(0);--newline--                        }--newline--                    }--newline--                    break;--newline--                }--newline--                found = true;--newline--            }--newline--        }--newline--        return sb.toString();--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "15 ms Java solution"
        }
    ],
    "qc": "316.json"
}