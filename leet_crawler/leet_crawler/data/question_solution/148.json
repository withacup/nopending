{
    "posts": [
        {
            "java": "public class Solution {--newline--  --newline--  public ListNode sortList(ListNode head) {--newline--    if (head == null || head.next == null)--newline--      return head;--newline--        --newline--    // step 1. cut the list to two halves--newline--    ListNode prev = null, slow = head, fast = head;--newline--    --newline--    while (fast != null && fast.next != null) {--newline--      prev = slow;--newline--      slow = slow.next;--newline--      fast = fast.next.next;--newline--    }--newline--    --newline--    prev.next = null;--newline--    --newline--    // step 2. sort each half--newline--    ListNode l1 = sortList(head);--newline--    ListNode l2 = sortList(slow);--newline--    --newline--    // step 3. merge l1 and l2--newline--    return merge(l1, l2);--newline--  }--newline--  --newline--  ListNode merge(ListNode l1, ListNode l2) {--newline--    ListNode l = new ListNode(0), p = l;--newline--    --newline--    while (l1 != null && l2 != null) {--newline--      if (l1.val < l2.val) {--newline--        p.next = l1;--newline--        l1 = l1.next;--newline--      } else {--newline--        p.next = l2;--newline--        l2 = l2.next;--newline--      }--newline--      p = p.next;--newline--    }--newline--    --newline--    if (l1 != null)--newline--      p.next = l1;--newline--    --newline--    if (l2 != null)--newline--      p.next = l2;--newline--    --newline--    return l.next;--newline--  }--newline----newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java merge sort solution"
        },
        {
            "java": "/**--newline-- * Definition for singly-linked list.--newline-- * class ListNode {--newline-- *     int val;--newline-- *     ListNode next;--newline-- *     ListNode(int x) {--newline-- *         val = x;--newline-- *         next = null;--newline-- *     }--newline-- * }--newline-- */--newline--public class Solution {--newline--    public ListNode sortList(ListNode head) {--newline--        if (head == null || head.next == null)--newline--            return head;--newline--        ListNode f = head.next.next;--newline--        ListNode p = head;--newline--        while (f != null && f.next != null) {--newline--            p = p.next;--newline--            f =  f.next.next;--newline--        }--newline--        ListNode h2 = sortList(p.next);--newline--        p.next = null;--newline--        return merge(sortList(head), h2);--newline--    }--newline--    public ListNode merge(ListNode h1, ListNode h2) {--newline--        ListNode hn = new ListNode(Integer.MIN_VALUE);--newline--        ListNode c = hn;--newline--        while (h1 != null && h2 != null) {--newline--            if (h1.val < h2.val) {--newline--                c.next = h1;--newline--                h1 = h1.next;--newline--            }--newline--            else {--newline--                c.next = h2;--newline--                h2 = h2.next;--newline--            }--newline--            c = c.next;--newline--        }--newline--        if (h1 != null)--newline--            c.next = h1;--newline--        if (h2 != null)--newline--            c.next = h2;--newline--        return hn.next;--newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "I have a pretty good MergeSort method. Can anyone speed up the run time or reduce the memory usage?"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "/**--newline-- * Merge sort use bottom-up policy, --newline-- * so Space Complexity is O(1)--newline-- * Time Complexity is O(NlgN)--newline-- * stable sort--newline--*/--newline--class Solution {--newline--public:--newline----tab--ListNode *sortList(ListNode *head) {--newline----tab----tab--if(!head || !(head->next)) return head;--newline----tab----tab----newline----tab----tab--//get the linked list's length--newline----tab----tab--ListNode* cur = head;--newline----tab----tab--int length = 0;--newline----tab----tab--while(cur){--newline----tab----tab----tab--length++;--newline----tab----tab----tab--cur = cur->next;--newline----tab----tab--}--newline----tab----tab----newline----tab----tab--ListNode dummy(0);--newline----tab----tab--dummy.next = head;--newline----tab----tab--ListNode *left, *right, *tail;--newline----tab----tab--for(int step = 1; step < length; step <<= 1){--newline----tab----tab----tab--cur = dummy.next;--newline----tab----tab----tab--tail = &dummy;--newline----tab----tab----tab--while(cur){--newline----tab----tab----tab----tab--left = cur;--newline----tab----tab----tab----tab--right = split(left, step);--newline----tab----tab----tab----tab--cur = split(right,step);--newline----tab----tab----tab----tab--tail = merge(left, right, tail);--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return dummy.next;--newline----tab--}--newline--private:--newline----tab--/**--newline----tab-- * Divide the linked list into two lists,--newline--     * while the first list contains first n ndoes--newline----tab-- * return the second list's head--newline----tab-- */--newline----tab--ListNode* split(ListNode *head, int n){--newline----tab----tab--//if(!head) return NULL;--newline----tab----tab--for(int i = 1; head && i < n; i++) head = head->next;--newline----tab----tab----newline----tab----tab--if(!head) return NULL;--newline----tab----tab--ListNode *second = head->next;--newline----tab----tab--head->next = NULL;--newline----tab----tab--return second;--newline----tab--}--newline----tab--/**--newline----tab--  * merge the two sorted linked list l1 and l2,--newline----tab--  * then append the merged sorted linked list to the node head--newline----tab--  * return the tail of the merged sorted linked list--newline----tab-- */--newline----tab--ListNode* merge(ListNode* l1, ListNode* l2, ListNode* head){--newline----tab----tab--ListNode *cur = head;--newline----tab----tab--while(l1 && l2){--newline----tab----tab----tab--if(l1->val > l2->val){--newline----tab----tab----tab----tab--cur->next = l2;--newline----tab----tab----tab----tab--cur = l2;--newline----tab----tab----tab----tab--l2 = l2->next;--newline----tab----tab----tab--}--newline----tab----tab----tab--else{--newline----tab----tab----tab----tab--cur->next = l1;--newline----tab----tab----tab----tab--cur = l1;--newline----tab----tab----tab----tab--l1 = l1->next;--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--cur->next = (l1 ? l1 : l2);--newline----tab----tab--while(cur->next) cur = cur->next;--newline----tab----tab--return cur;--newline----tab--}--newline--};",
            "python": null,
            "topic_title": "Bottom-to-up(not recurring)  with o(1) space complextity and o(nlgn) time complextity"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int count_size(ListNode *node){--newline--        int n = 0;--newline--        while (node != NULL){--newline--            node = node->next;--newline--            ++n;--newline--        }--newline--        return n;--newline--    }--newline--    ListNode *sortList(ListNode *head) {--newline--        int block_size = 1, n = count_size(head), iter = 0, i = 0, a = 0, b = 0;--newline--        ListNode virtual_head(0);--newline--        ListNode *last = NULL, *it = NULL, *A = NULL, *B = NULL, *tmp = NULL;--newline--        virtual_head.next = head;--newline--        while (block_size < n){--newline--            iter = 0;--newline--            last = &virtual_head;--newline--            it = virtual_head.next;--newline--            while (iter <  n){--newline--                a = min(n - iter, block_size);--newline--                b = min(n - iter - a, block_size);--newline--                --newline--                A = it;--newline--                if (b != 0){--newline--                    for (i = 0; i < a - 1; ++i) it = it->next;--newline--                    B = it->next;--newline--                    it->next = NULL;--newline--                    it = B;--newline--                    --newline--                    for (i = 0; i < b - 1; ++i) it = it->next;--newline--                    tmp = it->next;--newline--                    it->next = NULL;--newline--                    it = tmp;--newline--                }--newline--                --newline--                while (A || B){--newline--                    if (B == NULL || (A != NULL && A->val <= B->val)){--newline--                        last->next = A;--newline--                        last = last->next;--newline--                        A = A->next;--newline--                    } else {--newline--                        last->next = B;--newline--                        last = last->next;--newline--                        B = B->next;--newline--                    }--newline--                }--newline--                last->next = NULL;--newline--                iter += a + b;--newline--            }--newline--            block_size <<= 1;--newline--        }--newline--        return virtual_head.next;--newline--    }--newline--};",
            "python": null,
            "topic_title": "My O(n log n) time, O(1) space solution"
        },
        {
            "java": "public class Solution {--newline--    --newline--    //merge two sorted list, return result head--newline--    public ListNode merge(ListNode h1, ListNode h2){--newline--        if(h1 == null){--newline--            return h2;--newline--        }--newline--        if(h2 == null){--newline--            return h1;--newline--        }--newline--        --newline--        if(h1.val < h2.val){--newline--            h1.next = merge(h1.next, h2);--newline--            return h1;--newline--        }--newline--        else{--newline--            h2.next = merge(h1, h2.next);--newline--            return h2;--newline--        }--newline--        --newline--    }--newline--    --newline--    public ListNode sortList(ListNode head) {--newline--        //bottom case--newline--        if(head == null){--newline--            return head;--newline--        }--newline--        if(head.next == null){--newline--            return head;--newline--        }--newline--        --newline--        //p1 move 1 step every time, p2 move 2 step every time, pre record node before p1--newline--        ListNode p1 = head;--newline--        ListNode p2 = head;--newline--        ListNode pre = head;--newline--        --newline--        while(p2 != null && p2.next != null){--newline--            pre = p1;--newline--            p1 = p1.next;--newline--            p2 = p2.next.next;--newline--        }--newline--        //change pre next to null, make two sub list(head to pre, p1 to p2)--newline--        pre.next = null;--newline--        --newline--        //handle those two sub list--newline--        ListNode h1 = sortList(head);--newline--        ListNode h2 = sortList(p1);--newline--        --newline--        return merge(h1, h2);--newline--        --newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Basically, it seems like merge sort problem(Really easy understand)"
        }
    ],
    "qc": "148.json"
}