{
    "posts": [
        {
            "java": "public class Solution {--newline--    public int findKthLargest(int[] nums, int k) {--newline--    --newline--            shuffle(nums);--newline--            k = nums.length - k;--newline--            int lo = 0;--newline--            int hi = nums.length - 1;--newline--            while (lo < hi) {--newline--                final int j = partition(nums, lo, hi);--newline--                if(j < k) {--newline--                    lo = j + 1;--newline--                } else if (j > k) {--newline--                    hi = j - 1;--newline--                } else {--newline--                    break;--newline--                }--newline--            }--newline--            return nums[k];--newline--        }--newline--    --newline--    private void shuffle(int a[]) {--newline--    --newline--            final Random random = new Random();--newline--            for(int ind = 1; ind < a.length; ind++) {--newline--                final int r = random.nextInt(ind + 1);--newline--                exch(a, ind, r);--newline--            }--newline--        }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Solution explained"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int findKthLargest(vector<int>& nums, int k) {--newline--        multiset<int> mset;--newline--        int n = nums.size();--newline--        for (int i = 0; i < n; i++) { --newline--            mset.insert(nums[i]);--newline--            if (mset.size() > k)--newline--                mset.erase(mset.begin());--newline--        }--newline--        return *mset.begin();--newline--    }--newline--};",
            "python": null,
            "topic_title": "4 C++ Solutions using Partition, Max-Heap, priority_queue and multiset respectively"
        },
        {
            "java": "public class Solution {--newline--  --newline--  public int findKthLargest(int[] a, int k) {--newline--    int n = a.length;--newline--    int p = quickSelect(a, 0, n - 1, n - k + 1);--newline--    return a[p];--newline--  }--newline--  --newline--  // return the index of the kth smallest number--newline--  int quickSelect(int[] a, int lo, int hi, int k) {--newline--    // use quick sort's idea--newline--    // put nums that are <= pivot to the left--newline--    // put nums that are  > pivot to the right--newline--    int i = lo, j = hi, pivot = a[hi];--newline--    while (i < j) {--newline--      if (a[i++] > pivot) swap(a, --i, --j);--newline--    }--newline--    swap(a, i, hi);--newline--    --newline--    // count the nums that are <= pivot from lo--newline--    int m = i - lo + 1;--newline--    --newline--    // pivot is the one!--newline--    if (m == k)     return i;--newline--    // pivot is too big, so it must be on the left--newline--    else if (m > k) return quickSelect(a, lo, i - 1, k);--newline--    // pivot is too small, so it must be on the right--newline--    else            return quickSelect(a, i + 1, hi, k - m);--newline--  }--newline--  --newline--  void swap(int[] a, int i, int j) {--newline--    int tmp = a[i];--newline--    a[i] = a[j];--newline--    a[j] = tmp;--newline--  }--newline----newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "AC Clean QuickSelect Java solution avg. O(n) time"
        },
        {
            "java": "public class Solution {--newline--    public int findKthLargest(int[] nums, int k) {--newline--    --tab--if (nums == null || nums.length == 0) return Integer.MAX_VALUE;--newline--        return findKthLargest(nums, 0, nums.length - 1, nums.length - k);--newline--    }    --newline--    --newline--    public int findKthLargest(int[] nums, int start, int end, int k) {// quick select: kth smallest--newline--    --tab--if (start > end) return Integer.MAX_VALUE;--newline--    --tab----newline--    --tab--int pivot = nums[end];// Take A[end] as the pivot, --newline--    --tab--int left = start;--newline--    --tab--for (int i = start; i < end; i++) {--newline--    --tab----tab--if (nums[i] <= pivot) // Put numbers < pivot to pivot's left--newline--    --tab----tab----tab--swap(nums, left++, i);--tab----tab----tab----newline--    --tab--}--newline--    --tab--swap(nums, left, end);// Finally, swap A[end] with A[left]--newline--    --tab----newline--    --tab--if (left == k)// Found kth smallest number--newline--    --tab----tab--return nums[left];--newline--    --tab--else if (left < k)// Check right part--newline--    --tab----tab--return findKthLargest(nums, left + 1, end, k);--newline--    --tab--else // Check left part--newline--    --tab----tab--return findKthLargest(nums, start, left - 1, k);--newline--    } --newline--    --newline--    void swap(int[] A, int i, int j) {--newline--    --tab--int tmp = A[i];--newline--    --tab--A[i] = A[j];--newline--    --tab--A[j] = tmp;--tab----tab----tab----tab----newline--    }--newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Concise JAVA solution based on Quick Select"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    # O(nlgn) time--newline----tab--    def findKthLargest1(self, nums, k):--newline----tab--        return sorted(nums, reverse=True)[k-1]--newline----tab--        --newline----tab--    # O(nk) time, bubble sort idea, TLE--newline----tab--    def findKthLargest2(self, nums, k):--newline----tab--        for i in xrange(k):--newline----tab--            for j in xrange(len(nums)-i-1):--newline----tab--                if nums[j] > nums[j+1]:--newline----tab--                    # exchange elements, time consuming--newline----tab--                    nums[j], nums[j+1] = nums[j+1], nums[j]--newline----tab--        return nums[len(nums)-k]--newline----tab--        --newline----tab--    # O(nk) time, selection sort idea--newline----tab--    def findKthLargest3(self, nums, k):--newline----tab--        for i in xrange(len(nums), len(nums)-k, -1):--newline----tab--            tmp = 0--newline----tab--            for j in xrange(i):--newline----tab--                if nums[j] > nums[tmp]:--newline----tab--                    tmp = j--newline----tab--            nums[tmp], nums[i-1] = nums[i-1], nums[tmp]--newline----tab--        return nums[len(nums)-k]--newline----tab--        --newline----tab--    # O(k+(n-k)lgk) time, min-heap--newline----tab--    def findKthLargest4(self, nums, k):--newline----tab--        heap = []--newline----tab--        for num in nums:--newline----tab--            heapq.heappush(heap, num)--newline----tab--        for _ in xrange(len(nums)-k):--newline----tab--            heapq.heappop(heap)--newline----tab--        return heapq.heappop(heap)--newline----tab--    --newline----tab--    # O(k+(n-k)lgk) time, min-heap        --newline----tab--    def findKthLargest5(self, nums, k):--newline----tab--        return heapq.nlargest(k, nums)[k-1]--newline----tab--        --newline----tab--    # O(n) time, quick selection--newline----tab--    def findKthLargest(self, nums, k):--newline----tab--        # convert the kth largest to smallest--newline----tab--        return self.findKthSmallest(nums, len(nums)+1-k)--newline----tab--        --newline----tab--    def findKthSmallest(self, nums, k):--newline----tab--        if nums:--newline----tab--            pos = self.partition(nums, 0, len(nums)-1)--newline----tab--            if k > pos+1:--newline----tab--                return self.findKthSmallest(nums[pos+1:], k-pos-1)--newline----tab--            elif k < pos+1:--newline----tab--                return self.findKthSmallest(nums[:pos], k)--newline----tab--            else:--newline----tab--                return nums[pos]--newline----tab--     --newline----tab--    # choose the right-most element as pivot   --newline----tab--    def partition(self, nums, l, r):--newline----tab--        low = l--newline----tab--        while l < r:--newline----tab--            if nums[l] < nums[r]:--newline----tab--                nums[l], nums[low] = nums[low], nums[l]--newline----tab--                low += 1--newline----tab--            l += 1--newline----tab--        nums[low], nums[r] = nums[r], nums[low]--newline----tab--        return low",
            "topic_title": "Python different solutions with comments (bubble sort, selection sort, heap sort and quick sort)."
        }
    ],
    "qc": "215.json"
}