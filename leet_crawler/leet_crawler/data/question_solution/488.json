{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Standard test program is wrong?"
        },
        {
            "java": "public class Solution {--newline--    int MAXCOUNT = 6;   // the max balls you need will not exceed 6 since \"The number of balls in your hand won't exceed 5\"--newline--    --newline--    public int findMinStep(String board, String hand) {--newline--        int[] handCount = new int[32];--newline--        for (int i = 0; i < hand.length(); ++i) ++handCount[hand.charAt(i) - 'A'];--newline--        int rs = helper(board + \"#\", handCount);  // append a \"#\" to avoid special process while j==board.length, make the code shorter.--newline--        return rs == MAXCOUNT ? -1 : rs;--newline--    }--newline--    private int helper(String s, int[] h) {--newline--        s = removeConsecutive(s);     --newline--        if (s.equals(\"#\")) return 0;--newline--        int  rs = MAXCOUNT, need = 0;--newline--        for (int i = 0, j = 0 ; j < s.length(); ++j) {--newline--            if (s.charAt(j) == s.charAt(i)) continue;--newline--            need = 3 - (j - i);     //balls need to remove current consecutive balls.--newline--            if (h[s.charAt(i) - 'A'] >= need) {--newline--                h[s.charAt(i) - 'A'] -= need;--newline--                rs = Math.min(rs, need + helper(s.substring(0, i) + s.substring(j), h));--newline--                h[s.charAt(i) - 'A'] += need;--newline--            }--newline--            i = j;--newline--        }--newline--        return rs;--newline--    }--newline--    //remove consecutive balls longer than 3--newline--    private String removeConsecutive(String board) {--newline--        for (int i = 0, j = 0; j < board.length(); ++j) {--newline--            if (board.charAt(j) == board.charAt(i)) continue;--newline--            if (j - i >= 3) return removeConsecutive(board.substring(0, i) + board.substring(j));--newline--            else i = j;--newline--        }--newline--        return board;--newline--    }--newline--    --newline--}",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "&quot;short&quot; java solution, beats 98%"
        },
        {
            "java": "public class Solution {--newline--    public int findMinStep(String board, String hand) {--newline--        List<Character> boardList = new ArrayList<Character>();--newline--        for (char c : board.toCharArray()) {--newline--            boardList.add(c);--newline--        }--newline--        Map<Character,Integer> handMap = new HashMap<>();--newline--        handMap.put('R',0);--newline--        handMap.put('Y',0);--newline--        handMap.put('B',0);--newline--        handMap.put('G',0);--newline--        handMap.put('W',0);--newline--        for (char h : hand.toCharArray()) {--newline--            handMap.put(h, handMap.get(h) + 1);--newline--        }--newline--        return find(boardList, handMap);--newline--    }--newline--    --newline--    private int find(List<Character> board, Map<Character, Integer> hand) {--newline--        cleanupBoard(board);--newline--        if (board.size() == 0) return 0;--newline--        if (empty(hand)) return -1;--newline--        int count = 0;--newline--        int min = Integer.MAX_VALUE;--newline--        for (int i = 0; i<board.size(); i++) {--newline--            char c = board.get(i);--newline--            count++;--newline--            if (i == board.size() - 1 || board.get(i+1) != c) {--newline--                int missing = 3 - count;--newline--                if (hand.get(c) >= missing) {--newline--                    hand.put(c, hand.get(c) - missing);--newline--                    List<Character> smallerBoard = new ArrayList<>(board);--newline--                    for (int j = 0; j<count; j++) {--newline--                        smallerBoard.remove(i-j);--newline--                    }--newline--                    int smallerFind = find(smallerBoard, hand);--newline--                    if ( smallerFind != -1 ) {--newline--                        min = Math.min(smallerFind + missing, min);--newline--                    }--newline--                    hand.put(c, hand.get(c) + missing);--newline--                }--newline--                count = 0;--newline--            }--newline--        }--newline--        return (min == Integer.MAX_VALUE) ? -1 : min;--newline--    }--newline--    --newline--    private void cleanupBoard(List<Character> board) {--newline--        int count = 0;--newline--        boolean cleaned = false;--newline--        for (int i = 0; i<board.size(); i++) {--newline--            char c = board.get(i);--newline--            count++;--newline--            if (i == board.size() - 1 || board.get(i+1) != c) {--newline--                if (count >= 3) {--newline--                    for (int j = 0; j<count; j++) {--newline--                        board.remove(i-j);--newline--                    }--newline--                    cleaned = true;--newline--                    break;--newline--                }--newline--                count = 0;--newline--            }--newline--        }--newline--        if (cleaned) {--newline--            cleanupBoard(board);--newline--        }--newline--    }--newline--    --newline--    private boolean empty(Map<Character,Integer> hand) {--newline--        for (int val : hand.values()) {--newline--            if (val > 0) return false;--newline--        }--newline--        return true;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Recursive java solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "#define MAX_STEP 6 --newline--class Solution {--newline--public:--newline--    int findMinStep(string board, string hand) {--newline--        sort(hand.begin(), hand.end()); --newline--        int res = helper(board, hand); --newline--        return res > hand.size() ? -1 : res;--newline--    }--newline--    --newline--    int helper(string b, string h) {--newline--        if (b.empty()) return 0;--newline--        if (h.empty()) return MAX_STEP;--newline--        int res = MAX_STEP;--newline--        for (int i = 0; i < h.size(); i++) {--newline--            int j = 0;--newline--            int n = b.size();--newline--            while (j < n) {--newline--                int k = b.find(h[i], j);--newline--                if (k == string::npos) break;--newline--                if (k < n-1 && b[k] == b[k+1]) { // 2 consecutive balls with same color on board--newline--                    string nextb = shrink(b.substr(0, k) + b.substr(k+2)); // shrink the string until no 3 or more consecutive balls in same color--newline--                    if (nextb.empty()) return 1; // this is the best result for current board, no need to continue--newline--                    string nexth = h;--newline--                    nexth.erase(i, 1); // remove the used ball from hand--newline--                    res = min(res, helper(nextb, nexth) + 1);--newline--                    k++;--newline--                }--newline--                else if (i > 0 && h[i] == h[i-1]) { // 2 balls with same color in hand--newline--                    string nextb = shrink(b.substr(0, k) + b.substr(k+1)); // shrink the string until no 3 or more consecutive balls in same color--newline--                    if (nextb.empty()) return 2;  // this is the best result for current board, no need to continue--newline--                    string nexth = h;--newline--                    nexth.erase(i, 1); // remove the used balls from hand--newline--                    nexth.erase(i-1, 1);--newline--                    res = min(res, helper(nextb, nexth) + 2);--newline--                }--newline--                j = k + 1;--newline--            }--newline--        }--newline--        return res;--newline--    }--newline--    --newline--    string shrink(string s) {--newline--        while(s.size() > 0) {--newline--            int start = 0;--newline--            bool done = true;--newline--            for (int i = 0; i <= s.size(); i++) {--newline--                if (i == s.size() || s[i] != s[start]) {--newline--                    if (i - start >= 3) {--newline--                        s = s.substr(0, start) + s.substr(i);--newline--                        done = false;--newline--                        break;--newline--                    }--newline--                    start = i;--newline--                }--newline--            }--newline--            if (done) break;--newline--        }--newline--        return s;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Concise 3ms C++ Solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--        int findMinStep(string b, string h) {--newline--          // pre-process--newline--          string a; int L, r = 0;--newline--          for (char c:b) // shrink b to remove consecutive identical letters--newline--            if (c-r) if ((L=a.size()) < 2 || c-a[L-1] || c-a[L-2]) a += c, r = 0;--newline--                     else r = c, a.pop_back(), a.pop_back();--newline--          sort(h.begin(), h.end()); // sort hand for memorization--newline--          --newline--          // memorization--newline--          if (m.count(b=a) && m[b].count(h)) return m[b][h];--newline--            --newline--          // base cases--newline--          if (b.empty()) return 0; else if (h.empty()) return -1;--newline--        --newline--          // edge cases--newline--          for (char c:b) if (count(a.begin(),(a=b+h).end(),c) < 3) return m[b][h] = -1; --newline--          --newline--          // recursion--newline--          for (int i = 0, res = INT_MAX; i <= h.size(); ++i) { // each letter in hand--newline--            if (i==h.size()) return m[b][h] = res<INT_MAX? res : -1;--newline--            if (i && h[i]==h[i-1] || b.find(h[i])==string::npos) continue;--newline--            for (int j = 0, step; j < b.size(); ++j) { // each insertion position--newline--              if (b[j]-h[i] || (j && b[j]==b[j-1])) continue;--newline--              string bb(b); bb.insert(bb.begin() + j, h[i]); // insert h[i] to board--newline--              string hh(h); hh.erase(hh.begin() + hh.find(h[i])); // remove h[i] from hand--newline--              if (step = findMinStep(bb, hh)+1) res = min(res, step);--newline--            }--newline--          }--newline--        }--newline--        --newline--        // m[b][h] = min steps for borad=b & hand=h--newline--        unordered_map<string, unordered_map<string, int>> m;--newline--    --newline--}",
            "python": null,
            "topic_title": "16-line 9ms recursive solution with pre-process, memorization and edge case test, no helper functions (detailed explanation)"
        }
    ],
    "qc": "488.json"
}