{
    "posts": [
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<double> medianSlidingWindow(vector<int>& nums, int k) {--newline--        multiset<int> window(nums.begin(), nums.begin() + k);--newline--        auto mid = next(window.begin(), k / 2);--newline--        vector<double> medians;--newline--        for (int i=k; ; i++) {--newline--    --newline--            // Push the current median.--newline--            medians.push_back((double(*mid) + *prev(mid, 1 - k%2)) / 2);--newline--    --newline--            // If all done, return.--newline--            if (i == nums.size())--newline--                return medians;--newline--                --newline--            // Insert nums[i].--newline--            window.insert(nums[i]);--newline--            if (nums[i] < *mid)--newline--                mid--;--newline--    --newline--            // Erase nums[i-k].--newline--            if (nums[i-k] <= *mid)--newline--                mid++;--newline--            window.erase(window.lower_bound(nums[i-k]));--newline--        }--newline--    }--newline--}",
            "python": null,
            "topic_title": "O(n log k) C++ using multiset and updating middle-iterator"
        },
        {
            "java": "public class Solution {--newline--    public double[] medianSlidingWindow(int[] nums, int k) {--newline--        double[] res = new double[nums.length-k+1];--newline--        TreeMap<Integer, Integer> minHeap = new TreeMap<Integer, Integer>();--newline--        TreeMap<Integer, Integer> maxHeap = new TreeMap<Integer, Integer>(Collections.reverseOrder());--newline--        --newline--        int minHeapCap = k/2; //smaller heap when k is odd.--newline--        int maxHeapCap = k - minHeapCap; --newline--        --newline--        for(int i=0; i< k; i++){--newline--            maxHeap.put(nums[i], maxHeap.getOrDefault(nums[i], 0) + 1);--newline--        }--newline--        int[] minHeapSize = new int[]{0};--newline--        int[] maxHeapSize = new int[]{k};--newline--        for(int i=0; i< minHeapCap; i++){--newline--            move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--        }--newline--        --newline--        res[0] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--        int resIdx = 1;--newline--        --newline--        for(int i=0; i< nums.length-k; i++){--newline--            int addee = nums[i+k];--newline--            if(addee <= maxHeap.keySet().iterator().next()){--newline--                add(addee, maxHeap, maxHeapSize);--newline--            } else {--newline--                add(addee, minHeap, minHeapSize);--newline--            }--newline--            --newline--            int removee = nums[i];--newline--            if(removee <= maxHeap.keySet().iterator().next()){--newline--                remove(removee, maxHeap, maxHeapSize);--newline--            } else {--newline--                remove(removee, minHeap, minHeapSize);--newline--            }--newline----newline--            //rebalance--newline--            if(minHeapSize[0] > minHeapCap){--newline--                move1Over(minHeap, maxHeap, minHeapSize, maxHeapSize);--newline--            } else if(minHeapSize[0] < minHeapCap){--newline--                move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--            }--newline--            --newline--            res[resIdx] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);--newline--            resIdx++;--newline--        }--newline--        return res;--newline--    }--newline----newline--    public double getMedian(TreeMap<Integer, Integer> bigHeap, TreeMap<Integer, Integer> smallHeap, int[] bigHeapSize, int[] smallHeapSize){--newline--        return bigHeapSize[0] > smallHeapSize[0] ? (double) bigHeap.keySet().iterator().next() : ((double) bigHeap.keySet().iterator().next() + (double) smallHeap.keySet().iterator().next()) / 2.0;--newline--    }--newline--    --newline--    //move the top element of heap1 to heap2--newline--    public void move1Over(TreeMap<Integer, Integer> heap1, TreeMap<Integer, Integer> heap2, int[] heap1Size, int[] heap2Size){--newline--        int peek = heap1.keySet().iterator().next();--newline--        add(peek, heap2, heap2Size);--newline--        remove(peek, heap1, heap1Size);--newline--    }--newline--    --newline--    public void add(int val, TreeMap<Integer, Integer> heap, int[] heapSize){--newline--        heap.put(val, heap.getOrDefault(val,0) + 1);--newline--        heapSize[0]++;--newline--    }--newline--    --newline--    public void remove(int val, TreeMap<Integer, Integer> heap, int[] heapSize){--newline--        if(heap.put(val, heap.get(val) - 1) == 1) heap.remove(val);--newline--        heapSize[0]--;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy to understand O(nlogk) Java solution using TreeMap"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<double> medianSlidingWindow(vector<int>& nums, int k) {--newline--        vector<double> medians;--newline--        unordered_map<int, int> hash;                          // count numbers to be deleted--newline--        priority_queue<int, vector<int>> bheap;                // heap on the bottom--newline--        priority_queue<int, vector<int>, greater<int>> theap;  // heap on the top--newline--        --newline--        int i = 0;--newline--        --newline--        // Initialize the heaps--newline--        while (i < k)  { bheap.push(nums[i++]); }--newline--        for (int count = k/2; count > 0; --count) {--newline--            theap.push(bheap.top()); bheap.pop();--newline--        }--newline--        --newline--        while (true) {--newline--            // Get median--newline--            if (k % 2) medians.push_back(bheap.top());--newline--            else medians.push_back( ((double)bheap.top() + theap.top()) / 2 );--newline--            --newline--            if (i == nums.size()) break;--newline--            int m = nums[i-k], n = nums[i++], balance = 0;--newline--            --newline--            // What happens to the number m that is moving out of the window--newline--            if (m <= bheap.top())  { --balance;  if (m == bheap.top()) bheap.pop(); else ++hash[m]; }--newline--            else                   { ++balance;  if (m == theap.top()) theap.pop(); else ++hash[m]; }--newline--            --newline--            // Insert the new number n that enters the window--newline--            if (!bheap.empty() && n <= bheap.top())  { ++balance; bheap.push(n); }--newline--            else                                     { --balance; theap.push(n); }--newline--            --newline--            // Rebalance the bottom and top heaps--newline--            if      (balance < 0)  { bheap.push(theap.top()); theap.pop(); }--newline--            else if (balance > 0)  { theap.push(bheap.top()); bheap.pop(); }--newline--            --newline--            // Remove numbers that should be discarded at the top of the two heaps--newline--            while (!bheap.empty() && hash[bheap.top()])  { --hash[bheap.top()]; bheap.pop(); }--newline--            while (!theap.empty() && hash[theap.top()])  { --hash[theap.top()]; theap.pop(); }--newline--        }--newline--        --newline--        return medians;--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "O(n*log(n)) Time C++ Solution Using Two Heaps and a Hash Table"
        },
        {
            "java": "public class Solution {--newline--    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();--newline--    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(--newline--        new Comparator<Integer>() {--newline--            public int compare(Integer i1, Integer i2) {--newline--                return i2.compareTo(i1);--newline--            }--newline--        }--newline--    );--newline----tab----newline--    public double[] medianSlidingWindow(int[] nums, int k) {--newline--        int n = nums.length - k + 1;--newline----tab--if (n <= 0) return new double[0];--newline--        double[] result = new double[n];--newline--        --newline--        for (int i = 0; i <= nums.length; i++) {--newline--            if (i >= k) {--newline--        --tab--result[i - k] = getMedian();--newline--        --tab--remove(nums[i - k]);--newline--            }--newline--            if (i < nums.length) {--newline--        --tab--add(nums[i]);--newline--            }--newline--        }--newline--        --newline--        return result;--newline--    }--newline--    --newline--    private void add(int num) {--newline----tab--if (num < getMedian()) {--newline----tab--    maxHeap.add(num);--newline----tab--}--newline----tab--else {--newline----tab--    minHeap.add(num);--newline----tab--}--newline----tab--if (maxHeap.size() > minHeap.size()) {--newline--            minHeap.add(maxHeap.poll());--newline----tab--}--newline--        if (minHeap.size() - maxHeap.size() > 1) {--newline--            maxHeap.add(minHeap.poll());--newline--        }--newline--    }--newline----tab----newline--    private void remove(int num) {--newline----tab--if (num < getMedian()) {--newline----tab--    maxHeap.remove(num);--newline----tab--}--newline----tab--else {--newline----tab--    minHeap.remove(num);--newline----tab--}--newline----tab--if (maxHeap.size() > minHeap.size()) {--newline--            minHeap.add(maxHeap.poll());--newline----tab--}--newline--        if (minHeap.size() - maxHeap.size() > 1) {--newline--            maxHeap.add(minHeap.poll());--newline--        }--newline--    }--newline----tab----newline--    private double getMedian() {--newline----tab--if (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;--newline----tab--    --newline----tab--if (maxHeap.size() == minHeap.size()) {--newline----tab--    return ((double)maxHeap.peek() + (double)minHeap.peek()) / 2.0;--newline----tab--}--newline----tab--else {--newline--            return (double)minHeap.peek();--newline----tab--}--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java solution using two PriorityQueues"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    public:--newline--        vector<double> medianSlidingWindow(vector<int>& nums, int k) {--newline--            multiset<int> mp;--newline--            vector<double> med;--newline--            --newline--            for(int i=0; i<k-1; ++i) mp.insert(nums[i]);--newline--            --newline--            for(int i=k-1; i< nums.size(); ++i){--newline--                mp.insert(nums[i]); // Add the next number--newline--                --newline--                auto itb = mp.begin(); advance(itb, (k-1)/2); //Find the lower median--newline--                auto ite = mp.end(); advance(ite, -(k+1)/2); //Find the upper median--newline--            --newline--                double avg = ((long)(*itb) + (*ite)) / 2.0;--newline--                med.push_back(avg);--newline--            --newline--                mp.erase(mp.find(nums[i-k+1])); //Remove the oldest element--newline--            }--newline--            --newline--            return med;--newline--        }--newline--    };--newline--}",
            "python": null,
            "topic_title": "C++ Solution O(n*k)"
        }
    ],
    "qc": "480.json"
}