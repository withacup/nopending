{
    "posts": [
        {
            "java": "    public class Solution {--newline----tab--public int wiggleMaxLength(int[] nums) {--newline----tab----tab--if (nums.length == 0 || nums.length == 1) {--newline----tab----tab----tab--return nums.length;--newline----tab----tab--}--newline----tab----tab--int k = 0;--newline----tab----tab--while (k < nums.length - 1 && nums[k] == nums[k + 1]) {  //Skips all the same numbers from series beginning eg 5, 5, 5, 1--newline----tab----tab----tab--k++;--newline----tab----tab--}--newline----tab----tab--if (k == nums.length - 1) {--newline----tab----tab----tab--return 1;--newline----tab----tab--}--newline----tab----tab--int result = 2;     // This will track the result of result array--newline----tab----tab--boolean smallReq = nums[k] < nums[k + 1];       //To check series starting pattern--newline----tab----tab--for (int i = k + 1; i < nums.length - 1; i++) {--newline----tab----tab----tab--if (smallReq && nums[i + 1] < nums[i]) {--newline----tab----tab----tab----tab--nums[result] = nums[i + 1];--newline----tab----tab----tab----tab--result++;--newline----tab----tab----tab----tab--smallReq = !smallReq;    //Toggle the requirement from small to big number--newline----tab----tab----tab--} else {--newline----tab----tab----tab----tab--if (!smallReq && nums[i + 1] > nums[i]) {--newline----tab----tab----tab----tab----tab--nums[result] = nums[i + 1];--newline----tab----tab----tab----tab----tab--result++;--newline----tab----tab----tab----tab----tab--smallReq = !smallReq;    //Toggle the requirement from big to small number--newline----tab----tab----tab----tab--}--newline----tab----tab----tab--}--newline----tab----tab--}--newline----tab----tab--return result;--newline----tab--}--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Very Simple Java Solution with detail explanation"
        },
        {
            "java": "public class Solution {--newline--    public int wiggleMaxLength(int[] nums) {--newline--        --newline--        if( nums.length == 0 ) return 0;--newline--        --newline--        int[] up = new int[nums.length];--newline--        int[] down = new int[nums.length];--newline--        --newline--        up[0] = 1;--newline--        down[0] = 1;--newline--        --newline--        for(int i = 1 ; i < nums.length; i++){--newline--            if( nums[i] > nums[i-1] ){--newline--                up[i] = down[i-1]+1;--newline--                down[i] = down[i-1];--newline--            }else if( nums[i] < nums[i-1]){--newline--                down[i] = up[i-1]+1;--newline--                up[i] = up[i-1];--newline--            }else{--newline--                down[i] = down[i-1];--newline--                up[i] = up[i-1];--newline--            }--newline--        }--newline--        --newline--        return Math.max(down[nums.length-1],up[nums.length-1]);--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Easy understanding DP solution with O(n), Java version"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int wiggleMaxLength(vector<int>& nums) {--newline--        int size=nums.size(), f=1, d=1;--newline--        for(int i=1; i<size; ++i){--newline--                 if(nums[i]>nums[i-1]) f=d+1;--newline--            else if(nums[i]<nums[i-1]) d=f+1;--newline--        }--newline--        return min(size, max(f, d));--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "Two solutions. One is DP, the other is greedy (8 lines)."
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    int wiggleMaxLength(vector<int>& nums) {--newline--        int size = nums.size();--newline--        --newline--        if (size == 0) {--newline--            return 0;--newline--        }--newline--        --newline--        /** up[i] is the length of a longest wiggle subsequence of {nums[0],...,nums[i]}, with a--newline--            positive difference between its last two numbers. This subsequence may or may not--newline--            include nums[i] and there may be several such subsequences (of the same length).--newline--            We call this a subsequence of type U.--newline--         */--newline--        vector<int> up(size, 0);--newline--        /** down[i] is the length of a longest wiggle subsequence of {nums[0],...,nums[i]}, with a--newline--            negative difference between its last two numbers. This subsequence may or may not--newline--            include nums[i] and there may be several such subsequences (of the same length).--newline--            We call this a subsequence of type D.--newline--         */--newline--        vector<int> down(size, 0);--newline--        --newline--        // At i=0, there is only one number and we can use it as a subsequence, i.e up[0]=down[0]=1--newline--        up[0] = 1;--newline--        down[0] = 1;--newline--        for(int i=1; i<size; ++i){--newline--            --newline--            if (nums[i] > nums[i-1]) {--newline--                /** If nums[i] > nums[i-1], then we can use nums[i] to make a longer subsequence of type U--newline--                    Proof: We consider a subsequence of type D in {0,...,i-1} (its length is down[i-1]).--newline--                    Let N be the last number of this subsequence.--newline--                    - If nums[i] > N, then we can add nums[i] to the subsequence and it gives us a longer--newline--                    valid subsequence of type U.--newline--                    - If nums[i] <= N, then:--newline--                    (1) N cannot be nums[i-1], because nums[i-1] < nums[i] <= N i.e. nums[i-1] < N--newline--                    (2) We can replace N with nums[i-1] (we still have a valid--newline--                    subsequence of type D since N >= nums[i] > nums[i-1] i.e. N > nums[i-1]),--newline--                    and then add nums[i] to the subsequence, and we have a longer subsequence of type U.--newline--                    Therefore up[i] = down[i-1] + 1--newline--                    --newline--                    There is no gain in using nums[i] to make a longer subsequence of type D.--newline--                    Proof: Let N be the last number of a subsequence of type U--newline--                    in {0,...,i-1}.--newline--                    Assume we can use nums[i] to make a longer subsequence of type D. Then:--newline--                    (1) N cannot be nums[i-1], otherwise we would not be able to use nums[i]--newline--                    to make a longer subsequence of type D as nums[i] > nums[i-1]--newline--                    (2) Necessarily nums[i] < N, and therefore nums[i-1] < N since nums[i-1] < nums[i].--newline--                    But this means that we could have used nums[i-1] already to make a longer--newline--                    subsequence of type D.--newline--                    So even if we can use nums[i], there is no gain in using it, so we keep the old value of--newline--                    down (down[i] = down[i-1])--newline--                */--newline--                up[i] = down[i-1] + 1;--newline--                down[i] = down[i-1];--newline--            }--newline--            else if (nums[i] < nums[i-1]) {--newline--                /** The reasoning is similar if nums[i] < nums[i-1] */--newline--                down[i] = up[i-1] + 1;--newline--                up[i] = up[i-1];--newline--            }--newline--            else {--newline--                /** if nums[i] == nums[i-1], we cannot do anything more than what we did with--newline--                     nums[i-1] so we just keep the old values of up and down--newline--                */--newline--                up[i] = up[i-1];--newline--                down[i] = down[i-1];--newline--            }--newline--        }--newline--        return max(up[size-1], down[size-1]);--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ 0ms O(N) dynamic programming solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def wiggleMaxLength(self, nums):--newline----tab--        norep = [num for num, _ in itertools.groupby(nums)]--newline----tab--        triples = zip(norep, norep[1:], norep[2:])--newline----tab--        return sum((b>a) == (b>c) for a, b, c in triples) + len(norep[:2])--newline----tab--    --newline----tab--    def wiggleMaxLength(self, nums):--newline----tab--        norep = [num for num, _ in itertools.groupby(nums)]--newline----tab--        if len(norep) < 2: return len(norep)--newline----tab--        triples = zip(norep, norep[1:], norep[2:])--newline----tab--        return 2 + sum(a<b>c or a>b<c for a, b, c in triples)",
            "topic_title": "3 lines O(n) Python with explanation&#x2F;proof"
        }
    ],
    "qc": "376.json"
}