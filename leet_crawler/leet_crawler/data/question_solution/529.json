{
    "posts": [
        {
            "java": "public class Solution {--newline--    public char[][] updateBoard(char[][] board, int[] click) {--newline--        int m = board.length, n = board[0].length;--newline--        Queue<int[]> queue = new LinkedList<>();--newline--        queue.add(click);--newline--        --newline--        while (!queue.isEmpty()) {--newline--            int[] cell = queue.poll();--newline--            int row = cell[0], col = cell[1];--newline--            --newline--            if (board[row][col] == 'M') { // Mine--newline--                board[row][col] = 'X';--newline--            }--newline--            else { // Empty--newline--                // Get number of mines first.--newline--                int count = 0;--newline--                for (int i = -1; i < 2; i++) {--newline--                    for (int j = -1; j < 2; j++) {--newline--                        if (i == 0 && j == 0) continue;--newline--                        int r = row + i, c = col + j;--newline--                        if (r < 0 || r >= m || c < 0 || c < 0 || c >= n) continue;--newline--                        if (board[r][c] == 'M' || board[r][c] == 'X') count++;--newline--                    }--newline--                }--newline--                --newline--                if (count > 0) { // If it is not a 'B', stop further DFS.--newline--                    board[row][col] = (char)(count + '0');--newline--                }--newline--                else { // Continue BFS to adjacent cells.--newline--                    board[row][col] = 'B';--newline--                    for (int i = -1; i < 2; i++) {--newline--                        for (int j = -1; j < 2; j++) {--newline--                            if (i == 0 && j == 0) continue;--newline--                            int r = row + i, c = col + j;--newline--                            if (r < 0 || r >= m || c < 0 || c < 0 || c >= n) continue;--newline--                            if (board[r][c] == 'E') {--newline--                                queue.add(new int[] {r, c});--newline--                                board[r][c] = 'B'; // Avoid to be added again.--newline--                            }--newline--                        }--newline--                    }--newline--                }--newline--            }--newline--        }--newline--        --newline--        return board;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Java Solution, DFS + BFS"
        },
        {
            "java": "public class Solution {--newline--    public char[][] updateBoard(char[][] board, int[] click) {--newline--        int x = click[0], y = click[1];--newline--        if (board[x][y] == 'M') {--newline--            board[x][y] = 'X';--newline--            return board;--newline--        }--newline--        --newline--        dfs(board, x, y);--newline--        return board;--newline--    }--newline--    --newline--    int[] dx = {-1, 0, 1, -1, 1, 0, 1, -1};--newline--    int[] dy = {-1, 1, 1, 0, -1, -1, 0, 1};--newline--    private void dfs(char[][] board, int x, int y) {--newline--        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != 'E')  return;--newline--        --newline--        int num = getNumsOfBombs(board, x, y);--newline--    --newline--        if (num == 0) {--newline--            board[x][y] = 'B';--newline--            for (int i = 0; i < 8; i++) {--newline--                int nx = x + dx[i], ny = y + dy[i];--newline--                dfs(board, nx, ny);--newline--            }--newline--        } else {--newline--            board[x][y] = (char)('0' + num);--newline--        }--newline--        --newline--    }--newline--    --newline--    private int getNumsOfBombs(char[][] board, int x, int y) {--newline--        int num = 0;--newline--        for (int i = -1; i <= 1; i++) {--newline--            for (int j = -1; j <= 1; j++) {--newline--                int nx = x + i, ny = y + j;--newline--                if (nx < 0 || nx >= board.length || ny < 0 || ny >= board[0].length)    continue;--newline--                if (board[nx][ny] == 'M' || board[nx][ny] == 'X') {--newline--                    num++;--newline--                }--newline--            }--newline--        }--newline--        return num;--newline--    }--newline--}--newline--",
            "is_locked": false,
            "cpp": null,
            "python": null,
            "topic_title": "Straight forward Java solution"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def updateBoard(self, A, click):--newline----tab--        click = tuple(click)--newline----tab--        R, C = len(A), len(A[0])--newline----tab--        --newline----tab--        def neighbors(r, c):--newline----tab--            for dr in xrange(-1, 2):--newline----tab--                for dc in xrange(-1, 2):--newline----tab--                    if (dr or dc) and 0 <= r + dr < R and 0 <= c + dc < C:--newline----tab--                        yield r + dr, c + dc--newline----tab--        --newline----tab--        stack = [click]--newline----tab--        seen = {click}--newline----tab--        while stack:--newline----tab--            r, c = stack.pop()--newline----tab--            if A[r][c] == 'M':--newline----tab--                A[r][c] = 'X'--newline----tab--            else:--newline----tab--                mines_adj = sum( A[nr][nc] in 'MX' for nr, nc in neighbors(r, c) )--newline----tab--                if mines_adj:--newline----tab--                    A[r][c] = str(mines_adj)--newline----tab--                else:--newline----tab--                    A[r][c] = 'B'--newline----tab--                    for nei in neighbors(r, c):--newline----tab--                        if A[nei[0]][nei[1]] in 'ME' and nei not in seen:--newline----tab--                            stack.append(nei)--newline----tab--                            seen.add(nei)--newline----tab--        return A--newline----tab--    ",
            "topic_title": "Simple Python (DFS)"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": "class Solution {--newline--public:--newline--    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {--newline--        if(board[click[0]][click[1]] == 'M'){--newline--            board[click[0]][click[1]] = 'X';--newline--            return board;--newline--        }--newline--        reveal(board,click[0],click[1]);--newline--        return board;--newline--    }--newline--    --newline--    bool inboard(const vector<vector<char>>& board, int x, int y){--newline--        return ( x>=0 && x<board.size() && y>=0 && y<board[0].size() );--newline--    }--newline--    --newline--    void reveal(vector<vector<char>>& board, int x, int y){--newline--        if(!inboard(board,x,y)) return;--newline--        if(board[x][y] == 'E'){--newline--            //search 8 adjacent squares--newline--            int count = 0;--newline--            if(inboard(board,x-1,y-1) && board[x-1][y-1] == 'M') count++;--newline--            if(inboard(board,x-1,y  ) && board[x-1][y  ] == 'M') count++;--newline--            if(inboard(board,x-1,y+1) && board[x-1][y+1] == 'M') count++;--newline--            if(inboard(board,x  ,y-1) && board[x  ][y-1] == 'M') count++;--newline--            if(inboard(board,x  ,y+1) && board[x  ][y+1] == 'M') count++;--newline--            if(inboard(board,x+1,y-1) && board[x+1][y-1] == 'M') count++;--newline--            if(inboard(board,x+1,y  ) && board[x+1][y  ] == 'M') count++;--newline--            if(inboard(board,x+1,y+1) && board[x+1][y+1] == 'M') count++;--newline----newline--            if(count>0)--newline--                board[x][y] = '0'+count;--newline--            else{--newline--                board[x][y] = 'B';--newline--                reveal(board,x-1,y-1);--newline--                reveal(board,x-1,y  );--newline--                reveal(board,x-1,y+1);--newline--                reveal(board,x  ,y-1);--newline--                reveal(board,x  ,y+1);--newline--                reveal(board,x+1,y-1);--newline--                reveal(board,x+1,y  );--newline--                reveal(board,x+1,y+1);--newline--            }--newline--        }--newline--    }--newline--};--newline--",
            "python": null,
            "topic_title": "C++ DFS solution, easy to understand"
        },
        {
            "java": null,
            "is_locked": false,
            "cpp": null,
            "python": "class Solution :--newline----tab--    def updateBoard(self, board, click):--newline----tab--        (row, col), directions = click, ((-1, 0), (1, 0), (0, 1), (0, -1), (-1, 1), (-1, -1), (1, 1), (1, -1))--newline----tab--        if 0 <= row < len(board) and 0 <= col < len(board[0]):--newline----tab--            if board[row][col] == 'M':--newline----tab--                board[row][col] = 'X'--newline----tab--            elif board[row][col] == 'E':--newline----tab--                n = sum([board[row + r][col + c] == 'M' for r, c in directions if 0 <= row + r < len(board) and 0 <= col + c < len(board[0])])--newline----tab--                board[row][col] = str(n or 'B')--newline----tab--                for r, c in directions * (not n): self.updateBoard(board, [row + r, col + c])--newline----tab--        return board--newline----tab--    ",
            "topic_title": "10 line python solution"
        }
    ],
    "qc": "529.json"
}