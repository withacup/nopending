---CONTENT_BEGIN---
Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

Example 1:
Given the list [[1,1],2,[1,1]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].



Example 2:
Given the list [1,[4,[6]]],

By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].


---CONTENT_END---
---SCRIPT_BEGIN---
[{"value": "cpp", "defaultCode": "/**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * class NestedInteger {  *   public:  *     // Return true if this NestedInteger holds a single integer, rather than a nested list.  *     bool isInteger() const;  *  *     // Return the single integer that this NestedInteger holds, if it holds a single integer  *     // The result is undefined if this NestedInteger holds a nested list  *     int getInteger() const;  *  *     // Return the nested list that this NestedInteger holds, if it holds a nested list  *     // The result is undefined if this NestedInteger holds a single integer  *     const vector<NestedInteger> &getList() const;  * };  */ class NestedIterator { public:     NestedIterator(vector<NestedInteger> &nestedList) {              }      int next() {              }      bool hasNext() {              } };  /**  * Your NestedIterator object will be instantiated and called as such:  * NestedIterator i(nestedList);  * while (i.hasNext()) cout << i.next();  */", "text": "C++"}, {"value": "java", "defaultCode": "/**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * public interface NestedInteger {  *  *     // @return true if this NestedInteger holds a single integer, rather than a nested list.  *     public boolean isInteger();  *  *     // @return the single integer that this NestedInteger holds, if it holds a single integer  *     // Return null if this NestedInteger holds a nested list  *     public Integer getInteger();  *  *     // @return the nested list that this NestedInteger holds, if it holds a nested list  *     // Return null if this NestedInteger holds a single integer  *     public List<NestedInteger> getList();  * }  */ public class NestedIterator implements Iterator<Integer> {      public NestedIterator(List<NestedInteger> nestedList) {              }      @Override     public Integer next() {              }      @Override     public boolean hasNext() {              } }  /**  * Your NestedIterator object will be instantiated and called as such:  * NestedIterator i = new NestedIterator(nestedList);  * while (i.hasNext()) v[f()] = i.next();  */", "text": "Java"}, {"value": "python", "defaultCode": "# ''' # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # ''' #class NestedInteger(object): #    def isInteger(self): #        ''' #        @return True if this NestedInteger holds a single integer, rather than a nested list. #        :rtype bool #        ''' # #    def getInteger(self): #        ''' #        @return the single integer that this NestedInteger holds, if it holds a single integer #        Return None if this NestedInteger holds a nested list #        :rtype int #        ''' # #    def getList(self): #        ''' #        @return the nested list that this NestedInteger holds, if it holds a nested list #        Return None if this NestedInteger holds a single integer #        :rtype List[NestedInteger] #        '''  class NestedIterator(object):      def __init__(self, nestedList):         '''         Initialize your data structure here.         :type nestedList: List[NestedInteger]         '''               def next(self):         '''         :rtype: int         '''               def hasNext(self):         '''         :rtype: bool         '''           # Your NestedIterator object will be instantiated and called as such: # i, v = NestedIterator(nestedList), [] # while i.hasNext(): v.append(i.next())", "text": "Python"}, {"value": "c", "defaultCode": "/**  * *********************************************************************  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * *********************************************************************  *  * // Return true if this NestedInteger holds a single integer, rather than a nested list.  * bool NestedIntegerIsInteger(struct NestedInteger *);  *  * // Return the single integer that this NestedInteger holds, if it holds a single integer  * // The result is undefined if this NestedInteger holds a nested list  * int NestedIntegerGetInteger(struct NestedInteger *);  *  * // Return the nested list that this NestedInteger holds, if it holds a nested list  * // The result is undefined if this NestedInteger holds a single integer  * struct NestedInteger **NestedIntegerGetList(struct NestedInteger *);  *  * // Return the nested ' size that this NestedInteger holds, if it holds a nested list  * // The result is undefined if this NestedInteger holds a single integer  * int NestedIntegerGetListSize(struct NestedInteger *);  * };  */ struct NestedIterator {      };  struct NestedIterator *nestedIterCreate(struct NestedInteger** nestedList, int nestedListSize) {      }  bool nestedIterHasNext(struct NestedIterator *iter) {      }  int nestedIterNext(struct NestedIterator *iter) {      }  /** Deallocates memory previously allocated for the iterator */ void nestedIterFree(struct NestedIterator *iter) {      }  /**  * Your NestedIterator will be called like this:  * struct NestedIterator *i = nestedIterCreate(nestedList, nestedListSize);  * while (nestedIterHasNext(i)) printf('%d\n', nestedIterNext(i));  * nestedIterFree(i);  */", "text": "C"}, {"value": "csharp", "defaultCode": "/**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * interface NestedInteger {  *  *     // @return true if this NestedInteger holds a single integer, rather than a nested list.  *     bool IsInteger();  *  *     // @return the single integer that this NestedInteger holds, if it holds a single integer  *     // Return null if this NestedInteger holds a nested list  *     int GetInteger();  *  *     // @return the nested list that this NestedInteger holds, if it holds a nested list  *     // Return null if this NestedInteger holds a single integer  *     IList<NestedInteger> GetList();  * }  */ public class NestedIterator {      public NestedIterator(IList<NestedInteger> nestedList) {              }      public bool HasNext() {              }      public int Next() {              } }  /**  * Your NestedIterator will be called like this:  * NestedIterator i = new NestedIterator(nestedList);  * while (i.HasNext()) v[f()] = i.Next();  */", "text": "C#"}, {"value": "javascript", "defaultCode": "/**  * // This is the interface that allows for creating nested lists.  * // You should not implement it, or speculate about its implementation  * function NestedInteger() {  *  *     Return true if this NestedInteger holds a single integer, rather than a nested list.  *     @return {boolean}  *     this.isInteger = function() {  *         ...  *     };  *  *     Return the single integer that this NestedInteger holds, if it holds a single integer  *     Return null if this NestedInteger holds a nested list  *     @return {integer}  *     this.getInteger = function() {  *         ...  *     };  *  *     Return the nested list that this NestedInteger holds, if it holds a nested list  *     Return null if this NestedInteger holds a single integer  *     @return {NestedInteger[]}  *     this.getList = function() {  *         ...  *     };  * };  */ /**  * @constructor  * @param {NestedInteger[]} nestedList  */ var NestedIterator = function(nestedList) {      };   /**  * @this NestedIterator  * @returns {boolean}  */ NestedIterator.prototype.hasNext = function() {      };  /**  * @this NestedIterator  * @returns {integer}  */ NestedIterator.prototype.next = function() {      };  /**  * Your NestedIterator will be called like this:  * var i = new NestedIterator(nestedList), a = [];  * while (i.hasNext()) a.push(i.next()); */", "text": "JavaScript"}, {"value": "ruby", "defaultCode": "# This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # #class NestedInteger #    def is_integer() #        ''' #        Return true if this NestedInteger holds a single integer, rather than a nested list. #        @return {Boolean} #        ''' # #    def get_integer() #        ''' #        Return the single integer that this NestedInteger holds, if it holds a single integer #        Return nil if this NestedInteger holds a nested list #        @return {Integer} #        ''' # #    def get_list() #        ''' #        Return the nested list that this NestedInteger holds, if it holds a nested list #        Return nil if this NestedInteger holds a single integer #        @return {NestedInteger[]} #        '''  class NestedIterator     # @param {NestedInteger[]} nested_list     def initialize(nested_list)              end      # @return {Boolean}     def has_next              end      # @return {Integer}     def next              end end  # Your NestedIterator will be called like this: # i, v = NestedIterator.new(nested_list), [] # while i.has_next() #    v << i.next # end", "text": "Ruby"}]
---SCRIPT_END---
