---CONTENT_BEGIN---
Given a data stream input of non-negative integers a1, a2, ..., an, ..., summarize the numbers seen so far as a list of disjoint intervals.

For example, suppose the integers from the data stream are 1, 3, 7, 2, 6, ..., then the summary will be:

[1, 1]
[1, 1], [3, 3]
[1, 1], [3, 3], [7, 7]
[1, 3], [7, 7]
[1, 3], [6, 7]


Follow up:
What if there are lots of merges and the number of disjoint intervals are small compared to the data stream's size?


Credits:Special thanks to @yunhong for adding this problem and creating most of the test cases.
---CONTENT_END---
---SCRIPT_BEGIN---
[{"text": "C++", "value": "cpp", "defaultCode": "/**  * Definition for an interval.  * struct Interval {  *     int start;  *     int end;  *     Interval() : start(0), end(0) {}  *     Interval(int s, int e) : start(s), end(e) {}  * };  */ class SummaryRanges { public:     /** Initialize your data structure here. */     SummaryRanges() {              }          void addNum(int val) {              }          vector<Interval> getIntervals() {              } };  /**  * Your SummaryRanges object will be instantiated and called as such:  * SummaryRanges obj = new SummaryRanges();  * obj.addNum(val);  * vector<Interval> param_2 = obj.getIntervals();  */"}, {"text": "Java", "value": "java", "defaultCode": "/**  * Definition for an interval.  * public class Interval {  *     int start;  *     int end;  *     Interval() { start = 0; end = 0; }  *     Interval(int s, int e) { start = s; end = e; }  * }  */ public class SummaryRanges {      /** Initialize your data structure here. */     public SummaryRanges() {              }          public void addNum(int val) {              }          public List<Interval> getIntervals() {              } }  /**  * Your SummaryRanges object will be instantiated and called as such:  * SummaryRanges obj = new SummaryRanges();  * obj.addNum(val);  * List<Interval> param_2 = obj.getIntervals();  */"}, {"text": "Python", "value": "python", "defaultCode": "# Definition for an interval. # class Interval(object): #     def __init__(self, s=0, e=0): #         self.start = s #         self.end = e  class SummaryRanges(object):      def __init__(self):         '''         Initialize your data structure here.         '''               def addNum(self, val):         '''         :type val: int         :rtype: void         '''               def getIntervals(self):         '''         :rtype: List[Interval]         '''            # Your SummaryRanges object will be instantiated and called as such: # obj = SummaryRanges() # obj.addNum(val) # param_2 = obj.getIntervals()"}, {"text": "C", "value": "c", "defaultCode": "/**  * Definition for an interval.  * struct Interval {  *     int start;  *     int end;  * };  */ typedef struct {      } SummaryRanges;  /** Initialize your data structure here. */ SummaryRanges* summaryRangesCreate() {      }  void summaryRangesAddNum(SummaryRanges* obj, int val) {      }  struct Interval* summaryRangesGetIntervals(SummaryRanges* obj, int *returnSize) {      }  void summaryRangesFree(SummaryRanges* obj) {      }  /**  * Your SummaryRanges struct will be instantiated and called as such:  * struct SummaryRanges* obj = summaryRangesCreate();  * summaryRangesAddNum(obj, val);  * struct Interval* param_2 = summaryRangesGetIntervals(obj);  * summaryRangesFree(obj);  */"}, {"text": "Go", "value": "golang", "defaultCode": "/**  * Definition for an interval.  * type Interval struct {  *       Start int  *       End   int  * }  */ type SummaryRanges struct {  }   /** Initialize your data structure here. */ func Constructor() SummaryRanges {  }   func (this *SummaryRanges) Addnum(val int)  {  }   func (this *SummaryRanges) Getintervals() []Interval {  }   /**  * Your SummaryRanges object will be instantiated and called as such:  * obj := Constructor();  * obj.Addnum(val);  * param_2 := obj.Getintervals();  */"}]
---SCRIPT_END---
