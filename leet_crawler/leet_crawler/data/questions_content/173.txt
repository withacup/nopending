---CONTENT_BEGIN---
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 

Credits:Special thanks to @ts for adding this problem and creating all test cases.
---CONTENT_END---
---SCRIPT_BEGIN---
[{"value": "cpp", "defaultCode": "/**  * Definition for binary tree  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class BSTIterator { public:     BSTIterator(TreeNode *root) {              }      /** @return whether we have a next smallest number */     bool hasNext() {              }      /** @return the next smallest number */     int next() {              } };  /**  * Your BSTIterator will be called like this:  * BSTIterator i = BSTIterator(root);  * while (i.hasNext()) cout << i.next();  */", "text": "C++"}, {"value": "java", "defaultCode": "/**  * Definition for binary tree  * public class TreeNode {  *     int val;  *     TreeNode left;  *     TreeNode right;  *     TreeNode(int x) { val = x; }  * }  */  public class BSTIterator {      public BSTIterator(TreeNode root) {              }      /** @return whether we have a next smallest number */     public boolean hasNext() {              }      /** @return the next smallest number */     public int next() {              } }  /**  * Your BSTIterator will be called like this:  * BSTIterator i = new BSTIterator(root);  * while (i.hasNext()) v[f()] = i.next();  */", "text": "Java"}, {"value": "python", "defaultCode": "# Definition for a  binary tree node # class TreeNode(object): #     def __init__(self, x): #         self.val = x #         self.left = None #         self.right = None  class BSTIterator(object):     def __init__(self, root):         '''         :type root: TreeNode         '''               def hasNext(self):         '''         :rtype: bool         '''               def next(self):         '''         :rtype: int         '''           # Your BSTIterator will be called like this: # i, v = BSTIterator(root), [] # while i.hasNext(): v.append(i.next())", "text": "Python"}, {"value": "c", "defaultCode": "/**  * Definition for binary tree  * struct TreeNode {  *     int val;  *     struct TreeNode *left;  *     struct TreeNode *right;  * };  */ struct BSTIterator {      };  struct BSTIterator *bstIteratorCreate(struct TreeNode *root) {      }  /** @return whether we have a next smallest number */ bool bstIteratorHasNext(struct BSTIterator *iter) {      }  /** @return the next smallest number */ int bstIteratorNext(struct BSTIterator *iter) {      }  /** Deallocates memory previously allocated for the iterator */ void bstIteratorFree(struct BSTIterator *iter) {      }  /**  * Your BSTIterator will be called like this:  * struct BSTIterator *i = bstIteratorCreate(root);  * while (bstIteratorHasNext(i)) printf('%d\n', bstIteratorNext(i));  * bstIteratorFree(i);  */", "text": "C"}, {"value": "csharp", "defaultCode": "/**  * Definition for binary tree  * public class TreeNode {  *     public int val;  *     public TreeNode left;  *     public TreeNode right;  *     public TreeNode(int x) { val = x; }  * }  */  public class BSTIterator {      public BSTIterator(TreeNode root) {              }      /** @return whether we have a next smallest number */     public bool HasNext() {              }      /** @return the next smallest number */     public int Next() {              } }  /**  * Your BSTIterator will be called like this:  * BSTIterator i = new BSTIterator(root);  * while (i.HasNext()) v[f()] = i.Next();  */", "text": "C#"}, {"value": "javascript", "defaultCode": "/**  * Definition for binary tree  * function TreeNode(val) {  *     this.val = val;  *     this.left = this.right = null;  * }  */  /**  * @constructor  * @param {TreeNode} root - root of the binary search tree  */ var BSTIterator = function(root) {      };   /**  * @this BSTIterator  * @returns {boolean} - whether we have a next smallest number  */ BSTIterator.prototype.hasNext = function() {      };  /**  * @this BSTIterator  * @returns {number} - the next smallest number  */ BSTIterator.prototype.next = function() {      };  /**  * Your BSTIterator will be called like this:  * var i = new BSTIterator(root), a = [];  * while (i.hasNext()) a.push(i.next()); */", "text": "JavaScript"}, {"value": "ruby", "defaultCode": "# Definition for a binary tree node. # class TreeNode #     attr_accessor :val, :left, :right #     def initialize(val) #         @val = val #         @left, @right = nil, nil #     end # end  class BSTIterator     # @param {TreeNode} root     def initialize(root)              end      # @return {Boolean}     def has_next              end      # @return {Integer}     def next              end end  # Your BSTIterator will be called like this: # i, v = BSTIterator.new(root), [] # while i.has_next() #    v << i.next # end", "text": "Ruby"}]
---SCRIPT_END---
