---CONTENT_BEGIN---
Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.

Follow up:
What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?


Example:

// Init a singly linked list [1,2,3].
ListNode head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
Solution solution = new Solution(head);

// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
solution.getRandom();


---CONTENT_END---
---SCRIPT_BEGIN---
[{"value": "cpp", "defaultCode": "/**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode(int x) : val(x), next(NULL) {}  * };  */ class Solution { public:     /** @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node. */     Solution(ListNode* head) {              }          /** Returns a random ' value. */     int getRandom() {              } };  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(head);  * int param_1 = obj.getRandom();  */", "text": "C++"}, {"value": "java", "defaultCode": "/**  * Definition for singly-linked list.  * public class ListNode {  *     int val;  *     ListNode next;  *     ListNode(int x) { val = x; }  * }  */ public class Solution {      /** @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node. */     public Solution(ListNode head) {              }          /** Returns a random ' value. */     public int getRandom() {              } }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(head);  * int param_1 = obj.getRandom();  */", "text": "Java"}, {"value": "python", "defaultCode": "# Definition for singly-linked list. # class ListNode(object): #     def __init__(self, x): #         self.val = x #         self.next = None  class Solution(object):      def __init__(self, head):         '''         @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node.         :type head: ListNode         '''               def getRandom(self):         '''         Returns a random ' value.         :rtype: int         '''            # Your Solution object will be instantiated and called as such: # obj = Solution(head) # param_1 = obj.getRandom()", "text": "Python"}, {"value": "c", "defaultCode": "/**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     struct ListNode *next;  * };  */ typedef struct {      } Solution;  /** @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution* solutionCreate(struct ListNode* head) {      }  /** Returns a random ' value. */ int solutionGetRandom(Solution* obj) {      }  void solutionFree(Solution* obj) {      }  /**  * Your Solution struct will be instantiated and called as such:  * struct Solution* obj = solutionCreate(head);  * int param_1 = solutionGetRandom(obj);  * solutionFree(obj);  */", "text": "C"}, {"value": "csharp", "defaultCode": "/**  * Definition for singly-linked list.  * public class ListNode {  *     public int val;  *     public ListNode next;  *     public ListNode(int x) { val = x; }  * }  */ public class Solution {      /** @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node. */     public Solution(ListNode head) {              }          /** Returns a random ' value. */     public int GetRandom() {              } }  /**  * Your Solution object will be instantiated and called as such:  * Solution obj = new Solution(head);  * int param_1 = obj.GetRandom();  */", "text": "C#"}, {"value": "javascript", "defaultCode": "/**  * Definition for singly-linked list.  * function ListNode(val) {  *     this.val = val;  *     this.next = null;  * }  */ /**  * @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node.  * @param {ListNode} head  */ var Solution = function(head) {      };  /**  * Returns a random ' value.  * @return {number}  */ Solution.prototype.getRandom = function() {      };  /**   * Your Solution object will be instantiated and called as such:  * var obj = Object.create(Solution).createNew(head)  * var param_1 = obj.getRandom()  */", "text": "JavaScript"}, {"value": "ruby", "defaultCode": "# Definition for singly-linked list. # class ListNode #     attr_accessor :val, :next #     def initialize(val) #         @val = val #         @next = nil #     end # end  class Solution  =begin     @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node.     :type head: ListNode =end     def initialize(head)              end   =begin     Returns a random ' value.     :rtype: Integer =end     def get_random()              end   end  # Your Solution object will be instantiated and called as such: # obj = Solution.new(head) # param_1 = obj.get_random()", "text": "Ruby"}, {"value": "golang", "defaultCode": "/**  * Definition for singly-linked list.  * type ListNode struct {  *     Val int  *     Next *ListNode  * }  */ type Solution struct {      }   /** @param head The linked ' head.         Note that the head is guaranteed to be not null, so it contains at least one node. */ func Constructor(head *ListNode) Solution {      }   /** Returns a random ' value. */ func (this *Solution) GetRandom() int {      }   /**  * Your Solution object will be instantiated and called as such:  * obj := Constructor(head);  * param_1 := obj.GetRandom();  */", "text": "Go"}]
---SCRIPT_END---
