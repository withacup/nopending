---CONTENT_BEGIN---

Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.



get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.


Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4


---CONTENT_END---
---SCRIPT_BEGIN---
[{"value": "cpp", "defaultCode": "class LRUCache { public:     LRUCache(int capacity) {              }          int get(int key) {              }          void put(int key, int value) {              } };  /**  * Your LRUCache object will be instantiated and called as such:  * LRUCache obj = new LRUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */", "text": "C++"}, {"value": "java", "defaultCode": "public class LRUCache {      public LRUCache(int capacity) {              }          public int get(int key) {              }          public void put(int key, int value) {              } }  /**  * Your LRUCache object will be instantiated and called as such:  * LRUCache obj = new LRUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */", "text": "Java"}, {"value": "python", "defaultCode": "class LRUCache(object):      def __init__(self, capacity):         '''         :type capacity: int         '''               def get(self, key):         '''         :type key: int         :rtype: int         '''               def put(self, key, value):         '''         :type key: int         :type value: int         :rtype: void         '''            # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)", "text": "Python"}, {"value": "c", "defaultCode": "typedef struct {      } LRUCache;  LRUCache* lRUCacheCreate(int capacity) {      }  int lRUCacheGet(LRUCache* obj, int key) {      }  void lRUCachePut(LRUCache* obj, int key, int value) {      }  void lRUCacheFree(LRUCache* obj) {      }  /**  * Your LRUCache struct will be instantiated and called as such:  * struct LRUCache* obj = lRUCacheCreate(capacity);  * int param_1 = lRUCacheGet(obj, key);  * lRUCachePut(obj, key, value);  * lRUCacheFree(obj);  */", "text": "C"}, {"value": "csharp", "defaultCode": "public class LRUCache {      public LRUCache(int capacity) {              }          public int Get(int key) {              }          public void Put(int key, int value) {              } }  /**  * Your LRUCache object will be instantiated and called as such:  * LRUCache obj = new LRUCache(capacity);  * int param_1 = obj.Get(key);  * obj.Put(key,value);  */", "text": "C#"}, {"value": "javascript", "defaultCode": "/**  * @param {number} capacity  */ var LRUCache = function(capacity) {      };  /**   * @param {number} key  * @return {number}  */ LRUCache.prototype.get = function(key) {      };  /**   * @param {number} key   * @param {number} value  * @return {void}  */ LRUCache.prototype.put = function(key, value) {      };  /**   * Your LRUCache object will be instantiated and called as such:  * var obj = Object.create(LRUCache).createNew(capacity)  * var param_1 = obj.get(key)  * obj.put(key,value)  */", "text": "JavaScript"}, {"value": "ruby", "defaultCode": "class LRUCache  =begin     :type capacity: Integer =end     def initialize(capacity)              end   =begin     :type key: Integer     :rtype: Integer =end     def get(key)              end   =begin     :type key: Integer     :type value: Integer     :rtype: Void =end     def put(key, value)              end   end  # Your LRUCache object will be instantiated and called as such: # obj = LRUCache.new(capacity) # param_1 = obj.get(key) # obj.put(key,value)", "text": "Ruby"}, {"value": "golang", "defaultCode": "type LRUCache struct {      }   func Constructor(capacity int) LRUCache {      }   func (this *LRUCache) Get(key int) int {      }   func (this *LRUCache) Put(key int, value int)  {      }   /**  * Your LRUCache object will be instantiated and called as such:  * obj := Constructor(capacity);  * param_1 := obj.Get(key);  * obj.Put(key,value);  */", "text": "Go"}]
---SCRIPT_END---
