---CONTENT_BEGIN---
Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.



get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.


Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4


---CONTENT_END---
---SCRIPT_BEGIN---
[{"text": "C++", "value": "cpp", "defaultCode": "class LFUCache { public:     LFUCache(int capacity) {              }          int get(int key) {              }          void put(int key, int value) {              } };  /**  * Your LFUCache object will be instantiated and called as such:  * LFUCache obj = new LFUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */"}, {"text": "Java", "value": "java", "defaultCode": "public class LFUCache {      public LFUCache(int capacity) {              }          public int get(int key) {              }          public void put(int key, int value) {              } }  /**  * Your LFUCache object will be instantiated and called as such:  * LFUCache obj = new LFUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */"}, {"text": "Python", "value": "python", "defaultCode": "class LFUCache(object):      def __init__(self, capacity):         '''         :type capacity: int         '''               def get(self, key):         '''         :type key: int         :rtype: int         '''               def put(self, key, value):         '''         :type key: int         :type value: int         :rtype: void         '''            # Your LFUCache object will be instantiated and called as such: # obj = LFUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)"}, {"text": "C", "value": "c", "defaultCode": "typedef struct {      } LFUCache;  LFUCache* lFUCacheCreate(int capacity) {      }  int lFUCacheGet(LFUCache* obj, int key) {      }  void lFUCachePut(LFUCache* obj, int key, int value) {      }  void lFUCacheFree(LFUCache* obj) {      }  /**  * Your LFUCache struct will be instantiated and called as such:  * struct LFUCache* obj = lFUCacheCreate(capacity);  * int param_1 = lFUCacheGet(obj, key);  * lFUCachePut(obj, key, value);  * lFUCacheFree(obj);  */"}, {"text": "C#", "value": "csharp", "defaultCode": "public class LFUCache {      public LFUCache(int capacity) {              }          public int Get(int key) {              }          public void Put(int key, int value) {              } }  /**  * Your LFUCache object will be instantiated and called as such:  * LFUCache obj = new LFUCache(capacity);  * int param_1 = obj.Get(key);  * obj.Put(key,value);  */"}, {"text": "JavaScript", "value": "javascript", "defaultCode": "/**  * @param {number} capacity  */ var LFUCache = function(capacity) {      };  /**   * @param {number} key  * @return {number}  */ LFUCache.prototype.get = function(key) {      };  /**   * @param {number} key   * @param {number} value  * @return {void}  */ LFUCache.prototype.put = function(key, value) {      };  /**   * Your LFUCache object will be instantiated and called as such:  * var obj = Object.create(LFUCache).createNew(capacity)  * var param_1 = obj.get(key)  * obj.put(key,value)  */"}, {"text": "Ruby", "value": "ruby", "defaultCode": "class LFUCache  =begin     :type capacity: Integer =end     def initialize(capacity)              end   =begin     :type key: Integer     :rtype: Integer =end     def get(key)              end   =begin     :type key: Integer     :type value: Integer     :rtype: Void =end     def put(key, value)              end   end  # Your LFUCache object will be instantiated and called as such: # obj = LFUCache.new(capacity) # param_1 = obj.get(key) # obj.put(key,value)"}, {"text": "Go", "value": "golang", "defaultCode": "type LFUCache struct {      }   func Constructor(capacity int) LFUCache {      }   func (this *LFUCache) Get(key int) int {      }   func (this *LFUCache) Put(key int, value int)  {      }   /**  * Your LFUCache object will be instantiated and called as such:  * obj := Constructor(capacity);  * param_1 := obj.Get(key);  * obj.Put(key,value);  */"}]
---SCRIPT_END---
